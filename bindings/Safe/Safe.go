// This file was generated by seer: https://github.com/moonstream-to/seer.
// seer version: 0.2.0
// seer command: seer evm generate --package Safe --cli --struct Safe --output bindings/Safe/Safe.go
// Code generated - DO NOT EDIT.
// This file is a generated binding and any manual changes will be lost.

package Safe

import (
	"bytes"
	"crypto/rand"
	"errors"
	"math/big"
	"net/http"
	"strings"

	"context"

	ethereum "github.com/ethereum/go-ethereum"
	"github.com/ethereum/go-ethereum/accounts/abi"
	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/core/types"
	"github.com/ethereum/go-ethereum/event"
	"github.com/ethereum/go-ethereum/signer/core/apitypes"

	// Reference imports to suppress errors if they are not otherwise used.
	"encoding/hex"
	"encoding/json"
	"fmt"
	"os"
	"time"

	"github.com/ethereum/go-ethereum/accounts/keystore"
	"github.com/ethereum/go-ethereum/ethclient"
	"github.com/moonstream-to/seer/bindings/CreateCall"
	"github.com/moonstream-to/seer/bindings/GnosisSafe"
	"github.com/spf13/cobra"
	"golang.org/x/term"

	// SafeMetaData contains all meta data concerning the Safe contract.
	"github.com/ethereum/go-ethereum/common/math"
	"github.com/ethereum/go-ethereum/crypto"
)

var (
	_ = errors.New
	_ = big.NewInt
	_ = strings.NewReader
	_ = ethereum.NotFound
	_ = bind.Bind
	_ = common.Big1
	_ = types.BloomLookup
	_ = event.NewSubscription
	_ = abi.ConvertType
)

var SafeMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"AddedOwner\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"approvedHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"ApproveHash\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"handler\",\"type\":\"address\"}],\"name\":\"ChangedFallbackHandler\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"guard\",\"type\":\"address\"}],\"name\":\"ChangedGuard\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"moduleGuard\",\"type\":\"address\"}],\"name\":\"ChangedModuleGuard\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"threshold\",\"type\":\"uint256\"}],\"name\":\"ChangedThreshold\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"}],\"name\":\"DisabledModule\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"}],\"name\":\"EnabledModule\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"txHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"payment\",\"type\":\"uint256\"}],\"name\":\"ExecutionFailure\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"}],\"name\":\"ExecutionFromModuleFailure\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"}],\"name\":\"ExecutionFromModuleSuccess\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"txHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"payment\",\"type\":\"uint256\"}],\"name\":\"ExecutionSuccess\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"RemovedOwner\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"SafeReceived\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"initiator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"owners\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"threshold\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"initializer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"fallbackHandler\",\"type\":\"address\"}],\"name\":\"SafeSetup\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"msgHash\",\"type\":\"bytes32\"}],\"name\":\"SignMsg\",\"type\":\"event\"},{\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"VERSION\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_threshold\",\"type\":\"uint256\"}],\"name\":\"addOwnerWithThreshold\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"hashToApprove\",\"type\":\"bytes32\"}],\"name\":\"approveHash\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"approvedHashes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_threshold\",\"type\":\"uint256\"}],\"name\":\"changeThreshold\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"dataHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"signatures\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"requiredSignatures\",\"type\":\"uint256\"}],\"name\":\"checkNSignatures\",\"outputs\":[],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"executor\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"dataHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"signatures\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"requiredSignatures\",\"type\":\"uint256\"}],\"name\":\"checkNSignatures\",\"outputs\":[],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"dataHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"signatures\",\"type\":\"bytes\"}],\"name\":\"checkSignatures\",\"outputs\":[],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"dataHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"signatures\",\"type\":\"bytes\"}],\"name\":\"checkSignatures\",\"outputs\":[],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"prevModule\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"}],\"name\":\"disableModule\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"domainSeparator\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"}],\"name\":\"enableModule\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"enumEnum.Operation\",\"name\":\"operation\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"safeTxGas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"baseGas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gasPrice\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"gasToken\",\"type\":\"address\"},{\"internalType\":\"addresspayable\",\"name\":\"refundReceiver\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"signatures\",\"type\":\"bytes\"}],\"name\":\"execTransaction\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"enumEnum.Operation\",\"name\":\"operation\",\"type\":\"uint8\"}],\"name\":\"execTransactionFromModule\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"enumEnum.Operation\",\"name\":\"operation\",\"type\":\"uint8\"}],\"name\":\"execTransactionFromModuleReturnData\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"returnData\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"start\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"pageSize\",\"type\":\"uint256\"}],\"name\":\"getModulesPaginated\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"array\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"next\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOwners\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"offset\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"length\",\"type\":\"uint256\"}],\"name\":\"getStorageAt\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getThreshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"enumEnum.Operation\",\"name\":\"operation\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"safeTxGas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"baseGas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gasPrice\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"gasToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"refundReceiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_nonce\",\"type\":\"uint256\"}],\"name\":\"getTransactionHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"}],\"name\":\"isModuleEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"prevOwner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_threshold\",\"type\":\"uint256\"}],\"name\":\"removeOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"handler\",\"type\":\"address\"}],\"name\":\"setFallbackHandler\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"guard\",\"type\":\"address\"}],\"name\":\"setGuard\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"moduleGuard\",\"type\":\"address\"}],\"name\":\"setModuleGuard\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_owners\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"_threshold\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"fallbackHandler\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"paymentToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"payment\",\"type\":\"uint256\"},{\"internalType\":\"addresspayable\",\"name\":\"paymentReceiver\",\"type\":\"address\"}],\"name\":\"setup\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"signedMessages\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"targetContract\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"calldataPayload\",\"type\":\"bytes\"}],\"name\":\"simulateAndRevert\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"prevOwner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"oldOwner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"swapOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]",
	Bin: "0x608060405234801561001057600080fd5b506001600481905550615548806100286000396000f3fe6080604052600436106101dc5760003560e01c8063affed0e011610102578063e19a9dd911610095578063f08a032311610064578063f08a032314611542578063f698da2514611593578063f8dc5dd9146115be578063ffa1ad741461163957610231565b8063e19a9dd914611363578063e318b52b146113b4578063e75235b814611445578063ed516d511461147057610231565b8063d4d9bdcd116100d1578063d4d9bdcd1461112c578063d8d11f7814611167578063e009cfde146112a1578063e068df371461131257610231565b8063affed0e014610ddc578063b4faba0914610e07578063b63e800d14610eef578063cc2f84521461105f57610231565b80635624b25b1161017a5780636a761202116101495780636a76120214610a1e5780637d83297414610bda578063934f3a1114610c49578063a0e67e2b14610d7057610231565b80635624b25b146108855780635ae6bd3714610943578063610b592514610992578063694e80c3146109e357610231565b80632d9ad53d116101b65780632d9ad53d146105215780632f54bf6e14610588578063468721a7146105ef5780635229073f1461070457610231565b80630d582f131461029957806312fb68e0146102f45780631fcac7f31461042557610231565b36610231573373ffffffffffffffffffffffffffffffffffffffff167f3d0ce9bfc3ed7d6862dbb28b2dea94561fe714a1b4d019aa8af39730d1ad7c3d346040518082815260200191505060405180910390a2005b34801561023d57600080fd5b507f6c9a6c4a39284e37ed1cf53d337577d14212a4870fb976a4366c693b939918d5548061026a57600080f35b60405136600082373360601b3682015260008060143601836000865af13d6000833e80610295573d82fd5b3d82f35b3480156102a557600080fd5b506102f2600480360360408110156102bc57600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190803590602001909291905050506116c9565b005b34801561030057600080fd5b506104236004803603608081101561031757600080fd5b81019080803590602001909291908035906020019064010000000081111561033e57600080fd5b82018360208201111561035057600080fd5b8035906020019184600183028401116401000000008311171561037257600080fd5b90919293919293908035906020019064010000000081111561039357600080fd5b8201836020820111156103a557600080fd5b803590602001918460018302840111640100000000831117156103c757600080fd5b91908080601f016020809104026020016040519081016040528093929190818152602001838380828437600081840152601f19601f82011690508083019250505050505050919291929080359060200190929190505050611a23565b005b34801561043157600080fd5b5061051f6004803603608081101561044857600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190803590602001909291908035906020019064010000000081111561048f57600080fd5b8201836020820111156104a157600080fd5b803590602001918460018302840111640100000000831117156104c357600080fd5b91908080601f016020809104026020016040519081016040528093929190818152602001838380828437600081840152601f19601f82011690508083019250505050505050919291929080359060200190929190505050611a36565b005b34801561052d57600080fd5b506105706004803603602081101561054457600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190505050611e5a565b60405180821515815260200191505060405180910390f35b34801561059457600080fd5b506105d7600480360360208110156105ab57600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190505050611f2c565b60405180821515815260200191505060405180910390f35b3480156105fb57600080fd5b506106ec6004803603608081101561061257600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190803590602001909291908035906020019064010000000081111561065957600080fd5b82018360208201111561066b57600080fd5b8035906020019184600183028401116401000000008311171561068d57600080fd5b91908080601f016020809104026020016040519081016040528093929190818152602001838380828437600081840152601f19601f820116905080830192505050505050509192919290803560ff169060200190929190505050611ffc565b60405180821515815260200191505060405180910390f35b34801561071057600080fd5b506108016004803603608081101561072757600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190803590602001909291908035906020019064010000000081111561076e57600080fd5b82018360208201111561078057600080fd5b803590602001918460018302840111640100000000831117156107a257600080fd5b91908080601f016020809104026020016040519081016040528093929190818152602001838380828437600081840152601f19601f820116905080830192505050505050509192919290803560ff169060200190929190505050612055565b60405180831515815260200180602001828103825283818151815260200191508051906020019080838360005b8381101561084957808201518184015260208101905061082e565b50505050905090810190601f1680156108765780820380516001836020036101000a031916815260200191505b50935050505060405180910390f35b34801561089157600080fd5b506108c8600480360360408110156108a857600080fd5b8101908080359060200190929190803590602001909291905050506120ca565b6040518080602001828103825283818151815260200191508051906020019080838360005b838110156109085780820151818401526020810190506108ed565b50505050905090810190601f1680156109355780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b34801561094f57600080fd5b5061097c6004803603602081101561096657600080fd5b8101908080359060200190929190505050612151565b6040518082815260200191505060405180910390f35b34801561099e57600080fd5b506109e1600480360360208110156109b557600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190505050612169565b005b3480156109ef57600080fd5b50610a1c60048036036020811015610a0657600080fd5b8101908080359060200190929190505050612467565b005b610bc26004803603610140811015610a3557600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff1690602001909291908035906020019092919080359060200190640100000000811115610a7c57600080fd5b820183602082011115610a8e57600080fd5b80359060200191846001830284011164010000000083111715610ab057600080fd5b9091929391929390803560ff169060200190929190803590602001909291908035906020019092919080359060200190929190803573ffffffffffffffffffffffffffffffffffffffff169060200190929190803573ffffffffffffffffffffffffffffffffffffffff16906020019092919080359060200190640100000000811115610b3c57600080fd5b820183602082011115610b4e57600080fd5b80359060200191846001830284011164010000000083111715610b7057600080fd5b91908080601f016020809104026020016040519081016040528093929190818152602001838380828437600081840152601f19601f820116905080830192505050505050509192919290505050612519565b60405180821515815260200191505060405180910390f35b348015610be657600080fd5b50610c3360048036036040811015610bfd57600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190803590602001909291905050506129c4565b6040518082815260200191505060405180910390f35b348015610c5557600080fd5b50610d6e60048036036060811015610c6c57600080fd5b810190808035906020019092919080359060200190640100000000811115610c9357600080fd5b820183602082011115610ca557600080fd5b80359060200191846001830284011164010000000083111715610cc757600080fd5b909192939192939080359060200190640100000000811115610ce857600080fd5b820183602082011115610cfa57600080fd5b80359060200191846001830284011164010000000083111715610d1c57600080fd5b91908080601f016020809104026020016040519081016040528093929190818152602001838380828437600081840152601f19601f8201169050808301925050505050505091929192905050506129e9565b005b348015610d7c57600080fd5b50610d856129f9565b6040518080602001828103825283818151815260200191508051906020019060200280838360005b83811015610dc8578082015181840152602081019050610dad565b505050509050019250505060405180910390f35b348015610de857600080fd5b50610df1612ba2565b6040518082815260200191505060405180910390f35b348015610e1357600080fd5b50610eed60048036036040811015610e2a57600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff16906020019092919080359060200190640100000000811115610e6757600080fd5b820183602082011115610e7957600080fd5b80359060200191846001830284011164010000000083111715610e9b57600080fd5b91908080601f016020809104026020016040519081016040528093929190818152602001838380828437600081840152601f19601f820116905080830192505050505050509192919290505050612ba8565b005b348015610efb57600080fd5b5061105d6004803603610100811015610f1357600080fd5b8101908080359060200190640100000000811115610f3057600080fd5b820183602082011115610f4257600080fd5b80359060200191846020830284011164010000000083111715610f6457600080fd5b909192939192939080359060200190929190803573ffffffffffffffffffffffffffffffffffffffff16906020019092919080359060200190640100000000811115610faf57600080fd5b820183602082011115610fc157600080fd5b80359060200191846001830284011164010000000083111715610fe357600080fd5b9091929391929390803573ffffffffffffffffffffffffffffffffffffffff169060200190929190803573ffffffffffffffffffffffffffffffffffffffff16906020019092919080359060200190929190803573ffffffffffffffffffffffffffffffffffffffff169060200190929190505050612bcf565b005b34801561106b57600080fd5b506110b86004803603604081101561108257600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff16906020019092919080359060200190929190505050612d8d565b60405180806020018373ffffffffffffffffffffffffffffffffffffffff168152602001828103825284818151815260200191508051906020019060200280838360005b838110156111175780820151818401526020810190506110fc565b50505050905001935050505060405180910390f35b34801561113857600080fd5b506111656004803603602081101561114f57600080fd5b810190808035906020019092919050505061306d565b005b34801561117357600080fd5b5061128b600480360361014081101561118b57600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff16906020019092919080359060200190929190803590602001906401000000008111156111d257600080fd5b8201836020820111156111e457600080fd5b8035906020019184600183028401116401000000008311171561120657600080fd5b9091929391929390803560ff169060200190929190803590602001909291908035906020019092919080359060200190929190803573ffffffffffffffffffffffffffffffffffffffff169060200190929190803573ffffffffffffffffffffffffffffffffffffffff169060200190929190803590602001909291905050506131c8565b6040518082815260200191505060405180910390f35b3480156112ad57600080fd5b50611310600480360360408110156112c457600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190803573ffffffffffffffffffffffffffffffffffffffff1690602001909291905050506131f5565b005b34801561131e57600080fd5b506113616004803603602081101561133557600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff1690602001909291905050506134f2565b005b34801561136f57600080fd5b506113b26004803603602081101561138657600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff1690602001909291905050506136a0565b005b3480156113c057600080fd5b50611443600480360360608110156113d757600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190803573ffffffffffffffffffffffffffffffffffffffff169060200190929190803573ffffffffffffffffffffffffffffffffffffffff169060200190929190505050613845565b005b34801561145157600080fd5b5061145a613d8d565b6040518082815260200191505060405180910390f35b34801561147c57600080fd5b506115406004803603604081101561149357600080fd5b8101908080359060200190929190803590602001906401000000008111156114ba57600080fd5b8201836020820111156114cc57600080fd5b803590602001918460018302840111640100000000831117156114ee57600080fd5b91908080601f016020809104026020016040519081016040528093929190818152602001838380828437600081840152601f19601f820116905080830192505050505050509192919290505050613d97565b005b34801561154e57600080fd5b506115916004803603602081101561156557600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190505050613de2565b005b34801561159f57600080fd5b506115a8613e39565b6040518082815260200191505060405180910390f35b3480156115ca57600080fd5b50611637600480360360608110156115e157600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190803573ffffffffffffffffffffffffffffffffffffffff16906020019092919080359060200190929190505050613eb5565b005b34801561164557600080fd5b5061164e614210565b6040518080602001828103825283818151815260200191508051906020019080838360005b8381101561168e578082015181840152602081019050611673565b50505050905090810190601f1680156116bb5780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b6116d1614249565b600073ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff1614806117385750600173ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff16145b8061176e57503073ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff16145b1561179d5761179c7f47533230330000000000000000000000000000000000000000000000000000006142a8565b5b600073ffffffffffffffffffffffffffffffffffffffff16600260008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff161461185a576118597f47533230340000000000000000000000000000000000000000000000000000006142a8565b5b60026000600173ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16600260008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055508160026000600173ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055506003600081548092919060010191905055508173ffffffffffffffffffffffffffffffffffffffff167f9465fa0c962cc76958e6373a993326400c1c94f8be2fe3a952adfa7f60b2ea2660405160405180910390a28060045414611a1f57611a1e81612467565b5b5050565b611a2f33868484611a36565b5050505050565b611a4a6041826142e790919063ffffffff16565b82511015611a7c57611a7b7f47533032300000000000000000000000000000000000000000000000000000006142a8565b5b6000808060008060005b86811015611e4e57611a988882614321565b8260ff1692508094508195508296505050506000841415611b15578260001c9450611acd6041886142e790919063ffffffff16565b8260001c1015611b0157611b007f47533032310000000000000000000000000000000000000000000000000000006142a8565b5b611b10858a8a8560001c614350565b611d12565b6001841415611be4578260001c94508473ffffffffffffffffffffffffffffffffffffffff168a73ffffffffffffffffffffffffffffffffffffffff1614158015611bb057506000600860008773ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008b815260200190815260200160002054145b15611bdf57611bde7f47533032350000000000000000000000000000000000000000000000000000006142a8565b5b611d11565b601e841115611ca95760018960405160200180807f19457468657265756d205369676e6564204d6573736167653a0a333200000000815250601c018281526020019150506040516020818303038152906040528051906020012060048603858560405160008152602001604052604051808581526020018460ff1681526020018381526020018281526020019450505050506020604051602081039080840390855afa158015611c98573d6000803e3d6000fd5b505050602060405103519450611d10565b60018985858560405160008152602001604052604051808581526020018460ff1681526020018381526020018281526020019450505050506020604051602081039080840390855afa158015611d03573d6000803e3d6000fd5b5050506020604051035194505b5b5b8573ffffffffffffffffffffffffffffffffffffffff168573ffffffffffffffffffffffffffffffffffffffff16111580611dd85750600073ffffffffffffffffffffffffffffffffffffffff16600260008773ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16145b80611e0f5750600173ffffffffffffffffffffffffffffffffffffffff168573ffffffffffffffffffffffffffffffffffffffff16145b15611e3e57611e3d7f47533032360000000000000000000000000000000000000000000000000000006142a8565b5b8495508080600101915050611a86565b50505050505050505050565b60008173ffffffffffffffffffffffffffffffffffffffff16600173ffffffffffffffffffffffffffffffffffffffff1614158015611f255750600073ffffffffffffffffffffffffffffffffffffffff16600160008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1614155b9050919050565b6000600173ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff161480611ff45750600073ffffffffffffffffffffffffffffffffffffffff16600260008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16145b159050919050565b600080600061200d87878787614579565b9150915061203e878787877fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff614857565b925061204b8282856148a3565b5050949350505050565b6000606060008061206888888888614579565b91509150612099888888887fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff614857565b9350604051925060203d0183016040523d83523d6000602085013e6120bf8282866148a3565b505094509492505050565b606060006020830267ffffffffffffffff811180156120e857600080fd5b506040519080825280601f01601f19166020018201604052801561211b5781602001600182028036833780820191505090505b50905060005b8381101561214657808501548060208302602085010152508080600101915050612121565b508091505092915050565b60076020528060005260406000206000915090505481565b612171614249565b600073ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff1614806121d85750600173ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff16145b15612207576122067f47533130310000000000000000000000000000000000000000000000000000006142a8565b5b600073ffffffffffffffffffffffffffffffffffffffff16600160008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16146122c4576122c37f47533130320000000000000000000000000000000000000000000000000000006142a8565b5b60016000600173ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16600160008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055508060016000600173ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055508073ffffffffffffffffffffffffffffffffffffffff167fecdf3a3effea5783a3c4c2140e677577666428d44ed9d474a0b3a4c9943f844060405160405180910390a250565b61246f614249565b6003548111156124a3576124a27f47533230310000000000000000000000000000000000000000000000000000006142a8565b5b60008114156124d6576124d57f47533230320000000000000000000000000000000000000000000000000000006142a8565b5b806004819055507f610f7ff2b304ae8903c3de74c60c6ab1f7d6226b3f52c5161905bb5ad4039c936004546040518082815260200191505060405180910390a150565b600061252e8c8c8c8c8c8c8c8c8c8c8c6149e4565b60006125538d8d8d8d8d8d8d8d8d8d60056000815480929190600101919050556131c8565b905061255f8184613d97565b60006125696149f1565b9050600073ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff161461274f578073ffffffffffffffffffffffffffffffffffffffff166375f0bb528f8f8f8f8f8f8f8f8f8f8f336040518d63ffffffff1660e01b8152600401808d73ffffffffffffffffffffffffffffffffffffffff1681526020018c8152602001806020018a600181111561260c57fe5b81526020018981526020018881526020018781526020018673ffffffffffffffffffffffffffffffffffffffff1681526020018573ffffffffffffffffffffffffffffffffffffffff168152602001806020018473ffffffffffffffffffffffffffffffffffffffff16815260200183810383528d8d82818152602001925080828437600081840152601f19601f820116905080830192505050838103825285818151815260200191508051906020019080838360005b838110156126de5780820151818401526020810190506126c3565b50505050905090810190601f16801561270b5780820380516001836020036101000a031916815260200191505b509e505050505050505050505050505050600060405180830381600087803b15801561273657600080fd5b505af115801561274a573d6000803e3d6000fd5b505050505b6101f46127766109c48b01603f60408d028161276757fe5b04614a1a90919063ffffffff16565b015a10156127a8576127a77f47533031300000000000000000000000000000000000000000000000000000006142a8565b5b60005a90506128118f8f8f8f8080601f016020809104026020016040519081016040528093929190818152602001838380828437600081840152601f19601f820116905080830192505050505050508e60008d14612806578e61280c565b6109c45a035b614857565b93506128265a82614a3490919063ffffffff16565b905083158015612836575060008a145b80156128425750600088145b15612871576128707f47533031330000000000000000000000000000000000000000000000000000006142a8565b5b60008089111561288b57612888828b8b8b8b614a54565b90505b84156128ce57837f442e715f626346e8c54381002da614f62bee8d27386535b2521ec8540898556e826040518082815260200191505060405180910390a2612907565b837f23428b18acfb3ea64b08dc0c1d296ea9c09702c09083ca5272e64d115b687d23826040518082815260200191505060405180910390a25b5050600073ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff16146129b3578073ffffffffffffffffffffffffffffffffffffffff16639327136883856040518363ffffffff1660e01b815260040180838152602001821515815260200192505050600060405180830381600087803b15801561299a57600080fd5b505af11580156129ae573d6000803e3d6000fd5b505050505b50509b9a5050505050505050505050565b6008602052816000526040600020602052806000526040600020600091509150505481565b6129f38482613d97565b50505050565b6060600060035467ffffffffffffffff81118015612a1657600080fd5b50604051908082528060200260200182016040528015612a455781602001602082028036833780820191505090505b50905060008060026000600173ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1690505b600173ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff1614612b995780838381518110612af057fe5b602002602001019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff1681525050600260008273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1690508180600101925050612aaf565b82935050505090565b60055481565b600080825160208401855af46040518181523d60208201523d6000604083013e60403d0181fd5b612c1a8a8a80806020026020016040519081016040528093929190818152602001838360200280828437600081840152601f19601f8201169050808301925050505050505089614c08565b600073ffffffffffffffffffffffffffffffffffffffff168473ffffffffffffffffffffffffffffffffffffffff1614612c5857612c5784614faf565b5b612ca68787878080601f016020809104026020016040519081016040528093929190818152602001838380828437600081840152601f19601f82011690508083019250505050505050615033565b6000821115612cc057612cbe82600060018685614a54565b505b3373ffffffffffffffffffffffffffffffffffffffff167f141df868a6331af528e38c83b7aa03edc19be66e37ae67f9285bf4f8e3c6a1a88b8b8b8b8960405180806020018581526020018473ffffffffffffffffffffffffffffffffffffffff1681526020018373ffffffffffffffffffffffffffffffffffffffff1681526020018281038252878782818152602001925060200280828437600081840152601f19601f820116905080830192505050965050505050505060405180910390a250505050505050505050565b60606000600173ffffffffffffffffffffffffffffffffffffffff168473ffffffffffffffffffffffffffffffffffffffff1614158015612dd45750612dd284611e5a565b155b15612e0357612e027f47533130350000000000000000000000000000000000000000000000000000006142a8565b5b6000831415612e3657612e357f47533130360000000000000000000000000000000000000000000000000000006142a8565b5b8267ffffffffffffffff81118015612e4d57600080fd5b50604051908082528060200260200182016040528015612e7c5781602001602082028036833780820191505090505b5091506000600160008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1691505b600073ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff1614158015612f4e5750600173ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff1614155b8015612f5957508381105b156130145781838281518110612f6b57fe5b602002602001019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff1681525050600160008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1691508080600101915050612ee4565b600173ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff16146130625782600182038151811061305757fe5b602002602001015191505b808352509250929050565b600073ffffffffffffffffffffffffffffffffffffffff16600260003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16141561312b5761312a7f47533033300000000000000000000000000000000000000000000000000000006142a8565b5b6001600860003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206000838152602001908152602001600020819055503373ffffffffffffffffffffffffffffffffffffffff16817ff2a0eb156472d1440255b0d7c1e19cc07115d1051fe605b0dce69acfec884d9c60405160405180910390a350565b60006131dd8c8c8c8c8c8c8c8c8c8c8c61523d565b8051906020012090509b9a5050505050505050505050565b6131fd614249565b600073ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff1614806132645750600173ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff16145b15613293576132927f47533130310000000000000000000000000000000000000000000000000000006142a8565b5b8073ffffffffffffffffffffffffffffffffffffffff16600160008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff161461334f5761334e7f47533130330000000000000000000000000000000000000000000000000000006142a8565b5b600160008273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16600160008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055506000600160008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055508073ffffffffffffffffffffffffffffffffffffffff167faab4fa2b463f581b2b32cb3b7e3b704b9ce37cc209b5fb4d77e593ace405427660405160405180910390a25050565b6134fa614249565b600073ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff16141580156135ff57508073ffffffffffffffffffffffffffffffffffffffff166301ffc9a77f58401ed8000000000000000000000000000000000000000000000000000000006040518263ffffffff1660e01b815260040180827bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916815260200191505060206040518083038186803b1580156135c257600080fd5b505afa1580156135d6573d6000803e3d6000fd5b505050506040513d60208110156135ec57600080fd5b8101908080519060200190929190505050155b1561362e5761362d7f47533330310000000000000000000000000000000000000000000000000000006142a8565b5b60007fb104e0b93118902c651344349b610029d694cfdec91c589c91ebafbcd028994760001b90508181558173ffffffffffffffffffffffffffffffffffffffff167fcd1966d6be16bc0c030cc741a06c6e0efaf8d00de2c8b6a9e11827e125de8bb860405160405180910390a25050565b6136a8614249565b600073ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff16141580156137ad57508073ffffffffffffffffffffffffffffffffffffffff166301ffc9a77fe6d7a83a000000000000000000000000000000000000000000000000000000006040518263ffffffff1660e01b815260040180827bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916815260200191505060206040518083038186803b15801561377057600080fd5b505afa158015613784573d6000803e3d6000fd5b505050506040513d602081101561379a57600080fd5b8101908080519060200190929190505050155b156137dc576137db7f47533330300000000000000000000000000000000000000000000000000000006142a8565b5b807f4a204f620c8c5ccdca3fd54d003badd85ba500436a431f0cbda4f558c93c34c8558073ffffffffffffffffffffffffffffffffffffffff167f1151116914515bc0891ff9047a6cb32cf902546f83066499bcf8ba33d2353fa260405160405180910390a250565b61384d614249565b600073ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff1614806138b45750600173ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff16145b806138ea57503073ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff16145b15613919576139187f47533230330000000000000000000000000000000000000000000000000000006142a8565b5b600073ffffffffffffffffffffffffffffffffffffffff16600260008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16146139d6576139d57f47533230340000000000000000000000000000000000000000000000000000006142a8565b5b600073ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff161480613a3d5750600173ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff16145b15613a6c57613a6b7f47533230330000000000000000000000000000000000000000000000000000006142a8565b5b8173ffffffffffffffffffffffffffffffffffffffff16600260008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1614613b2857613b277f47533230350000000000000000000000000000000000000000000000000000006142a8565b5b600260008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16600260008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555080600260008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055506000600260008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055508173ffffffffffffffffffffffffffffffffffffffff167ff8d49fc529812e9a7c5c50e69c20f0dccc0db8fa95c98bc58cc9a4f1c1299eaf60405160405180910390a28073ffffffffffffffffffffffffffffffffffffffff167f9465fa0c962cc76958e6373a993326400c1c94f8be2fe3a952adfa7f60b2ea2660405160405180910390a2505050565b6000600454905090565b600060045490506000811415613dd157613dd07f47533030310000000000000000000000000000000000000000000000000000006142a8565b5b613ddd33848484611a36565b505050565b613dea614249565b613df381614faf565b8073ffffffffffffffffffffffffffffffffffffffff167f5ac6c46c93c8d0e53714ba3b53db3e7c046da994313d7ed0d192028bc7c228b060405160405180910390a250565b6000804690507f47e79534a245952e8b16893a336b85a3d9ea9fa8c573f3d803afb92a7946921860001b8130604051602001808481526020018381526020018273ffffffffffffffffffffffffffffffffffffffff16815260200193505050506040516020818303038152906040528051906020012091505090565b613ebd614249565b806001600354031015613ef457613ef37f47533230310000000000000000000000000000000000000000000000000000006142a8565b5b600073ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff161480613f5b5750600173ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff16145b15613f8a57613f897f47533230330000000000000000000000000000000000000000000000000000006142a8565b5b8173ffffffffffffffffffffffffffffffffffffffff16600260008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1614614046576140457f47533230350000000000000000000000000000000000000000000000000000006142a8565b5b600260008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16600260008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055506000600260008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550600360008154809291906001900391905055508173ffffffffffffffffffffffffffffffffffffffff167ff8d49fc529812e9a7c5c50e69c20f0dccc0db8fa95c98bc58cc9a4f1c1299eaf60405160405180910390a2806004541461420b5761420a81612467565b5b505050565b6040518060400160405280600581526020017f312e342e3100000000000000000000000000000000000000000000000000000081525081565b3073ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16146142a6576142a57f47533033310000000000000000000000000000000000000000000000000000006142a8565b5b565b6040517f08c379a00000000000000000000000000000000000000000000000000000000081526020600482015260056024820152816044820152606481fd5b6000808314156142fa576000905061431b565b600082840290508284828161430b57fe5b041461431657600080fd5b809150505b92915050565b6000806000836041026020810186015192506040810186015191506060810186015160001a9350509250925092565b81516143666020836153e590919063ffffffff16565b1115614396576143957f47533032320000000000000000000000000000000000000000000000000000006142a8565b5b600060208284010151905082516143c9826143bb6020866153e590919063ffffffff16565b6153e590919063ffffffff16565b11156143f9576143f87f47533032330000000000000000000000000000000000000000000000000000006142a8565b5b60606020838501019050631626ba7e60e01b7bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19168673ffffffffffffffffffffffffffffffffffffffff16631626ba7e87846040518363ffffffff1660e01b81526004018083815260200180602001828103825283818151815260200191508051906020019080838360005b8381101561449d578082015181840152602081019050614482565b50505050905090810190601f1680156144ca5780820380516001836020036101000a031916815260200191505b50935050505060206040518083038186803b1580156144e857600080fd5b505afa1580156144fc573d6000803e3d6000fd5b505050506040513d602081101561451257600080fd5b81019080805190602001909291905050507bffffffffffffffffffffffffffffffffffffffffffffffffffffffff191614614571576145707f47533032340000000000000000000000000000000000000000000000000000006142a8565b5b505050505050565b60008061458886868686615404565b61459061540a565b9150600173ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff161415801561465b5750600073ffffffffffffffffffffffffffffffffffffffff16600160003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1614155b6146cd576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260058152602001807f475331303400000000000000000000000000000000000000000000000000000081525060200191505060405180910390fd5b600073ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff161461484e578173ffffffffffffffffffffffffffffffffffffffff1663728c297287878787336040518663ffffffff1660e01b8152600401808673ffffffffffffffffffffffffffffffffffffffff1681526020018581526020018060200184600181111561476757fe5b81526020018373ffffffffffffffffffffffffffffffffffffffff168152602001828103825285818151815260200191508051906020019080838360005b838110156147c05780820151818401526020810190506147a5565b50505050905090810190601f1680156147ed5780820380516001836020036101000a031916815260200191505b509650505050505050602060405180830381600087803b15801561481057600080fd5b505af1158015614824573d6000803e3d6000fd5b505050506040513d602081101561483a57600080fd5b810190808051906020019092919050505090505b94509492505050565b600060018081111561486557fe5b83600181111561487157fe5b141561488a576000808551602087018986f4905061489a565b600080855160208701888a87f190505b95945050505050565b600073ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff161461494d578273ffffffffffffffffffffffffffffffffffffffff16632acc37aa83836040518363ffffffff1660e01b815260040180838152602001821515815260200192505050600060405180830381600087803b15801561493457600080fd5b505af1158015614948573d6000803e3d6000fd5b505050505b801561499b573373ffffffffffffffffffffffffffffffffffffffff167f6895c13664aa4f67288b25d7a21d7aaa34916e355fb9b6fae0a139a9085becb860405160405180910390a26149df565b3373ffffffffffffffffffffffffffffffffffffffff167facd2c8702804128fdb0db2bb49f6d127dd0181c13fd45dbfe16de0930e2bd37560405160405180910390a25b505050565b5050505050505050505050565b60007f4a204f620c8c5ccdca3fd54d003badd85ba500436a431f0cbda4f558c93c34c854905090565b600081831015614a2a5781614a2c565b825b905092915050565b600082821115614a4357600080fd5b600082840390508091505092915050565b600080600073ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff1614614a915782614a93565b325b9050600073ffffffffffffffffffffffffffffffffffffffff168473ffffffffffffffffffffffffffffffffffffffff161415614b9d57614afd3a8610614ada573a614adc565b855b614aef888a6153e590919063ffffffff16565b6142e790919063ffffffff16565b915060008173ffffffffffffffffffffffffffffffffffffffff168360405180600001905060006040518083038185875af1925050503d8060008114614b5f576040519150601f19603f3d011682016040523d82523d6000602084013e614b64565b606091505b5050905080614b9757614b967f47533031310000000000000000000000000000000000000000000000000000006142a8565b5b50614bfe565b614bc285614bb4888a6153e590919063ffffffff16565b6142e790919063ffffffff16565b9150614bcf84828461543b565b614bfd57614bfc7f47533031320000000000000000000000000000000000000000000000000000006142a8565b5b5b5095945050505050565b60006004541115614c3d57614c3c7f47533230300000000000000000000000000000000000000000000000000000006142a8565b5b8151811115614c7057614c6f7f47533230310000000000000000000000000000000000000000000000000000006142a8565b5b6000811415614ca357614ca27f47533230320000000000000000000000000000000000000000000000000000006142a8565b5b60006001905060005b8351811015614f1b576000848281518110614cc357fe5b60200260200101519050600073ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff161480614d345750600173ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff16145b80614d6a57503073ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff16145b80614da057508073ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff16145b15614dcf57614dce7f47533230330000000000000000000000000000000000000000000000000000006142a8565b5b600073ffffffffffffffffffffffffffffffffffffffff16600260008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1614614e8c57614e8b7f47533230340000000000000000000000000000000000000000000000000000006142a8565b5b80600260008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550809250508080600101915050614cac565b506001600260008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550825160038190555081600481905550505050565b3073ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff16141561500d5761500c7f47533430300000000000000000000000000000000000000000000000000000006142a8565b5b807f6c9a6c4a39284e37ed1cf53d337577d14212a4870fb976a4366c693b939918d55550565b600073ffffffffffffffffffffffffffffffffffffffff1660016000600173ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16146150f1576150f07f47533130300000000000000000000000000000000000000000000000000000006142a8565b5b6001806000600173ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550600073ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff1614615239576151ad826154ff565b6151db576151da7f47533030320000000000000000000000000000000000000000000000000000006142a8565b5b61520a8260008360017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff614857565b615238576152377f47533030300000000000000000000000000000000000000000000000000000006142a8565b5b5b5050565b606060007fbb8310d486368db6bd6f849402fdd73ad53d316b5a4b2644ad6efe0f941286d860001b8d8d8d8d60405180838380828437808301925050509250505060405180910390208c8c8c8c8c8c8c604051602001808c81526020018b73ffffffffffffffffffffffffffffffffffffffff1681526020018a81526020018981526020018860018111156152ce57fe5b81526020018781526020018681526020018581526020018473ffffffffffffffffffffffffffffffffffffffff1681526020018373ffffffffffffffffffffffffffffffffffffffff1681526020018281526020019b505050505050505050505050604051602081830303815290604052805190602001209050601960f81b600160f81b61535a613e39565b8360405160200180857effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff19168152600101847effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191681526001018381526020018281526020019450505050506040516020818303038152906040529150509b9a5050505050505050505050565b6000808284019050838110156153fa57600080fd5b8091505092915050565b50505050565b6000807fb104e0b93118902c651344349b610029d694cfdec91c589c91ebafbcd028994760001b9050805491505090565b60008063a9059cbb8484604051602401808373ffffffffffffffffffffffffffffffffffffffff168152602001828152602001925050506040516020818303038152906040529060e01b6020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff83818316178352505050509050602060008251602084016000896127105a03f13d600081146154e257602081146154ea57600093506154f5565b8193506154f5565b600051158215171593505b5050509392505050565b600080823b90506000811191505091905056fea2646970667358221220125b2076cac9b04fd2e7f63b1418a0e0488c1014a5d106ef1907710461955a7f64736f6c63430007060033",
}

// SafeABI is the input ABI used to generate the binding from.
// Deprecated: Use SafeMetaData.ABI instead.
var SafeABI = SafeMetaData.ABI

// SafeBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use SafeMetaData.Bin instead.
var SafeBin = SafeMetaData.Bin

// DeploySafe deploys a new Ethereum contract, binding an instance of Safe to it.
func DeploySafe(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *Safe, error) {
	parsed, err := SafeMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(SafeBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &Safe{SafeCaller: SafeCaller{contract: contract}, SafeTransactor: SafeTransactor{contract: contract}, SafeFilterer: SafeFilterer{contract: contract}}, nil
}

// Safe is an auto generated Go binding around an Ethereum contract.
type Safe struct {
	SafeCaller     // Read-only binding to the contract
	SafeTransactor // Write-only binding to the contract
	SafeFilterer   // Log filterer for contract events
}

// SafeCaller is an auto generated read-only Go binding around an Ethereum contract.
type SafeCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// SafeTransactor is an auto generated write-only Go binding around an Ethereum contract.
type SafeTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// SafeFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type SafeFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// SafeSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type SafeSession struct {
	Contract     *Safe             // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// SafeCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type SafeCallerSession struct {
	Contract *SafeCaller   // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts // Call options to use throughout this session
}

// SafeTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type SafeTransactorSession struct {
	Contract     *SafeTransactor   // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// SafeRaw is an auto generated low-level Go binding around an Ethereum contract.
type SafeRaw struct {
	Contract *Safe // Generic contract binding to access the raw methods on
}

// SafeCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type SafeCallerRaw struct {
	Contract *SafeCaller // Generic read-only contract binding to access the raw methods on
}

// SafeTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type SafeTransactorRaw struct {
	Contract *SafeTransactor // Generic write-only contract binding to access the raw methods on
}

// NewSafe creates a new instance of Safe, bound to a specific deployed contract.
func NewSafe(address common.Address, backend bind.ContractBackend) (*Safe, error) {
	contract, err := bindSafe(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &Safe{SafeCaller: SafeCaller{contract: contract}, SafeTransactor: SafeTransactor{contract: contract}, SafeFilterer: SafeFilterer{contract: contract}}, nil
}

// NewSafeCaller creates a new read-only instance of Safe, bound to a specific deployed contract.
func NewSafeCaller(address common.Address, caller bind.ContractCaller) (*SafeCaller, error) {
	contract, err := bindSafe(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &SafeCaller{contract: contract}, nil
}

// NewSafeTransactor creates a new write-only instance of Safe, bound to a specific deployed contract.
func NewSafeTransactor(address common.Address, transactor bind.ContractTransactor) (*SafeTransactor, error) {
	contract, err := bindSafe(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &SafeTransactor{contract: contract}, nil
}

// NewSafeFilterer creates a new log filterer instance of Safe, bound to a specific deployed contract.
func NewSafeFilterer(address common.Address, filterer bind.ContractFilterer) (*SafeFilterer, error) {
	contract, err := bindSafe(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &SafeFilterer{contract: contract}, nil
}

// bindSafe binds a generic wrapper to an already deployed contract.
func bindSafe(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := SafeMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Safe *SafeRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _Safe.Contract.SafeCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Safe *SafeRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Safe.Contract.SafeTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Safe *SafeRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Safe.Contract.SafeTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Safe *SafeCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _Safe.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Safe *SafeTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Safe.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Safe *SafeTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Safe.Contract.contract.Transact(opts, method, params...)
}

// VERSION is a free data retrieval call binding the contract method 0xffa1ad74.
//
// Solidity: function VERSION() view returns(string)
func (_Safe *SafeCaller) VERSION(opts *bind.CallOpts) (string, error) {
	var out []interface{}
	err := _Safe.contract.Call(opts, &out, "VERSION")

	if err != nil {
		return *new(string), err
	}

	out0 := *abi.ConvertType(out[0], new(string)).(*string)

	return out0, err

}

// VERSION is a free data retrieval call binding the contract method 0xffa1ad74.
//
// Solidity: function VERSION() view returns(string)
func (_Safe *SafeSession) VERSION() (string, error) {
	return _Safe.Contract.VERSION(&_Safe.CallOpts)
}

// VERSION is a free data retrieval call binding the contract method 0xffa1ad74.
//
// Solidity: function VERSION() view returns(string)
func (_Safe *SafeCallerSession) VERSION() (string, error) {
	return _Safe.Contract.VERSION(&_Safe.CallOpts)
}

// ApprovedHashes is a free data retrieval call binding the contract method 0x7d832974.
//
// Solidity: function approvedHashes(address , bytes32 ) view returns(uint256)
func (_Safe *SafeCaller) ApprovedHashes(opts *bind.CallOpts, arg0 common.Address, arg1 [32]byte) (*big.Int, error) {
	var out []interface{}
	err := _Safe.contract.Call(opts, &out, "approvedHashes", arg0, arg1)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// ApprovedHashes is a free data retrieval call binding the contract method 0x7d832974.
//
// Solidity: function approvedHashes(address , bytes32 ) view returns(uint256)
func (_Safe *SafeSession) ApprovedHashes(arg0 common.Address, arg1 [32]byte) (*big.Int, error) {
	return _Safe.Contract.ApprovedHashes(&_Safe.CallOpts, arg0, arg1)
}

// ApprovedHashes is a free data retrieval call binding the contract method 0x7d832974.
//
// Solidity: function approvedHashes(address , bytes32 ) view returns(uint256)
func (_Safe *SafeCallerSession) ApprovedHashes(arg0 common.Address, arg1 [32]byte) (*big.Int, error) {
	return _Safe.Contract.ApprovedHashes(&_Safe.CallOpts, arg0, arg1)
}

// CheckNSignatures is a free data retrieval call binding the contract method 0x12fb68e0.
//
// Solidity: function checkNSignatures(bytes32 dataHash, bytes data, bytes signatures, uint256 requiredSignatures) view returns()
func (_Safe *SafeCaller) CheckNSignatures(opts *bind.CallOpts, dataHash [32]byte, data []byte, signatures []byte, requiredSignatures *big.Int) error {
	var out []interface{}
	err := _Safe.contract.Call(opts, &out, "checkNSignatures", dataHash, data, signatures, requiredSignatures)

	if err != nil {
		return err
	}

	return err

}

// CheckNSignatures is a free data retrieval call binding the contract method 0x12fb68e0.
//
// Solidity: function checkNSignatures(bytes32 dataHash, bytes data, bytes signatures, uint256 requiredSignatures) view returns()
func (_Safe *SafeSession) CheckNSignatures(dataHash [32]byte, data []byte, signatures []byte, requiredSignatures *big.Int) error {
	return _Safe.Contract.CheckNSignatures(&_Safe.CallOpts, dataHash, data, signatures, requiredSignatures)
}

// CheckNSignatures is a free data retrieval call binding the contract method 0x12fb68e0.
//
// Solidity: function checkNSignatures(bytes32 dataHash, bytes data, bytes signatures, uint256 requiredSignatures) view returns()
func (_Safe *SafeCallerSession) CheckNSignatures(dataHash [32]byte, data []byte, signatures []byte, requiredSignatures *big.Int) error {
	return _Safe.Contract.CheckNSignatures(&_Safe.CallOpts, dataHash, data, signatures, requiredSignatures)
}

// CheckNSignatures0 is a free data retrieval call binding the contract method 0x1fcac7f3.
//
// Solidity: function checkNSignatures(address executor, bytes32 dataHash, bytes signatures, uint256 requiredSignatures) view returns()
func (_Safe *SafeCaller) CheckNSignatures0(opts *bind.CallOpts, executor common.Address, dataHash [32]byte, signatures []byte, requiredSignatures *big.Int) error {
	var out []interface{}
	err := _Safe.contract.Call(opts, &out, "checkNSignatures0", executor, dataHash, signatures, requiredSignatures)

	if err != nil {
		return err
	}

	return err

}

// CheckNSignatures0 is a free data retrieval call binding the contract method 0x1fcac7f3.
//
// Solidity: function checkNSignatures(address executor, bytes32 dataHash, bytes signatures, uint256 requiredSignatures) view returns()
func (_Safe *SafeSession) CheckNSignatures0(executor common.Address, dataHash [32]byte, signatures []byte, requiredSignatures *big.Int) error {
	return _Safe.Contract.CheckNSignatures0(&_Safe.CallOpts, executor, dataHash, signatures, requiredSignatures)
}

// CheckNSignatures0 is a free data retrieval call binding the contract method 0x1fcac7f3.
//
// Solidity: function checkNSignatures(address executor, bytes32 dataHash, bytes signatures, uint256 requiredSignatures) view returns()
func (_Safe *SafeCallerSession) CheckNSignatures0(executor common.Address, dataHash [32]byte, signatures []byte, requiredSignatures *big.Int) error {
	return _Safe.Contract.CheckNSignatures0(&_Safe.CallOpts, executor, dataHash, signatures, requiredSignatures)
}

// CheckSignatures is a free data retrieval call binding the contract method 0x934f3a11.
//
// Solidity: function checkSignatures(bytes32 dataHash, bytes data, bytes signatures) view returns()
func (_Safe *SafeCaller) CheckSignatures(opts *bind.CallOpts, dataHash [32]byte, data []byte, signatures []byte) error {
	var out []interface{}
	err := _Safe.contract.Call(opts, &out, "checkSignatures", dataHash, data, signatures)

	if err != nil {
		return err
	}

	return err

}

// CheckSignatures is a free data retrieval call binding the contract method 0x934f3a11.
//
// Solidity: function checkSignatures(bytes32 dataHash, bytes data, bytes signatures) view returns()
func (_Safe *SafeSession) CheckSignatures(dataHash [32]byte, data []byte, signatures []byte) error {
	return _Safe.Contract.CheckSignatures(&_Safe.CallOpts, dataHash, data, signatures)
}

// CheckSignatures is a free data retrieval call binding the contract method 0x934f3a11.
//
// Solidity: function checkSignatures(bytes32 dataHash, bytes data, bytes signatures) view returns()
func (_Safe *SafeCallerSession) CheckSignatures(dataHash [32]byte, data []byte, signatures []byte) error {
	return _Safe.Contract.CheckSignatures(&_Safe.CallOpts, dataHash, data, signatures)
}

// CheckSignatures0 is a free data retrieval call binding the contract method 0xed516d51.
//
// Solidity: function checkSignatures(bytes32 dataHash, bytes signatures) view returns()
func (_Safe *SafeCaller) CheckSignatures0(opts *bind.CallOpts, dataHash [32]byte, signatures []byte) error {
	var out []interface{}
	err := _Safe.contract.Call(opts, &out, "checkSignatures0", dataHash, signatures)

	if err != nil {
		return err
	}

	return err

}

// CheckSignatures0 is a free data retrieval call binding the contract method 0xed516d51.
//
// Solidity: function checkSignatures(bytes32 dataHash, bytes signatures) view returns()
func (_Safe *SafeSession) CheckSignatures0(dataHash [32]byte, signatures []byte) error {
	return _Safe.Contract.CheckSignatures0(&_Safe.CallOpts, dataHash, signatures)
}

// CheckSignatures0 is a free data retrieval call binding the contract method 0xed516d51.
//
// Solidity: function checkSignatures(bytes32 dataHash, bytes signatures) view returns()
func (_Safe *SafeCallerSession) CheckSignatures0(dataHash [32]byte, signatures []byte) error {
	return _Safe.Contract.CheckSignatures0(&_Safe.CallOpts, dataHash, signatures)
}

// DomainSeparator is a free data retrieval call binding the contract method 0xf698da25.
//
// Solidity: function domainSeparator() view returns(bytes32)
func (_Safe *SafeCaller) DomainSeparator(opts *bind.CallOpts) ([32]byte, error) {
	var out []interface{}
	err := _Safe.contract.Call(opts, &out, "domainSeparator")

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// DomainSeparator is a free data retrieval call binding the contract method 0xf698da25.
//
// Solidity: function domainSeparator() view returns(bytes32)
func (_Safe *SafeSession) DomainSeparator() ([32]byte, error) {
	return _Safe.Contract.DomainSeparator(&_Safe.CallOpts)
}

// DomainSeparator is a free data retrieval call binding the contract method 0xf698da25.
//
// Solidity: function domainSeparator() view returns(bytes32)
func (_Safe *SafeCallerSession) DomainSeparator() ([32]byte, error) {
	return _Safe.Contract.DomainSeparator(&_Safe.CallOpts)
}

// GetModulesPaginated is a free data retrieval call binding the contract method 0xcc2f8452.
//
// Solidity: function getModulesPaginated(address start, uint256 pageSize) view returns(address[] array, address next)
func (_Safe *SafeCaller) GetModulesPaginated(opts *bind.CallOpts, start common.Address, pageSize *big.Int) (struct {
	Array []common.Address
	Next  common.Address
}, error) {
	var out []interface{}
	err := _Safe.contract.Call(opts, &out, "getModulesPaginated", start, pageSize)

	outstruct := new(struct {
		Array []common.Address
		Next  common.Address
	})
	if err != nil {
		return *outstruct, err
	}

	outstruct.Array = *abi.ConvertType(out[0], new([]common.Address)).(*[]common.Address)
	outstruct.Next = *abi.ConvertType(out[1], new(common.Address)).(*common.Address)

	return *outstruct, err

}

// GetModulesPaginated is a free data retrieval call binding the contract method 0xcc2f8452.
//
// Solidity: function getModulesPaginated(address start, uint256 pageSize) view returns(address[] array, address next)
func (_Safe *SafeSession) GetModulesPaginated(start common.Address, pageSize *big.Int) (struct {
	Array []common.Address
	Next  common.Address
}, error) {
	return _Safe.Contract.GetModulesPaginated(&_Safe.CallOpts, start, pageSize)
}

// GetModulesPaginated is a free data retrieval call binding the contract method 0xcc2f8452.
//
// Solidity: function getModulesPaginated(address start, uint256 pageSize) view returns(address[] array, address next)
func (_Safe *SafeCallerSession) GetModulesPaginated(start common.Address, pageSize *big.Int) (struct {
	Array []common.Address
	Next  common.Address
}, error) {
	return _Safe.Contract.GetModulesPaginated(&_Safe.CallOpts, start, pageSize)
}

// GetOwners is a free data retrieval call binding the contract method 0xa0e67e2b.
//
// Solidity: function getOwners() view returns(address[])
func (_Safe *SafeCaller) GetOwners(opts *bind.CallOpts) ([]common.Address, error) {
	var out []interface{}
	err := _Safe.contract.Call(opts, &out, "getOwners")

	if err != nil {
		return *new([]common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new([]common.Address)).(*[]common.Address)

	return out0, err

}

// GetOwners is a free data retrieval call binding the contract method 0xa0e67e2b.
//
// Solidity: function getOwners() view returns(address[])
func (_Safe *SafeSession) GetOwners() ([]common.Address, error) {
	return _Safe.Contract.GetOwners(&_Safe.CallOpts)
}

// GetOwners is a free data retrieval call binding the contract method 0xa0e67e2b.
//
// Solidity: function getOwners() view returns(address[])
func (_Safe *SafeCallerSession) GetOwners() ([]common.Address, error) {
	return _Safe.Contract.GetOwners(&_Safe.CallOpts)
}

// GetStorageAt is a free data retrieval call binding the contract method 0x5624b25b.
//
// Solidity: function getStorageAt(uint256 offset, uint256 length) view returns(bytes)
func (_Safe *SafeCaller) GetStorageAt(opts *bind.CallOpts, offset *big.Int, length *big.Int) ([]byte, error) {
	var out []interface{}
	err := _Safe.contract.Call(opts, &out, "getStorageAt", offset, length)

	if err != nil {
		return *new([]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([]byte)).(*[]byte)

	return out0, err

}

// GetStorageAt is a free data retrieval call binding the contract method 0x5624b25b.
//
// Solidity: function getStorageAt(uint256 offset, uint256 length) view returns(bytes)
func (_Safe *SafeSession) GetStorageAt(offset *big.Int, length *big.Int) ([]byte, error) {
	return _Safe.Contract.GetStorageAt(&_Safe.CallOpts, offset, length)
}

// GetStorageAt is a free data retrieval call binding the contract method 0x5624b25b.
//
// Solidity: function getStorageAt(uint256 offset, uint256 length) view returns(bytes)
func (_Safe *SafeCallerSession) GetStorageAt(offset *big.Int, length *big.Int) ([]byte, error) {
	return _Safe.Contract.GetStorageAt(&_Safe.CallOpts, offset, length)
}

// GetThreshold is a free data retrieval call binding the contract method 0xe75235b8.
//
// Solidity: function getThreshold() view returns(uint256)
func (_Safe *SafeCaller) GetThreshold(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _Safe.contract.Call(opts, &out, "getThreshold")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// GetThreshold is a free data retrieval call binding the contract method 0xe75235b8.
//
// Solidity: function getThreshold() view returns(uint256)
func (_Safe *SafeSession) GetThreshold() (*big.Int, error) {
	return _Safe.Contract.GetThreshold(&_Safe.CallOpts)
}

// GetThreshold is a free data retrieval call binding the contract method 0xe75235b8.
//
// Solidity: function getThreshold() view returns(uint256)
func (_Safe *SafeCallerSession) GetThreshold() (*big.Int, error) {
	return _Safe.Contract.GetThreshold(&_Safe.CallOpts)
}

// GetTransactionHash is a free data retrieval call binding the contract method 0xd8d11f78.
//
// Solidity: function getTransactionHash(address to, uint256 value, bytes data, uint8 operation, uint256 safeTxGas, uint256 baseGas, uint256 gasPrice, address gasToken, address refundReceiver, uint256 _nonce) view returns(bytes32)
func (_Safe *SafeCaller) GetTransactionHash(opts *bind.CallOpts, to common.Address, value *big.Int, data []byte, operation uint8, safeTxGas *big.Int, baseGas *big.Int, gasPrice *big.Int, gasToken common.Address, refundReceiver common.Address, _nonce *big.Int) ([32]byte, error) {
	var out []interface{}
	err := _Safe.contract.Call(opts, &out, "getTransactionHash", to, value, data, operation, safeTxGas, baseGas, gasPrice, gasToken, refundReceiver, _nonce)

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// GetTransactionHash is a free data retrieval call binding the contract method 0xd8d11f78.
//
// Solidity: function getTransactionHash(address to, uint256 value, bytes data, uint8 operation, uint256 safeTxGas, uint256 baseGas, uint256 gasPrice, address gasToken, address refundReceiver, uint256 _nonce) view returns(bytes32)
func (_Safe *SafeSession) GetTransactionHash(to common.Address, value *big.Int, data []byte, operation uint8, safeTxGas *big.Int, baseGas *big.Int, gasPrice *big.Int, gasToken common.Address, refundReceiver common.Address, _nonce *big.Int) ([32]byte, error) {
	return _Safe.Contract.GetTransactionHash(&_Safe.CallOpts, to, value, data, operation, safeTxGas, baseGas, gasPrice, gasToken, refundReceiver, _nonce)
}

// GetTransactionHash is a free data retrieval call binding the contract method 0xd8d11f78.
//
// Solidity: function getTransactionHash(address to, uint256 value, bytes data, uint8 operation, uint256 safeTxGas, uint256 baseGas, uint256 gasPrice, address gasToken, address refundReceiver, uint256 _nonce) view returns(bytes32)
func (_Safe *SafeCallerSession) GetTransactionHash(to common.Address, value *big.Int, data []byte, operation uint8, safeTxGas *big.Int, baseGas *big.Int, gasPrice *big.Int, gasToken common.Address, refundReceiver common.Address, _nonce *big.Int) ([32]byte, error) {
	return _Safe.Contract.GetTransactionHash(&_Safe.CallOpts, to, value, data, operation, safeTxGas, baseGas, gasPrice, gasToken, refundReceiver, _nonce)
}

// IsModuleEnabled is a free data retrieval call binding the contract method 0x2d9ad53d.
//
// Solidity: function isModuleEnabled(address module) view returns(bool)
func (_Safe *SafeCaller) IsModuleEnabled(opts *bind.CallOpts, module common.Address) (bool, error) {
	var out []interface{}
	err := _Safe.contract.Call(opts, &out, "isModuleEnabled", module)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// IsModuleEnabled is a free data retrieval call binding the contract method 0x2d9ad53d.
//
// Solidity: function isModuleEnabled(address module) view returns(bool)
func (_Safe *SafeSession) IsModuleEnabled(module common.Address) (bool, error) {
	return _Safe.Contract.IsModuleEnabled(&_Safe.CallOpts, module)
}

// IsModuleEnabled is a free data retrieval call binding the contract method 0x2d9ad53d.
//
// Solidity: function isModuleEnabled(address module) view returns(bool)
func (_Safe *SafeCallerSession) IsModuleEnabled(module common.Address) (bool, error) {
	return _Safe.Contract.IsModuleEnabled(&_Safe.CallOpts, module)
}

// IsOwner is a free data retrieval call binding the contract method 0x2f54bf6e.
//
// Solidity: function isOwner(address owner) view returns(bool)
func (_Safe *SafeCaller) IsOwner(opts *bind.CallOpts, owner common.Address) (bool, error) {
	var out []interface{}
	err := _Safe.contract.Call(opts, &out, "isOwner", owner)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// IsOwner is a free data retrieval call binding the contract method 0x2f54bf6e.
//
// Solidity: function isOwner(address owner) view returns(bool)
func (_Safe *SafeSession) IsOwner(owner common.Address) (bool, error) {
	return _Safe.Contract.IsOwner(&_Safe.CallOpts, owner)
}

// IsOwner is a free data retrieval call binding the contract method 0x2f54bf6e.
//
// Solidity: function isOwner(address owner) view returns(bool)
func (_Safe *SafeCallerSession) IsOwner(owner common.Address) (bool, error) {
	return _Safe.Contract.IsOwner(&_Safe.CallOpts, owner)
}

// Nonce is a free data retrieval call binding the contract method 0xaffed0e0.
//
// Solidity: function nonce() view returns(uint256)
func (_Safe *SafeCaller) Nonce(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _Safe.contract.Call(opts, &out, "nonce")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// Nonce is a free data retrieval call binding the contract method 0xaffed0e0.
//
// Solidity: function nonce() view returns(uint256)
func (_Safe *SafeSession) Nonce() (*big.Int, error) {
	return _Safe.Contract.Nonce(&_Safe.CallOpts)
}

// Nonce is a free data retrieval call binding the contract method 0xaffed0e0.
//
// Solidity: function nonce() view returns(uint256)
func (_Safe *SafeCallerSession) Nonce() (*big.Int, error) {
	return _Safe.Contract.Nonce(&_Safe.CallOpts)
}

// SignedMessages is a free data retrieval call binding the contract method 0x5ae6bd37.
//
// Solidity: function signedMessages(bytes32 ) view returns(uint256)
func (_Safe *SafeCaller) SignedMessages(opts *bind.CallOpts, arg0 [32]byte) (*big.Int, error) {
	var out []interface{}
	err := _Safe.contract.Call(opts, &out, "signedMessages", arg0)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// SignedMessages is a free data retrieval call binding the contract method 0x5ae6bd37.
//
// Solidity: function signedMessages(bytes32 ) view returns(uint256)
func (_Safe *SafeSession) SignedMessages(arg0 [32]byte) (*big.Int, error) {
	return _Safe.Contract.SignedMessages(&_Safe.CallOpts, arg0)
}

// SignedMessages is a free data retrieval call binding the contract method 0x5ae6bd37.
//
// Solidity: function signedMessages(bytes32 ) view returns(uint256)
func (_Safe *SafeCallerSession) SignedMessages(arg0 [32]byte) (*big.Int, error) {
	return _Safe.Contract.SignedMessages(&_Safe.CallOpts, arg0)
}

// AddOwnerWithThreshold is a paid mutator transaction binding the contract method 0x0d582f13.
//
// Solidity: function addOwnerWithThreshold(address owner, uint256 _threshold) returns()
func (_Safe *SafeTransactor) AddOwnerWithThreshold(opts *bind.TransactOpts, owner common.Address, _threshold *big.Int) (*types.Transaction, error) {
	return _Safe.contract.Transact(opts, "addOwnerWithThreshold", owner, _threshold)
}

// AddOwnerWithThreshold is a paid mutator transaction binding the contract method 0x0d582f13.
//
// Solidity: function addOwnerWithThreshold(address owner, uint256 _threshold) returns()
func (_Safe *SafeSession) AddOwnerWithThreshold(owner common.Address, _threshold *big.Int) (*types.Transaction, error) {
	return _Safe.Contract.AddOwnerWithThreshold(&_Safe.TransactOpts, owner, _threshold)
}

// AddOwnerWithThreshold is a paid mutator transaction binding the contract method 0x0d582f13.
//
// Solidity: function addOwnerWithThreshold(address owner, uint256 _threshold) returns()
func (_Safe *SafeTransactorSession) AddOwnerWithThreshold(owner common.Address, _threshold *big.Int) (*types.Transaction, error) {
	return _Safe.Contract.AddOwnerWithThreshold(&_Safe.TransactOpts, owner, _threshold)
}

// ApproveHash is a paid mutator transaction binding the contract method 0xd4d9bdcd.
//
// Solidity: function approveHash(bytes32 hashToApprove) returns()
func (_Safe *SafeTransactor) ApproveHash(opts *bind.TransactOpts, hashToApprove [32]byte) (*types.Transaction, error) {
	return _Safe.contract.Transact(opts, "approveHash", hashToApprove)
}

// ApproveHash is a paid mutator transaction binding the contract method 0xd4d9bdcd.
//
// Solidity: function approveHash(bytes32 hashToApprove) returns()
func (_Safe *SafeSession) ApproveHash(hashToApprove [32]byte) (*types.Transaction, error) {
	return _Safe.Contract.ApproveHash(&_Safe.TransactOpts, hashToApprove)
}

// ApproveHash is a paid mutator transaction binding the contract method 0xd4d9bdcd.
//
// Solidity: function approveHash(bytes32 hashToApprove) returns()
func (_Safe *SafeTransactorSession) ApproveHash(hashToApprove [32]byte) (*types.Transaction, error) {
	return _Safe.Contract.ApproveHash(&_Safe.TransactOpts, hashToApprove)
}

// ChangeThreshold is a paid mutator transaction binding the contract method 0x694e80c3.
//
// Solidity: function changeThreshold(uint256 _threshold) returns()
func (_Safe *SafeTransactor) ChangeThreshold(opts *bind.TransactOpts, _threshold *big.Int) (*types.Transaction, error) {
	return _Safe.contract.Transact(opts, "changeThreshold", _threshold)
}

// ChangeThreshold is a paid mutator transaction binding the contract method 0x694e80c3.
//
// Solidity: function changeThreshold(uint256 _threshold) returns()
func (_Safe *SafeSession) ChangeThreshold(_threshold *big.Int) (*types.Transaction, error) {
	return _Safe.Contract.ChangeThreshold(&_Safe.TransactOpts, _threshold)
}

// ChangeThreshold is a paid mutator transaction binding the contract method 0x694e80c3.
//
// Solidity: function changeThreshold(uint256 _threshold) returns()
func (_Safe *SafeTransactorSession) ChangeThreshold(_threshold *big.Int) (*types.Transaction, error) {
	return _Safe.Contract.ChangeThreshold(&_Safe.TransactOpts, _threshold)
}

// DisableModule is a paid mutator transaction binding the contract method 0xe009cfde.
//
// Solidity: function disableModule(address prevModule, address module) returns()
func (_Safe *SafeTransactor) DisableModule(opts *bind.TransactOpts, prevModule common.Address, module common.Address) (*types.Transaction, error) {
	return _Safe.contract.Transact(opts, "disableModule", prevModule, module)
}

// DisableModule is a paid mutator transaction binding the contract method 0xe009cfde.
//
// Solidity: function disableModule(address prevModule, address module) returns()
func (_Safe *SafeSession) DisableModule(prevModule common.Address, module common.Address) (*types.Transaction, error) {
	return _Safe.Contract.DisableModule(&_Safe.TransactOpts, prevModule, module)
}

// DisableModule is a paid mutator transaction binding the contract method 0xe009cfde.
//
// Solidity: function disableModule(address prevModule, address module) returns()
func (_Safe *SafeTransactorSession) DisableModule(prevModule common.Address, module common.Address) (*types.Transaction, error) {
	return _Safe.Contract.DisableModule(&_Safe.TransactOpts, prevModule, module)
}

// EnableModule is a paid mutator transaction binding the contract method 0x610b5925.
//
// Solidity: function enableModule(address module) returns()
func (_Safe *SafeTransactor) EnableModule(opts *bind.TransactOpts, module common.Address) (*types.Transaction, error) {
	return _Safe.contract.Transact(opts, "enableModule", module)
}

// EnableModule is a paid mutator transaction binding the contract method 0x610b5925.
//
// Solidity: function enableModule(address module) returns()
func (_Safe *SafeSession) EnableModule(module common.Address) (*types.Transaction, error) {
	return _Safe.Contract.EnableModule(&_Safe.TransactOpts, module)
}

// EnableModule is a paid mutator transaction binding the contract method 0x610b5925.
//
// Solidity: function enableModule(address module) returns()
func (_Safe *SafeTransactorSession) EnableModule(module common.Address) (*types.Transaction, error) {
	return _Safe.Contract.EnableModule(&_Safe.TransactOpts, module)
}

// ExecTransaction is a paid mutator transaction binding the contract method 0x6a761202.
//
// Solidity: function execTransaction(address to, uint256 value, bytes data, uint8 operation, uint256 safeTxGas, uint256 baseGas, uint256 gasPrice, address gasToken, address refundReceiver, bytes signatures) payable returns(bool success)
func (_Safe *SafeTransactor) ExecTransaction(opts *bind.TransactOpts, to common.Address, value *big.Int, data []byte, operation uint8, safeTxGas *big.Int, baseGas *big.Int, gasPrice *big.Int, gasToken common.Address, refundReceiver common.Address, signatures []byte) (*types.Transaction, error) {
	return _Safe.contract.Transact(opts, "execTransaction", to, value, data, operation, safeTxGas, baseGas, gasPrice, gasToken, refundReceiver, signatures)
}

// ExecTransaction is a paid mutator transaction binding the contract method 0x6a761202.
//
// Solidity: function execTransaction(address to, uint256 value, bytes data, uint8 operation, uint256 safeTxGas, uint256 baseGas, uint256 gasPrice, address gasToken, address refundReceiver, bytes signatures) payable returns(bool success)
func (_Safe *SafeSession) ExecTransaction(to common.Address, value *big.Int, data []byte, operation uint8, safeTxGas *big.Int, baseGas *big.Int, gasPrice *big.Int, gasToken common.Address, refundReceiver common.Address, signatures []byte) (*types.Transaction, error) {
	return _Safe.Contract.ExecTransaction(&_Safe.TransactOpts, to, value, data, operation, safeTxGas, baseGas, gasPrice, gasToken, refundReceiver, signatures)
}

// ExecTransaction is a paid mutator transaction binding the contract method 0x6a761202.
//
// Solidity: function execTransaction(address to, uint256 value, bytes data, uint8 operation, uint256 safeTxGas, uint256 baseGas, uint256 gasPrice, address gasToken, address refundReceiver, bytes signatures) payable returns(bool success)
func (_Safe *SafeTransactorSession) ExecTransaction(to common.Address, value *big.Int, data []byte, operation uint8, safeTxGas *big.Int, baseGas *big.Int, gasPrice *big.Int, gasToken common.Address, refundReceiver common.Address, signatures []byte) (*types.Transaction, error) {
	return _Safe.Contract.ExecTransaction(&_Safe.TransactOpts, to, value, data, operation, safeTxGas, baseGas, gasPrice, gasToken, refundReceiver, signatures)
}

// ExecTransactionFromModule is a paid mutator transaction binding the contract method 0x468721a7.
//
// Solidity: function execTransactionFromModule(address to, uint256 value, bytes data, uint8 operation) returns(bool success)
func (_Safe *SafeTransactor) ExecTransactionFromModule(opts *bind.TransactOpts, to common.Address, value *big.Int, data []byte, operation uint8) (*types.Transaction, error) {
	return _Safe.contract.Transact(opts, "execTransactionFromModule", to, value, data, operation)
}

// ExecTransactionFromModule is a paid mutator transaction binding the contract method 0x468721a7.
//
// Solidity: function execTransactionFromModule(address to, uint256 value, bytes data, uint8 operation) returns(bool success)
func (_Safe *SafeSession) ExecTransactionFromModule(to common.Address, value *big.Int, data []byte, operation uint8) (*types.Transaction, error) {
	return _Safe.Contract.ExecTransactionFromModule(&_Safe.TransactOpts, to, value, data, operation)
}

// ExecTransactionFromModule is a paid mutator transaction binding the contract method 0x468721a7.
//
// Solidity: function execTransactionFromModule(address to, uint256 value, bytes data, uint8 operation) returns(bool success)
func (_Safe *SafeTransactorSession) ExecTransactionFromModule(to common.Address, value *big.Int, data []byte, operation uint8) (*types.Transaction, error) {
	return _Safe.Contract.ExecTransactionFromModule(&_Safe.TransactOpts, to, value, data, operation)
}

// ExecTransactionFromModuleReturnData is a paid mutator transaction binding the contract method 0x5229073f.
//
// Solidity: function execTransactionFromModuleReturnData(address to, uint256 value, bytes data, uint8 operation) returns(bool success, bytes returnData)
func (_Safe *SafeTransactor) ExecTransactionFromModuleReturnData(opts *bind.TransactOpts, to common.Address, value *big.Int, data []byte, operation uint8) (*types.Transaction, error) {
	return _Safe.contract.Transact(opts, "execTransactionFromModuleReturnData", to, value, data, operation)
}

// ExecTransactionFromModuleReturnData is a paid mutator transaction binding the contract method 0x5229073f.
//
// Solidity: function execTransactionFromModuleReturnData(address to, uint256 value, bytes data, uint8 operation) returns(bool success, bytes returnData)
func (_Safe *SafeSession) ExecTransactionFromModuleReturnData(to common.Address, value *big.Int, data []byte, operation uint8) (*types.Transaction, error) {
	return _Safe.Contract.ExecTransactionFromModuleReturnData(&_Safe.TransactOpts, to, value, data, operation)
}

// ExecTransactionFromModuleReturnData is a paid mutator transaction binding the contract method 0x5229073f.
//
// Solidity: function execTransactionFromModuleReturnData(address to, uint256 value, bytes data, uint8 operation) returns(bool success, bytes returnData)
func (_Safe *SafeTransactorSession) ExecTransactionFromModuleReturnData(to common.Address, value *big.Int, data []byte, operation uint8) (*types.Transaction, error) {
	return _Safe.Contract.ExecTransactionFromModuleReturnData(&_Safe.TransactOpts, to, value, data, operation)
}

// RemoveOwner is a paid mutator transaction binding the contract method 0xf8dc5dd9.
//
// Solidity: function removeOwner(address prevOwner, address owner, uint256 _threshold) returns()
func (_Safe *SafeTransactor) RemoveOwner(opts *bind.TransactOpts, prevOwner common.Address, owner common.Address, _threshold *big.Int) (*types.Transaction, error) {
	return _Safe.contract.Transact(opts, "removeOwner", prevOwner, owner, _threshold)
}

// RemoveOwner is a paid mutator transaction binding the contract method 0xf8dc5dd9.
//
// Solidity: function removeOwner(address prevOwner, address owner, uint256 _threshold) returns()
func (_Safe *SafeSession) RemoveOwner(prevOwner common.Address, owner common.Address, _threshold *big.Int) (*types.Transaction, error) {
	return _Safe.Contract.RemoveOwner(&_Safe.TransactOpts, prevOwner, owner, _threshold)
}

// RemoveOwner is a paid mutator transaction binding the contract method 0xf8dc5dd9.
//
// Solidity: function removeOwner(address prevOwner, address owner, uint256 _threshold) returns()
func (_Safe *SafeTransactorSession) RemoveOwner(prevOwner common.Address, owner common.Address, _threshold *big.Int) (*types.Transaction, error) {
	return _Safe.Contract.RemoveOwner(&_Safe.TransactOpts, prevOwner, owner, _threshold)
}

// SetFallbackHandler is a paid mutator transaction binding the contract method 0xf08a0323.
//
// Solidity: function setFallbackHandler(address handler) returns()
func (_Safe *SafeTransactor) SetFallbackHandler(opts *bind.TransactOpts, handler common.Address) (*types.Transaction, error) {
	return _Safe.contract.Transact(opts, "setFallbackHandler", handler)
}

// SetFallbackHandler is a paid mutator transaction binding the contract method 0xf08a0323.
//
// Solidity: function setFallbackHandler(address handler) returns()
func (_Safe *SafeSession) SetFallbackHandler(handler common.Address) (*types.Transaction, error) {
	return _Safe.Contract.SetFallbackHandler(&_Safe.TransactOpts, handler)
}

// SetFallbackHandler is a paid mutator transaction binding the contract method 0xf08a0323.
//
// Solidity: function setFallbackHandler(address handler) returns()
func (_Safe *SafeTransactorSession) SetFallbackHandler(handler common.Address) (*types.Transaction, error) {
	return _Safe.Contract.SetFallbackHandler(&_Safe.TransactOpts, handler)
}

// SetGuard is a paid mutator transaction binding the contract method 0xe19a9dd9.
//
// Solidity: function setGuard(address guard) returns()
func (_Safe *SafeTransactor) SetGuard(opts *bind.TransactOpts, guard common.Address) (*types.Transaction, error) {
	return _Safe.contract.Transact(opts, "setGuard", guard)
}

// SetGuard is a paid mutator transaction binding the contract method 0xe19a9dd9.
//
// Solidity: function setGuard(address guard) returns()
func (_Safe *SafeSession) SetGuard(guard common.Address) (*types.Transaction, error) {
	return _Safe.Contract.SetGuard(&_Safe.TransactOpts, guard)
}

// SetGuard is a paid mutator transaction binding the contract method 0xe19a9dd9.
//
// Solidity: function setGuard(address guard) returns()
func (_Safe *SafeTransactorSession) SetGuard(guard common.Address) (*types.Transaction, error) {
	return _Safe.Contract.SetGuard(&_Safe.TransactOpts, guard)
}

// SetModuleGuard is a paid mutator transaction binding the contract method 0xe068df37.
//
// Solidity: function setModuleGuard(address moduleGuard) returns()
func (_Safe *SafeTransactor) SetModuleGuard(opts *bind.TransactOpts, moduleGuard common.Address) (*types.Transaction, error) {
	return _Safe.contract.Transact(opts, "setModuleGuard", moduleGuard)
}

// SetModuleGuard is a paid mutator transaction binding the contract method 0xe068df37.
//
// Solidity: function setModuleGuard(address moduleGuard) returns()
func (_Safe *SafeSession) SetModuleGuard(moduleGuard common.Address) (*types.Transaction, error) {
	return _Safe.Contract.SetModuleGuard(&_Safe.TransactOpts, moduleGuard)
}

// SetModuleGuard is a paid mutator transaction binding the contract method 0xe068df37.
//
// Solidity: function setModuleGuard(address moduleGuard) returns()
func (_Safe *SafeTransactorSession) SetModuleGuard(moduleGuard common.Address) (*types.Transaction, error) {
	return _Safe.Contract.SetModuleGuard(&_Safe.TransactOpts, moduleGuard)
}

// Setup is a paid mutator transaction binding the contract method 0xb63e800d.
//
// Solidity: function setup(address[] _owners, uint256 _threshold, address to, bytes data, address fallbackHandler, address paymentToken, uint256 payment, address paymentReceiver) returns()
func (_Safe *SafeTransactor) Setup(opts *bind.TransactOpts, _owners []common.Address, _threshold *big.Int, to common.Address, data []byte, fallbackHandler common.Address, paymentToken common.Address, payment *big.Int, paymentReceiver common.Address) (*types.Transaction, error) {
	return _Safe.contract.Transact(opts, "setup", _owners, _threshold, to, data, fallbackHandler, paymentToken, payment, paymentReceiver)
}

// Setup is a paid mutator transaction binding the contract method 0xb63e800d.
//
// Solidity: function setup(address[] _owners, uint256 _threshold, address to, bytes data, address fallbackHandler, address paymentToken, uint256 payment, address paymentReceiver) returns()
func (_Safe *SafeSession) Setup(_owners []common.Address, _threshold *big.Int, to common.Address, data []byte, fallbackHandler common.Address, paymentToken common.Address, payment *big.Int, paymentReceiver common.Address) (*types.Transaction, error) {
	return _Safe.Contract.Setup(&_Safe.TransactOpts, _owners, _threshold, to, data, fallbackHandler, paymentToken, payment, paymentReceiver)
}

// Setup is a paid mutator transaction binding the contract method 0xb63e800d.
//
// Solidity: function setup(address[] _owners, uint256 _threshold, address to, bytes data, address fallbackHandler, address paymentToken, uint256 payment, address paymentReceiver) returns()
func (_Safe *SafeTransactorSession) Setup(_owners []common.Address, _threshold *big.Int, to common.Address, data []byte, fallbackHandler common.Address, paymentToken common.Address, payment *big.Int, paymentReceiver common.Address) (*types.Transaction, error) {
	return _Safe.Contract.Setup(&_Safe.TransactOpts, _owners, _threshold, to, data, fallbackHandler, paymentToken, payment, paymentReceiver)
}

// SimulateAndRevert is a paid mutator transaction binding the contract method 0xb4faba09.
//
// Solidity: function simulateAndRevert(address targetContract, bytes calldataPayload) returns()
func (_Safe *SafeTransactor) SimulateAndRevert(opts *bind.TransactOpts, targetContract common.Address, calldataPayload []byte) (*types.Transaction, error) {
	return _Safe.contract.Transact(opts, "simulateAndRevert", targetContract, calldataPayload)
}

// SimulateAndRevert is a paid mutator transaction binding the contract method 0xb4faba09.
//
// Solidity: function simulateAndRevert(address targetContract, bytes calldataPayload) returns()
func (_Safe *SafeSession) SimulateAndRevert(targetContract common.Address, calldataPayload []byte) (*types.Transaction, error) {
	return _Safe.Contract.SimulateAndRevert(&_Safe.TransactOpts, targetContract, calldataPayload)
}

// SimulateAndRevert is a paid mutator transaction binding the contract method 0xb4faba09.
//
// Solidity: function simulateAndRevert(address targetContract, bytes calldataPayload) returns()
func (_Safe *SafeTransactorSession) SimulateAndRevert(targetContract common.Address, calldataPayload []byte) (*types.Transaction, error) {
	return _Safe.Contract.SimulateAndRevert(&_Safe.TransactOpts, targetContract, calldataPayload)
}

// SwapOwner is a paid mutator transaction binding the contract method 0xe318b52b.
//
// Solidity: function swapOwner(address prevOwner, address oldOwner, address newOwner) returns()
func (_Safe *SafeTransactor) SwapOwner(opts *bind.TransactOpts, prevOwner common.Address, oldOwner common.Address, newOwner common.Address) (*types.Transaction, error) {
	return _Safe.contract.Transact(opts, "swapOwner", prevOwner, oldOwner, newOwner)
}

// SwapOwner is a paid mutator transaction binding the contract method 0xe318b52b.
//
// Solidity: function swapOwner(address prevOwner, address oldOwner, address newOwner) returns()
func (_Safe *SafeSession) SwapOwner(prevOwner common.Address, oldOwner common.Address, newOwner common.Address) (*types.Transaction, error) {
	return _Safe.Contract.SwapOwner(&_Safe.TransactOpts, prevOwner, oldOwner, newOwner)
}

// SwapOwner is a paid mutator transaction binding the contract method 0xe318b52b.
//
// Solidity: function swapOwner(address prevOwner, address oldOwner, address newOwner) returns()
func (_Safe *SafeTransactorSession) SwapOwner(prevOwner common.Address, oldOwner common.Address, newOwner common.Address) (*types.Transaction, error) {
	return _Safe.Contract.SwapOwner(&_Safe.TransactOpts, prevOwner, oldOwner, newOwner)
}

// Fallback is a paid mutator transaction binding the contract fallback function.
//
// Solidity: fallback() returns()
func (_Safe *SafeTransactor) Fallback(opts *bind.TransactOpts, calldata []byte) (*types.Transaction, error) {
	return _Safe.contract.RawTransact(opts, calldata)
}

// Fallback is a paid mutator transaction binding the contract fallback function.
//
// Solidity: fallback() returns()
func (_Safe *SafeSession) Fallback(calldata []byte) (*types.Transaction, error) {
	return _Safe.Contract.Fallback(&_Safe.TransactOpts, calldata)
}

// Fallback is a paid mutator transaction binding the contract fallback function.
//
// Solidity: fallback() returns()
func (_Safe *SafeTransactorSession) Fallback(calldata []byte) (*types.Transaction, error) {
	return _Safe.Contract.Fallback(&_Safe.TransactOpts, calldata)
}

// Receive is a paid mutator transaction binding the contract receive function.
//
// Solidity: receive() payable returns()
func (_Safe *SafeTransactor) Receive(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Safe.contract.RawTransact(opts, nil) // calldata is disallowed for receive function
}

// Receive is a paid mutator transaction binding the contract receive function.
//
// Solidity: receive() payable returns()
func (_Safe *SafeSession) Receive() (*types.Transaction, error) {
	return _Safe.Contract.Receive(&_Safe.TransactOpts)
}

// Receive is a paid mutator transaction binding the contract receive function.
//
// Solidity: receive() payable returns()
func (_Safe *SafeTransactorSession) Receive() (*types.Transaction, error) {
	return _Safe.Contract.Receive(&_Safe.TransactOpts)
}

// SafeAddedOwnerIterator is returned from FilterAddedOwner and is used to iterate over the raw logs and unpacked data for AddedOwner events raised by the Safe contract.
type SafeAddedOwnerIterator struct {
	Event *SafeAddedOwner // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *SafeAddedOwnerIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(SafeAddedOwner)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(SafeAddedOwner)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *SafeAddedOwnerIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *SafeAddedOwnerIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// SafeAddedOwner represents a AddedOwner event raised by the Safe contract.
type SafeAddedOwner struct {
	Owner common.Address
	Raw   types.Log // Blockchain specific contextual infos
}

// FilterAddedOwner is a free log retrieval operation binding the contract event 0x9465fa0c962cc76958e6373a993326400c1c94f8be2fe3a952adfa7f60b2ea26.
//
// Solidity: event AddedOwner(address indexed owner)
func (_Safe *SafeFilterer) FilterAddedOwner(opts *bind.FilterOpts, owner []common.Address) (*SafeAddedOwnerIterator, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}

	logs, sub, err := _Safe.contract.FilterLogs(opts, "AddedOwner", ownerRule)
	if err != nil {
		return nil, err
	}
	return &SafeAddedOwnerIterator{contract: _Safe.contract, event: "AddedOwner", logs: logs, sub: sub}, nil
}

// WatchAddedOwner is a free log subscription operation binding the contract event 0x9465fa0c962cc76958e6373a993326400c1c94f8be2fe3a952adfa7f60b2ea26.
//
// Solidity: event AddedOwner(address indexed owner)
func (_Safe *SafeFilterer) WatchAddedOwner(opts *bind.WatchOpts, sink chan<- *SafeAddedOwner, owner []common.Address) (event.Subscription, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}

	logs, sub, err := _Safe.contract.WatchLogs(opts, "AddedOwner", ownerRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(SafeAddedOwner)
				if err := _Safe.contract.UnpackLog(event, "AddedOwner", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseAddedOwner is a log parse operation binding the contract event 0x9465fa0c962cc76958e6373a993326400c1c94f8be2fe3a952adfa7f60b2ea26.
//
// Solidity: event AddedOwner(address indexed owner)
func (_Safe *SafeFilterer) ParseAddedOwner(log types.Log) (*SafeAddedOwner, error) {
	event := new(SafeAddedOwner)
	if err := _Safe.contract.UnpackLog(event, "AddedOwner", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// SafeApproveHashIterator is returned from FilterApproveHash and is used to iterate over the raw logs and unpacked data for ApproveHash events raised by the Safe contract.
type SafeApproveHashIterator struct {
	Event *SafeApproveHash // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *SafeApproveHashIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(SafeApproveHash)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(SafeApproveHash)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *SafeApproveHashIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *SafeApproveHashIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// SafeApproveHash represents a ApproveHash event raised by the Safe contract.
type SafeApproveHash struct {
	ApprovedHash [32]byte
	Owner        common.Address
	Raw          types.Log // Blockchain specific contextual infos
}

// FilterApproveHash is a free log retrieval operation binding the contract event 0xf2a0eb156472d1440255b0d7c1e19cc07115d1051fe605b0dce69acfec884d9c.
//
// Solidity: event ApproveHash(bytes32 indexed approvedHash, address indexed owner)
func (_Safe *SafeFilterer) FilterApproveHash(opts *bind.FilterOpts, approvedHash [][32]byte, owner []common.Address) (*SafeApproveHashIterator, error) {

	var approvedHashRule []interface{}
	for _, approvedHashItem := range approvedHash {
		approvedHashRule = append(approvedHashRule, approvedHashItem)
	}
	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}

	logs, sub, err := _Safe.contract.FilterLogs(opts, "ApproveHash", approvedHashRule, ownerRule)
	if err != nil {
		return nil, err
	}
	return &SafeApproveHashIterator{contract: _Safe.contract, event: "ApproveHash", logs: logs, sub: sub}, nil
}

// WatchApproveHash is a free log subscription operation binding the contract event 0xf2a0eb156472d1440255b0d7c1e19cc07115d1051fe605b0dce69acfec884d9c.
//
// Solidity: event ApproveHash(bytes32 indexed approvedHash, address indexed owner)
func (_Safe *SafeFilterer) WatchApproveHash(opts *bind.WatchOpts, sink chan<- *SafeApproveHash, approvedHash [][32]byte, owner []common.Address) (event.Subscription, error) {

	var approvedHashRule []interface{}
	for _, approvedHashItem := range approvedHash {
		approvedHashRule = append(approvedHashRule, approvedHashItem)
	}
	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}

	logs, sub, err := _Safe.contract.WatchLogs(opts, "ApproveHash", approvedHashRule, ownerRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(SafeApproveHash)
				if err := _Safe.contract.UnpackLog(event, "ApproveHash", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseApproveHash is a log parse operation binding the contract event 0xf2a0eb156472d1440255b0d7c1e19cc07115d1051fe605b0dce69acfec884d9c.
//
// Solidity: event ApproveHash(bytes32 indexed approvedHash, address indexed owner)
func (_Safe *SafeFilterer) ParseApproveHash(log types.Log) (*SafeApproveHash, error) {
	event := new(SafeApproveHash)
	if err := _Safe.contract.UnpackLog(event, "ApproveHash", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// SafeChangedFallbackHandlerIterator is returned from FilterChangedFallbackHandler and is used to iterate over the raw logs and unpacked data for ChangedFallbackHandler events raised by the Safe contract.
type SafeChangedFallbackHandlerIterator struct {
	Event *SafeChangedFallbackHandler // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *SafeChangedFallbackHandlerIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(SafeChangedFallbackHandler)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(SafeChangedFallbackHandler)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *SafeChangedFallbackHandlerIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *SafeChangedFallbackHandlerIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// SafeChangedFallbackHandler represents a ChangedFallbackHandler event raised by the Safe contract.
type SafeChangedFallbackHandler struct {
	Handler common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterChangedFallbackHandler is a free log retrieval operation binding the contract event 0x5ac6c46c93c8d0e53714ba3b53db3e7c046da994313d7ed0d192028bc7c228b0.
//
// Solidity: event ChangedFallbackHandler(address indexed handler)
func (_Safe *SafeFilterer) FilterChangedFallbackHandler(opts *bind.FilterOpts, handler []common.Address) (*SafeChangedFallbackHandlerIterator, error) {

	var handlerRule []interface{}
	for _, handlerItem := range handler {
		handlerRule = append(handlerRule, handlerItem)
	}

	logs, sub, err := _Safe.contract.FilterLogs(opts, "ChangedFallbackHandler", handlerRule)
	if err != nil {
		return nil, err
	}
	return &SafeChangedFallbackHandlerIterator{contract: _Safe.contract, event: "ChangedFallbackHandler", logs: logs, sub: sub}, nil
}

// WatchChangedFallbackHandler is a free log subscription operation binding the contract event 0x5ac6c46c93c8d0e53714ba3b53db3e7c046da994313d7ed0d192028bc7c228b0.
//
// Solidity: event ChangedFallbackHandler(address indexed handler)
func (_Safe *SafeFilterer) WatchChangedFallbackHandler(opts *bind.WatchOpts, sink chan<- *SafeChangedFallbackHandler, handler []common.Address) (event.Subscription, error) {

	var handlerRule []interface{}
	for _, handlerItem := range handler {
		handlerRule = append(handlerRule, handlerItem)
	}

	logs, sub, err := _Safe.contract.WatchLogs(opts, "ChangedFallbackHandler", handlerRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(SafeChangedFallbackHandler)
				if err := _Safe.contract.UnpackLog(event, "ChangedFallbackHandler", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseChangedFallbackHandler is a log parse operation binding the contract event 0x5ac6c46c93c8d0e53714ba3b53db3e7c046da994313d7ed0d192028bc7c228b0.
//
// Solidity: event ChangedFallbackHandler(address indexed handler)
func (_Safe *SafeFilterer) ParseChangedFallbackHandler(log types.Log) (*SafeChangedFallbackHandler, error) {
	event := new(SafeChangedFallbackHandler)
	if err := _Safe.contract.UnpackLog(event, "ChangedFallbackHandler", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// SafeChangedGuardIterator is returned from FilterChangedGuard and is used to iterate over the raw logs and unpacked data for ChangedGuard events raised by the Safe contract.
type SafeChangedGuardIterator struct {
	Event *SafeChangedGuard // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *SafeChangedGuardIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(SafeChangedGuard)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(SafeChangedGuard)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *SafeChangedGuardIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *SafeChangedGuardIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// SafeChangedGuard represents a ChangedGuard event raised by the Safe contract.
type SafeChangedGuard struct {
	Guard common.Address
	Raw   types.Log // Blockchain specific contextual infos
}

// FilterChangedGuard is a free log retrieval operation binding the contract event 0x1151116914515bc0891ff9047a6cb32cf902546f83066499bcf8ba33d2353fa2.
//
// Solidity: event ChangedGuard(address indexed guard)
func (_Safe *SafeFilterer) FilterChangedGuard(opts *bind.FilterOpts, guard []common.Address) (*SafeChangedGuardIterator, error) {

	var guardRule []interface{}
	for _, guardItem := range guard {
		guardRule = append(guardRule, guardItem)
	}

	logs, sub, err := _Safe.contract.FilterLogs(opts, "ChangedGuard", guardRule)
	if err != nil {
		return nil, err
	}
	return &SafeChangedGuardIterator{contract: _Safe.contract, event: "ChangedGuard", logs: logs, sub: sub}, nil
}

// WatchChangedGuard is a free log subscription operation binding the contract event 0x1151116914515bc0891ff9047a6cb32cf902546f83066499bcf8ba33d2353fa2.
//
// Solidity: event ChangedGuard(address indexed guard)
func (_Safe *SafeFilterer) WatchChangedGuard(opts *bind.WatchOpts, sink chan<- *SafeChangedGuard, guard []common.Address) (event.Subscription, error) {

	var guardRule []interface{}
	for _, guardItem := range guard {
		guardRule = append(guardRule, guardItem)
	}

	logs, sub, err := _Safe.contract.WatchLogs(opts, "ChangedGuard", guardRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(SafeChangedGuard)
				if err := _Safe.contract.UnpackLog(event, "ChangedGuard", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseChangedGuard is a log parse operation binding the contract event 0x1151116914515bc0891ff9047a6cb32cf902546f83066499bcf8ba33d2353fa2.
//
// Solidity: event ChangedGuard(address indexed guard)
func (_Safe *SafeFilterer) ParseChangedGuard(log types.Log) (*SafeChangedGuard, error) {
	event := new(SafeChangedGuard)
	if err := _Safe.contract.UnpackLog(event, "ChangedGuard", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// SafeChangedModuleGuardIterator is returned from FilterChangedModuleGuard and is used to iterate over the raw logs and unpacked data for ChangedModuleGuard events raised by the Safe contract.
type SafeChangedModuleGuardIterator struct {
	Event *SafeChangedModuleGuard // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *SafeChangedModuleGuardIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(SafeChangedModuleGuard)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(SafeChangedModuleGuard)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *SafeChangedModuleGuardIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *SafeChangedModuleGuardIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// SafeChangedModuleGuard represents a ChangedModuleGuard event raised by the Safe contract.
type SafeChangedModuleGuard struct {
	ModuleGuard common.Address
	Raw         types.Log // Blockchain specific contextual infos
}

// FilterChangedModuleGuard is a free log retrieval operation binding the contract event 0xcd1966d6be16bc0c030cc741a06c6e0efaf8d00de2c8b6a9e11827e125de8bb8.
//
// Solidity: event ChangedModuleGuard(address indexed moduleGuard)
func (_Safe *SafeFilterer) FilterChangedModuleGuard(opts *bind.FilterOpts, moduleGuard []common.Address) (*SafeChangedModuleGuardIterator, error) {

	var moduleGuardRule []interface{}
	for _, moduleGuardItem := range moduleGuard {
		moduleGuardRule = append(moduleGuardRule, moduleGuardItem)
	}

	logs, sub, err := _Safe.contract.FilterLogs(opts, "ChangedModuleGuard", moduleGuardRule)
	if err != nil {
		return nil, err
	}
	return &SafeChangedModuleGuardIterator{contract: _Safe.contract, event: "ChangedModuleGuard", logs: logs, sub: sub}, nil
}

// WatchChangedModuleGuard is a free log subscription operation binding the contract event 0xcd1966d6be16bc0c030cc741a06c6e0efaf8d00de2c8b6a9e11827e125de8bb8.
//
// Solidity: event ChangedModuleGuard(address indexed moduleGuard)
func (_Safe *SafeFilterer) WatchChangedModuleGuard(opts *bind.WatchOpts, sink chan<- *SafeChangedModuleGuard, moduleGuard []common.Address) (event.Subscription, error) {

	var moduleGuardRule []interface{}
	for _, moduleGuardItem := range moduleGuard {
		moduleGuardRule = append(moduleGuardRule, moduleGuardItem)
	}

	logs, sub, err := _Safe.contract.WatchLogs(opts, "ChangedModuleGuard", moduleGuardRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(SafeChangedModuleGuard)
				if err := _Safe.contract.UnpackLog(event, "ChangedModuleGuard", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseChangedModuleGuard is a log parse operation binding the contract event 0xcd1966d6be16bc0c030cc741a06c6e0efaf8d00de2c8b6a9e11827e125de8bb8.
//
// Solidity: event ChangedModuleGuard(address indexed moduleGuard)
func (_Safe *SafeFilterer) ParseChangedModuleGuard(log types.Log) (*SafeChangedModuleGuard, error) {
	event := new(SafeChangedModuleGuard)
	if err := _Safe.contract.UnpackLog(event, "ChangedModuleGuard", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// SafeChangedThresholdIterator is returned from FilterChangedThreshold and is used to iterate over the raw logs and unpacked data for ChangedThreshold events raised by the Safe contract.
type SafeChangedThresholdIterator struct {
	Event *SafeChangedThreshold // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *SafeChangedThresholdIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(SafeChangedThreshold)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(SafeChangedThreshold)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *SafeChangedThresholdIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *SafeChangedThresholdIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// SafeChangedThreshold represents a ChangedThreshold event raised by the Safe contract.
type SafeChangedThreshold struct {
	Threshold *big.Int
	Raw       types.Log // Blockchain specific contextual infos
}

// FilterChangedThreshold is a free log retrieval operation binding the contract event 0x610f7ff2b304ae8903c3de74c60c6ab1f7d6226b3f52c5161905bb5ad4039c93.
//
// Solidity: event ChangedThreshold(uint256 threshold)
func (_Safe *SafeFilterer) FilterChangedThreshold(opts *bind.FilterOpts) (*SafeChangedThresholdIterator, error) {

	logs, sub, err := _Safe.contract.FilterLogs(opts, "ChangedThreshold")
	if err != nil {
		return nil, err
	}
	return &SafeChangedThresholdIterator{contract: _Safe.contract, event: "ChangedThreshold", logs: logs, sub: sub}, nil
}

// WatchChangedThreshold is a free log subscription operation binding the contract event 0x610f7ff2b304ae8903c3de74c60c6ab1f7d6226b3f52c5161905bb5ad4039c93.
//
// Solidity: event ChangedThreshold(uint256 threshold)
func (_Safe *SafeFilterer) WatchChangedThreshold(opts *bind.WatchOpts, sink chan<- *SafeChangedThreshold) (event.Subscription, error) {

	logs, sub, err := _Safe.contract.WatchLogs(opts, "ChangedThreshold")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(SafeChangedThreshold)
				if err := _Safe.contract.UnpackLog(event, "ChangedThreshold", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseChangedThreshold is a log parse operation binding the contract event 0x610f7ff2b304ae8903c3de74c60c6ab1f7d6226b3f52c5161905bb5ad4039c93.
//
// Solidity: event ChangedThreshold(uint256 threshold)
func (_Safe *SafeFilterer) ParseChangedThreshold(log types.Log) (*SafeChangedThreshold, error) {
	event := new(SafeChangedThreshold)
	if err := _Safe.contract.UnpackLog(event, "ChangedThreshold", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// SafeDisabledModuleIterator is returned from FilterDisabledModule and is used to iterate over the raw logs and unpacked data for DisabledModule events raised by the Safe contract.
type SafeDisabledModuleIterator struct {
	Event *SafeDisabledModule // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *SafeDisabledModuleIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(SafeDisabledModule)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(SafeDisabledModule)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *SafeDisabledModuleIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *SafeDisabledModuleIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// SafeDisabledModule represents a DisabledModule event raised by the Safe contract.
type SafeDisabledModule struct {
	Module common.Address
	Raw    types.Log // Blockchain specific contextual infos
}

// FilterDisabledModule is a free log retrieval operation binding the contract event 0xaab4fa2b463f581b2b32cb3b7e3b704b9ce37cc209b5fb4d77e593ace4054276.
//
// Solidity: event DisabledModule(address indexed module)
func (_Safe *SafeFilterer) FilterDisabledModule(opts *bind.FilterOpts, module []common.Address) (*SafeDisabledModuleIterator, error) {

	var moduleRule []interface{}
	for _, moduleItem := range module {
		moduleRule = append(moduleRule, moduleItem)
	}

	logs, sub, err := _Safe.contract.FilterLogs(opts, "DisabledModule", moduleRule)
	if err != nil {
		return nil, err
	}
	return &SafeDisabledModuleIterator{contract: _Safe.contract, event: "DisabledModule", logs: logs, sub: sub}, nil
}

// WatchDisabledModule is a free log subscription operation binding the contract event 0xaab4fa2b463f581b2b32cb3b7e3b704b9ce37cc209b5fb4d77e593ace4054276.
//
// Solidity: event DisabledModule(address indexed module)
func (_Safe *SafeFilterer) WatchDisabledModule(opts *bind.WatchOpts, sink chan<- *SafeDisabledModule, module []common.Address) (event.Subscription, error) {

	var moduleRule []interface{}
	for _, moduleItem := range module {
		moduleRule = append(moduleRule, moduleItem)
	}

	logs, sub, err := _Safe.contract.WatchLogs(opts, "DisabledModule", moduleRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(SafeDisabledModule)
				if err := _Safe.contract.UnpackLog(event, "DisabledModule", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseDisabledModule is a log parse operation binding the contract event 0xaab4fa2b463f581b2b32cb3b7e3b704b9ce37cc209b5fb4d77e593ace4054276.
//
// Solidity: event DisabledModule(address indexed module)
func (_Safe *SafeFilterer) ParseDisabledModule(log types.Log) (*SafeDisabledModule, error) {
	event := new(SafeDisabledModule)
	if err := _Safe.contract.UnpackLog(event, "DisabledModule", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// SafeEnabledModuleIterator is returned from FilterEnabledModule and is used to iterate over the raw logs and unpacked data for EnabledModule events raised by the Safe contract.
type SafeEnabledModuleIterator struct {
	Event *SafeEnabledModule // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *SafeEnabledModuleIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(SafeEnabledModule)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(SafeEnabledModule)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *SafeEnabledModuleIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *SafeEnabledModuleIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// SafeEnabledModule represents a EnabledModule event raised by the Safe contract.
type SafeEnabledModule struct {
	Module common.Address
	Raw    types.Log // Blockchain specific contextual infos
}

// FilterEnabledModule is a free log retrieval operation binding the contract event 0xecdf3a3effea5783a3c4c2140e677577666428d44ed9d474a0b3a4c9943f8440.
//
// Solidity: event EnabledModule(address indexed module)
func (_Safe *SafeFilterer) FilterEnabledModule(opts *bind.FilterOpts, module []common.Address) (*SafeEnabledModuleIterator, error) {

	var moduleRule []interface{}
	for _, moduleItem := range module {
		moduleRule = append(moduleRule, moduleItem)
	}

	logs, sub, err := _Safe.contract.FilterLogs(opts, "EnabledModule", moduleRule)
	if err != nil {
		return nil, err
	}
	return &SafeEnabledModuleIterator{contract: _Safe.contract, event: "EnabledModule", logs: logs, sub: sub}, nil
}

// WatchEnabledModule is a free log subscription operation binding the contract event 0xecdf3a3effea5783a3c4c2140e677577666428d44ed9d474a0b3a4c9943f8440.
//
// Solidity: event EnabledModule(address indexed module)
func (_Safe *SafeFilterer) WatchEnabledModule(opts *bind.WatchOpts, sink chan<- *SafeEnabledModule, module []common.Address) (event.Subscription, error) {

	var moduleRule []interface{}
	for _, moduleItem := range module {
		moduleRule = append(moduleRule, moduleItem)
	}

	logs, sub, err := _Safe.contract.WatchLogs(opts, "EnabledModule", moduleRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(SafeEnabledModule)
				if err := _Safe.contract.UnpackLog(event, "EnabledModule", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseEnabledModule is a log parse operation binding the contract event 0xecdf3a3effea5783a3c4c2140e677577666428d44ed9d474a0b3a4c9943f8440.
//
// Solidity: event EnabledModule(address indexed module)
func (_Safe *SafeFilterer) ParseEnabledModule(log types.Log) (*SafeEnabledModule, error) {
	event := new(SafeEnabledModule)
	if err := _Safe.contract.UnpackLog(event, "EnabledModule", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// SafeExecutionFailureIterator is returned from FilterExecutionFailure and is used to iterate over the raw logs and unpacked data for ExecutionFailure events raised by the Safe contract.
type SafeExecutionFailureIterator struct {
	Event *SafeExecutionFailure // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *SafeExecutionFailureIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(SafeExecutionFailure)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(SafeExecutionFailure)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *SafeExecutionFailureIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *SafeExecutionFailureIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// SafeExecutionFailure represents a ExecutionFailure event raised by the Safe contract.
type SafeExecutionFailure struct {
	TxHash  [32]byte
	Payment *big.Int
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterExecutionFailure is a free log retrieval operation binding the contract event 0x23428b18acfb3ea64b08dc0c1d296ea9c09702c09083ca5272e64d115b687d23.
//
// Solidity: event ExecutionFailure(bytes32 indexed txHash, uint256 payment)
func (_Safe *SafeFilterer) FilterExecutionFailure(opts *bind.FilterOpts, txHash [][32]byte) (*SafeExecutionFailureIterator, error) {

	var txHashRule []interface{}
	for _, txHashItem := range txHash {
		txHashRule = append(txHashRule, txHashItem)
	}

	logs, sub, err := _Safe.contract.FilterLogs(opts, "ExecutionFailure", txHashRule)
	if err != nil {
		return nil, err
	}
	return &SafeExecutionFailureIterator{contract: _Safe.contract, event: "ExecutionFailure", logs: logs, sub: sub}, nil
}

// WatchExecutionFailure is a free log subscription operation binding the contract event 0x23428b18acfb3ea64b08dc0c1d296ea9c09702c09083ca5272e64d115b687d23.
//
// Solidity: event ExecutionFailure(bytes32 indexed txHash, uint256 payment)
func (_Safe *SafeFilterer) WatchExecutionFailure(opts *bind.WatchOpts, sink chan<- *SafeExecutionFailure, txHash [][32]byte) (event.Subscription, error) {

	var txHashRule []interface{}
	for _, txHashItem := range txHash {
		txHashRule = append(txHashRule, txHashItem)
	}

	logs, sub, err := _Safe.contract.WatchLogs(opts, "ExecutionFailure", txHashRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(SafeExecutionFailure)
				if err := _Safe.contract.UnpackLog(event, "ExecutionFailure", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseExecutionFailure is a log parse operation binding the contract event 0x23428b18acfb3ea64b08dc0c1d296ea9c09702c09083ca5272e64d115b687d23.
//
// Solidity: event ExecutionFailure(bytes32 indexed txHash, uint256 payment)
func (_Safe *SafeFilterer) ParseExecutionFailure(log types.Log) (*SafeExecutionFailure, error) {
	event := new(SafeExecutionFailure)
	if err := _Safe.contract.UnpackLog(event, "ExecutionFailure", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// SafeExecutionFromModuleFailureIterator is returned from FilterExecutionFromModuleFailure and is used to iterate over the raw logs and unpacked data for ExecutionFromModuleFailure events raised by the Safe contract.
type SafeExecutionFromModuleFailureIterator struct {
	Event *SafeExecutionFromModuleFailure // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *SafeExecutionFromModuleFailureIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(SafeExecutionFromModuleFailure)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(SafeExecutionFromModuleFailure)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *SafeExecutionFromModuleFailureIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *SafeExecutionFromModuleFailureIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// SafeExecutionFromModuleFailure represents a ExecutionFromModuleFailure event raised by the Safe contract.
type SafeExecutionFromModuleFailure struct {
	Module common.Address
	Raw    types.Log // Blockchain specific contextual infos
}

// FilterExecutionFromModuleFailure is a free log retrieval operation binding the contract event 0xacd2c8702804128fdb0db2bb49f6d127dd0181c13fd45dbfe16de0930e2bd375.
//
// Solidity: event ExecutionFromModuleFailure(address indexed module)
func (_Safe *SafeFilterer) FilterExecutionFromModuleFailure(opts *bind.FilterOpts, module []common.Address) (*SafeExecutionFromModuleFailureIterator, error) {

	var moduleRule []interface{}
	for _, moduleItem := range module {
		moduleRule = append(moduleRule, moduleItem)
	}

	logs, sub, err := _Safe.contract.FilterLogs(opts, "ExecutionFromModuleFailure", moduleRule)
	if err != nil {
		return nil, err
	}
	return &SafeExecutionFromModuleFailureIterator{contract: _Safe.contract, event: "ExecutionFromModuleFailure", logs: logs, sub: sub}, nil
}

// WatchExecutionFromModuleFailure is a free log subscription operation binding the contract event 0xacd2c8702804128fdb0db2bb49f6d127dd0181c13fd45dbfe16de0930e2bd375.
//
// Solidity: event ExecutionFromModuleFailure(address indexed module)
func (_Safe *SafeFilterer) WatchExecutionFromModuleFailure(opts *bind.WatchOpts, sink chan<- *SafeExecutionFromModuleFailure, module []common.Address) (event.Subscription, error) {

	var moduleRule []interface{}
	for _, moduleItem := range module {
		moduleRule = append(moduleRule, moduleItem)
	}

	logs, sub, err := _Safe.contract.WatchLogs(opts, "ExecutionFromModuleFailure", moduleRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(SafeExecutionFromModuleFailure)
				if err := _Safe.contract.UnpackLog(event, "ExecutionFromModuleFailure", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseExecutionFromModuleFailure is a log parse operation binding the contract event 0xacd2c8702804128fdb0db2bb49f6d127dd0181c13fd45dbfe16de0930e2bd375.
//
// Solidity: event ExecutionFromModuleFailure(address indexed module)
func (_Safe *SafeFilterer) ParseExecutionFromModuleFailure(log types.Log) (*SafeExecutionFromModuleFailure, error) {
	event := new(SafeExecutionFromModuleFailure)
	if err := _Safe.contract.UnpackLog(event, "ExecutionFromModuleFailure", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// SafeExecutionFromModuleSuccessIterator is returned from FilterExecutionFromModuleSuccess and is used to iterate over the raw logs and unpacked data for ExecutionFromModuleSuccess events raised by the Safe contract.
type SafeExecutionFromModuleSuccessIterator struct {
	Event *SafeExecutionFromModuleSuccess // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *SafeExecutionFromModuleSuccessIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(SafeExecutionFromModuleSuccess)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(SafeExecutionFromModuleSuccess)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *SafeExecutionFromModuleSuccessIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *SafeExecutionFromModuleSuccessIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// SafeExecutionFromModuleSuccess represents a ExecutionFromModuleSuccess event raised by the Safe contract.
type SafeExecutionFromModuleSuccess struct {
	Module common.Address
	Raw    types.Log // Blockchain specific contextual infos
}

// FilterExecutionFromModuleSuccess is a free log retrieval operation binding the contract event 0x6895c13664aa4f67288b25d7a21d7aaa34916e355fb9b6fae0a139a9085becb8.
//
// Solidity: event ExecutionFromModuleSuccess(address indexed module)
func (_Safe *SafeFilterer) FilterExecutionFromModuleSuccess(opts *bind.FilterOpts, module []common.Address) (*SafeExecutionFromModuleSuccessIterator, error) {

	var moduleRule []interface{}
	for _, moduleItem := range module {
		moduleRule = append(moduleRule, moduleItem)
	}

	logs, sub, err := _Safe.contract.FilterLogs(opts, "ExecutionFromModuleSuccess", moduleRule)
	if err != nil {
		return nil, err
	}
	return &SafeExecutionFromModuleSuccessIterator{contract: _Safe.contract, event: "ExecutionFromModuleSuccess", logs: logs, sub: sub}, nil
}

// WatchExecutionFromModuleSuccess is a free log subscription operation binding the contract event 0x6895c13664aa4f67288b25d7a21d7aaa34916e355fb9b6fae0a139a9085becb8.
//
// Solidity: event ExecutionFromModuleSuccess(address indexed module)
func (_Safe *SafeFilterer) WatchExecutionFromModuleSuccess(opts *bind.WatchOpts, sink chan<- *SafeExecutionFromModuleSuccess, module []common.Address) (event.Subscription, error) {

	var moduleRule []interface{}
	for _, moduleItem := range module {
		moduleRule = append(moduleRule, moduleItem)
	}

	logs, sub, err := _Safe.contract.WatchLogs(opts, "ExecutionFromModuleSuccess", moduleRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(SafeExecutionFromModuleSuccess)
				if err := _Safe.contract.UnpackLog(event, "ExecutionFromModuleSuccess", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseExecutionFromModuleSuccess is a log parse operation binding the contract event 0x6895c13664aa4f67288b25d7a21d7aaa34916e355fb9b6fae0a139a9085becb8.
//
// Solidity: event ExecutionFromModuleSuccess(address indexed module)
func (_Safe *SafeFilterer) ParseExecutionFromModuleSuccess(log types.Log) (*SafeExecutionFromModuleSuccess, error) {
	event := new(SafeExecutionFromModuleSuccess)
	if err := _Safe.contract.UnpackLog(event, "ExecutionFromModuleSuccess", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// SafeExecutionSuccessIterator is returned from FilterExecutionSuccess and is used to iterate over the raw logs and unpacked data for ExecutionSuccess events raised by the Safe contract.
type SafeExecutionSuccessIterator struct {
	Event *SafeExecutionSuccess // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *SafeExecutionSuccessIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(SafeExecutionSuccess)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(SafeExecutionSuccess)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *SafeExecutionSuccessIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *SafeExecutionSuccessIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// SafeExecutionSuccess represents a ExecutionSuccess event raised by the Safe contract.
type SafeExecutionSuccess struct {
	TxHash  [32]byte
	Payment *big.Int
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterExecutionSuccess is a free log retrieval operation binding the contract event 0x442e715f626346e8c54381002da614f62bee8d27386535b2521ec8540898556e.
//
// Solidity: event ExecutionSuccess(bytes32 indexed txHash, uint256 payment)
func (_Safe *SafeFilterer) FilterExecutionSuccess(opts *bind.FilterOpts, txHash [][32]byte) (*SafeExecutionSuccessIterator, error) {

	var txHashRule []interface{}
	for _, txHashItem := range txHash {
		txHashRule = append(txHashRule, txHashItem)
	}

	logs, sub, err := _Safe.contract.FilterLogs(opts, "ExecutionSuccess", txHashRule)
	if err != nil {
		return nil, err
	}
	return &SafeExecutionSuccessIterator{contract: _Safe.contract, event: "ExecutionSuccess", logs: logs, sub: sub}, nil
}

// WatchExecutionSuccess is a free log subscription operation binding the contract event 0x442e715f626346e8c54381002da614f62bee8d27386535b2521ec8540898556e.
//
// Solidity: event ExecutionSuccess(bytes32 indexed txHash, uint256 payment)
func (_Safe *SafeFilterer) WatchExecutionSuccess(opts *bind.WatchOpts, sink chan<- *SafeExecutionSuccess, txHash [][32]byte) (event.Subscription, error) {

	var txHashRule []interface{}
	for _, txHashItem := range txHash {
		txHashRule = append(txHashRule, txHashItem)
	}

	logs, sub, err := _Safe.contract.WatchLogs(opts, "ExecutionSuccess", txHashRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(SafeExecutionSuccess)
				if err := _Safe.contract.UnpackLog(event, "ExecutionSuccess", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseExecutionSuccess is a log parse operation binding the contract event 0x442e715f626346e8c54381002da614f62bee8d27386535b2521ec8540898556e.
//
// Solidity: event ExecutionSuccess(bytes32 indexed txHash, uint256 payment)
func (_Safe *SafeFilterer) ParseExecutionSuccess(log types.Log) (*SafeExecutionSuccess, error) {
	event := new(SafeExecutionSuccess)
	if err := _Safe.contract.UnpackLog(event, "ExecutionSuccess", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// SafeRemovedOwnerIterator is returned from FilterRemovedOwner and is used to iterate over the raw logs and unpacked data for RemovedOwner events raised by the Safe contract.
type SafeRemovedOwnerIterator struct {
	Event *SafeRemovedOwner // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *SafeRemovedOwnerIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(SafeRemovedOwner)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(SafeRemovedOwner)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *SafeRemovedOwnerIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *SafeRemovedOwnerIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// SafeRemovedOwner represents a RemovedOwner event raised by the Safe contract.
type SafeRemovedOwner struct {
	Owner common.Address
	Raw   types.Log // Blockchain specific contextual infos
}

// FilterRemovedOwner is a free log retrieval operation binding the contract event 0xf8d49fc529812e9a7c5c50e69c20f0dccc0db8fa95c98bc58cc9a4f1c1299eaf.
//
// Solidity: event RemovedOwner(address indexed owner)
func (_Safe *SafeFilterer) FilterRemovedOwner(opts *bind.FilterOpts, owner []common.Address) (*SafeRemovedOwnerIterator, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}

	logs, sub, err := _Safe.contract.FilterLogs(opts, "RemovedOwner", ownerRule)
	if err != nil {
		return nil, err
	}
	return &SafeRemovedOwnerIterator{contract: _Safe.contract, event: "RemovedOwner", logs: logs, sub: sub}, nil
}

// WatchRemovedOwner is a free log subscription operation binding the contract event 0xf8d49fc529812e9a7c5c50e69c20f0dccc0db8fa95c98bc58cc9a4f1c1299eaf.
//
// Solidity: event RemovedOwner(address indexed owner)
func (_Safe *SafeFilterer) WatchRemovedOwner(opts *bind.WatchOpts, sink chan<- *SafeRemovedOwner, owner []common.Address) (event.Subscription, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}

	logs, sub, err := _Safe.contract.WatchLogs(opts, "RemovedOwner", ownerRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(SafeRemovedOwner)
				if err := _Safe.contract.UnpackLog(event, "RemovedOwner", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRemovedOwner is a log parse operation binding the contract event 0xf8d49fc529812e9a7c5c50e69c20f0dccc0db8fa95c98bc58cc9a4f1c1299eaf.
//
// Solidity: event RemovedOwner(address indexed owner)
func (_Safe *SafeFilterer) ParseRemovedOwner(log types.Log) (*SafeRemovedOwner, error) {
	event := new(SafeRemovedOwner)
	if err := _Safe.contract.UnpackLog(event, "RemovedOwner", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// SafeSafeReceivedIterator is returned from FilterSafeReceived and is used to iterate over the raw logs and unpacked data for SafeReceived events raised by the Safe contract.
type SafeSafeReceivedIterator struct {
	Event *SafeSafeReceived // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *SafeSafeReceivedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(SafeSafeReceived)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(SafeSafeReceived)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *SafeSafeReceivedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *SafeSafeReceivedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// SafeSafeReceived represents a SafeReceived event raised by the Safe contract.
type SafeSafeReceived struct {
	Sender common.Address
	Value  *big.Int
	Raw    types.Log // Blockchain specific contextual infos
}

// FilterSafeReceived is a free log retrieval operation binding the contract event 0x3d0ce9bfc3ed7d6862dbb28b2dea94561fe714a1b4d019aa8af39730d1ad7c3d.
//
// Solidity: event SafeReceived(address indexed sender, uint256 value)
func (_Safe *SafeFilterer) FilterSafeReceived(opts *bind.FilterOpts, sender []common.Address) (*SafeSafeReceivedIterator, error) {

	var senderRule []interface{}
	for _, senderItem := range sender {
		senderRule = append(senderRule, senderItem)
	}

	logs, sub, err := _Safe.contract.FilterLogs(opts, "SafeReceived", senderRule)
	if err != nil {
		return nil, err
	}
	return &SafeSafeReceivedIterator{contract: _Safe.contract, event: "SafeReceived", logs: logs, sub: sub}, nil
}

// WatchSafeReceived is a free log subscription operation binding the contract event 0x3d0ce9bfc3ed7d6862dbb28b2dea94561fe714a1b4d019aa8af39730d1ad7c3d.
//
// Solidity: event SafeReceived(address indexed sender, uint256 value)
func (_Safe *SafeFilterer) WatchSafeReceived(opts *bind.WatchOpts, sink chan<- *SafeSafeReceived, sender []common.Address) (event.Subscription, error) {

	var senderRule []interface{}
	for _, senderItem := range sender {
		senderRule = append(senderRule, senderItem)
	}

	logs, sub, err := _Safe.contract.WatchLogs(opts, "SafeReceived", senderRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(SafeSafeReceived)
				if err := _Safe.contract.UnpackLog(event, "SafeReceived", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseSafeReceived is a log parse operation binding the contract event 0x3d0ce9bfc3ed7d6862dbb28b2dea94561fe714a1b4d019aa8af39730d1ad7c3d.
//
// Solidity: event SafeReceived(address indexed sender, uint256 value)
func (_Safe *SafeFilterer) ParseSafeReceived(log types.Log) (*SafeSafeReceived, error) {
	event := new(SafeSafeReceived)
	if err := _Safe.contract.UnpackLog(event, "SafeReceived", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// SafeSafeSetupIterator is returned from FilterSafeSetup and is used to iterate over the raw logs and unpacked data for SafeSetup events raised by the Safe contract.
type SafeSafeSetupIterator struct {
	Event *SafeSafeSetup // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *SafeSafeSetupIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(SafeSafeSetup)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(SafeSafeSetup)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *SafeSafeSetupIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *SafeSafeSetupIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// SafeSafeSetup represents a SafeSetup event raised by the Safe contract.
type SafeSafeSetup struct {
	Initiator       common.Address
	Owners          []common.Address
	Threshold       *big.Int
	Initializer     common.Address
	FallbackHandler common.Address
	Raw             types.Log // Blockchain specific contextual infos
}

// FilterSafeSetup is a free log retrieval operation binding the contract event 0x141df868a6331af528e38c83b7aa03edc19be66e37ae67f9285bf4f8e3c6a1a8.
//
// Solidity: event SafeSetup(address indexed initiator, address[] owners, uint256 threshold, address initializer, address fallbackHandler)
func (_Safe *SafeFilterer) FilterSafeSetup(opts *bind.FilterOpts, initiator []common.Address) (*SafeSafeSetupIterator, error) {

	var initiatorRule []interface{}
	for _, initiatorItem := range initiator {
		initiatorRule = append(initiatorRule, initiatorItem)
	}

	logs, sub, err := _Safe.contract.FilterLogs(opts, "SafeSetup", initiatorRule)
	if err != nil {
		return nil, err
	}
	return &SafeSafeSetupIterator{contract: _Safe.contract, event: "SafeSetup", logs: logs, sub: sub}, nil
}

// WatchSafeSetup is a free log subscription operation binding the contract event 0x141df868a6331af528e38c83b7aa03edc19be66e37ae67f9285bf4f8e3c6a1a8.
//
// Solidity: event SafeSetup(address indexed initiator, address[] owners, uint256 threshold, address initializer, address fallbackHandler)
func (_Safe *SafeFilterer) WatchSafeSetup(opts *bind.WatchOpts, sink chan<- *SafeSafeSetup, initiator []common.Address) (event.Subscription, error) {

	var initiatorRule []interface{}
	for _, initiatorItem := range initiator {
		initiatorRule = append(initiatorRule, initiatorItem)
	}

	logs, sub, err := _Safe.contract.WatchLogs(opts, "SafeSetup", initiatorRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(SafeSafeSetup)
				if err := _Safe.contract.UnpackLog(event, "SafeSetup", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseSafeSetup is a log parse operation binding the contract event 0x141df868a6331af528e38c83b7aa03edc19be66e37ae67f9285bf4f8e3c6a1a8.
//
// Solidity: event SafeSetup(address indexed initiator, address[] owners, uint256 threshold, address initializer, address fallbackHandler)
func (_Safe *SafeFilterer) ParseSafeSetup(log types.Log) (*SafeSafeSetup, error) {
	event := new(SafeSafeSetup)
	if err := _Safe.contract.UnpackLog(event, "SafeSetup", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// SafeSignMsgIterator is returned from FilterSignMsg and is used to iterate over the raw logs and unpacked data for SignMsg events raised by the Safe contract.
type SafeSignMsgIterator struct {
	Event *SafeSignMsg // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *SafeSignMsgIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(SafeSignMsg)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(SafeSignMsg)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *SafeSignMsgIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *SafeSignMsgIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// SafeSignMsg represents a SignMsg event raised by the Safe contract.
type SafeSignMsg struct {
	MsgHash [32]byte
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterSignMsg is a free log retrieval operation binding the contract event 0xe7f4675038f4f6034dfcbbb24c4dc08e4ebf10eb9d257d3d02c0f38d122ac6e4.
//
// Solidity: event SignMsg(bytes32 indexed msgHash)
func (_Safe *SafeFilterer) FilterSignMsg(opts *bind.FilterOpts, msgHash [][32]byte) (*SafeSignMsgIterator, error) {

	var msgHashRule []interface{}
	for _, msgHashItem := range msgHash {
		msgHashRule = append(msgHashRule, msgHashItem)
	}

	logs, sub, err := _Safe.contract.FilterLogs(opts, "SignMsg", msgHashRule)
	if err != nil {
		return nil, err
	}
	return &SafeSignMsgIterator{contract: _Safe.contract, event: "SignMsg", logs: logs, sub: sub}, nil
}

// WatchSignMsg is a free log subscription operation binding the contract event 0xe7f4675038f4f6034dfcbbb24c4dc08e4ebf10eb9d257d3d02c0f38d122ac6e4.
//
// Solidity: event SignMsg(bytes32 indexed msgHash)
func (_Safe *SafeFilterer) WatchSignMsg(opts *bind.WatchOpts, sink chan<- *SafeSignMsg, msgHash [][32]byte) (event.Subscription, error) {

	var msgHashRule []interface{}
	for _, msgHashItem := range msgHash {
		msgHashRule = append(msgHashRule, msgHashItem)
	}

	logs, sub, err := _Safe.contract.WatchLogs(opts, "SignMsg", msgHashRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(SafeSignMsg)
				if err := _Safe.contract.UnpackLog(event, "SignMsg", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseSignMsg is a log parse operation binding the contract event 0xe7f4675038f4f6034dfcbbb24c4dc08e4ebf10eb9d257d3d02c0f38d122ac6e4.
//
// Solidity: event SignMsg(bytes32 indexed msgHash)
func (_Safe *SafeFilterer) ParseSignMsg(log types.Log) (*SafeSignMsg, error) {
	event := new(SafeSignMsg)
	if err := _Safe.contract.UnpackLog(event, "SignMsg", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

func CreateSafeDeploymentCommand() *cobra.Command {
	var keyfile, nonce, password, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas, rpc string
	var gasLimit uint64
	var simulate bool
	var timeout uint
	var safeAddress, safeApi, safeCreateCall, safeSaltRaw string
	var safeOperationType uint8
	var salt [32]byte

	cmd := &cobra.Command{
		Use:   "deploy",
		Short: "Deploy a new Safe contract",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if keyfile == "" {
				return fmt.Errorf("--keystore not specified (this should be a path to an Ethereum account keystore file)")
			}

			if rpc == "" {
				return fmt.Errorf("--rpc not specified (this should be a URL to an Ethereum JSONRPC API)")
			}

			if safeAddress != "" {
				if !common.IsHexAddress(safeAddress) {
					return fmt.Errorf("--safe is not a valid Ethereum address")
				}
				if safeApi == "" {
					client, clientErr := NewClient(rpc)
					if clientErr != nil {
						return clientErr
					}
					chainIDCtx, cancelChainIDCtx := NewChainContext(timeout)
					defer cancelChainIDCtx()
					chainID, chainIDErr := client.ChainID(chainIDCtx)
					if chainIDErr != nil {
						return chainIDErr
					}
					safeApi = fmt.Sprintf("https://safe-client.safe.global/v1/chains/%s/transactions/%s/propose", chainID.String(), safeAddress)
					fmt.Println("--safe-api not specified, using default (", safeApi, ")")
				}

				if safeCreateCall == "" {
					fmt.Println("--safe-create-call not specified, using default (0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4)")
					safeCreateCall = "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4"
				}
				if !common.IsHexAddress(safeCreateCall) {
					return fmt.Errorf("--safe-create-call is not a valid Ethereum address")
				}

				if SafeOperationType(safeOperationType).String() == "Unknown" {
					return fmt.Errorf("--safe-operation must be 0 (Call) or 1 (DelegateCall)")
				}

				if safeSaltRaw == "" {
					fmt.Println("--safe-salt not specified, generating random salt")
					_, err := rand.Read(salt[:])
					if err != nil {
						return fmt.Errorf("failed to generate random salt: %v", err)
					}
					// prompt user to accept random salt
					fmt.Println("Generated salt:", common.Bytes2Hex(salt[:]))
					fmt.Println("Please check the salt and confirm (y/n)")
					var confirm string
					fmt.Scanln(&confirm)
					if confirm != "y" && confirm != "Y" && confirm != "\n" && confirm != "" {
						return fmt.Errorf("salt not accepted, please specify a valid salt")
					}
				} else {
					copy(salt[:], safeSaltRaw)
				}
			}

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			client, clientErr := NewClient(rpc)
			if clientErr != nil {
				return clientErr
			}

			key, keyErr := KeyFromFile(keyfile, password)
			if keyErr != nil {
				return keyErr
			}

			chainIDCtx, cancelChainIDCtx := NewChainContext(timeout)
			defer cancelChainIDCtx()
			chainID, chainIDErr := client.ChainID(chainIDCtx)
			if chainIDErr != nil {
				return chainIDErr
			}

			transactionOpts, transactionOptsErr := bind.NewKeyedTransactorWithChainID(key.PrivateKey, chainID)
			if transactionOptsErr != nil {
				return transactionOptsErr
			}

			SetTransactionParametersFromArgs(transactionOpts, nonce, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas, gasLimit, simulate)

			if safeAddress != "" {
				// Generate deploy bytecode with constructor arguments
				deployBytecode, err := generateSafeDeployBytecode()
				if err != nil {
					return fmt.Errorf("failed to generate deploy bytecode: %v", err)
				}

				// Create Safe proposal for deployment
				value := transactionOpts.Value
				if value == nil {
					value = big.NewInt(0)
				}

				err = DeployWithSafe(client, key, common.HexToAddress(safeAddress), common.HexToAddress(safeCreateCall), value, safeApi, deployBytecode, SafeOperationType(safeOperationType), salt)
				if err != nil {
					return fmt.Errorf("failed to create Safe proposal: %v", err)
				}

				return nil
			}

			address, deploymentTransaction, _, deploymentErr := DeploySafe(
				transactionOpts,
				client,
			)
			if deploymentErr != nil {
				return deploymentErr
			}

			cmd.Printf("Transaction hash: %s\nContract address: %s\n", deploymentTransaction.Hash().Hex(), address.Hex())
			if transactionOpts.NoSend {
				estimationMessage := ethereum.CallMsg{
					From: transactionOpts.From,
					Data: deploymentTransaction.Data(),
				}

				gasEstimationCtx, cancelGasEstimationCtx := NewChainContext(timeout)
				defer cancelGasEstimationCtx()

				gasEstimate, gasEstimateErr := client.EstimateGas(gasEstimationCtx, estimationMessage)
				if gasEstimateErr != nil {
					return gasEstimateErr
				}

				transactionBinary, transactionBinaryErr := deploymentTransaction.MarshalBinary()
				if transactionBinaryErr != nil {
					return transactionBinaryErr
				}
				transactionBinaryHex := hex.EncodeToString(transactionBinary)

				cmd.Printf("Transaction: %s\nEstimated gas: %d\n", transactionBinaryHex, gasEstimate)
			} else {
				cmd.Println("Transaction submitted")
			}

			return nil
		},
	}

	cmd.Flags().StringVar(&rpc, "rpc", "", "URL of the JSONRPC API to use")
	cmd.Flags().StringVar(&keyfile, "keyfile", "", "Path to the keystore file to use for the transaction")
	cmd.Flags().StringVar(&password, "password", "", "Password to use to unlock the keystore (if not specified, you will be prompted for the password when the command executes)")
	cmd.Flags().StringVar(&nonce, "nonce", "", "Nonce to use for the transaction")
	cmd.Flags().StringVar(&value, "value", "", "Value to send with the transaction")
	cmd.Flags().StringVar(&gasPrice, "gas-price", "", "Gas price to use for the transaction")
	cmd.Flags().StringVar(&maxFeePerGas, "max-fee-per-gas", "", "Maximum fee per gas to use for the (EIP-1559) transaction")
	cmd.Flags().StringVar(&maxPriorityFeePerGas, "max-priority-fee-per-gas", "", "Maximum priority fee per gas to use for the (EIP-1559) transaction")
	cmd.Flags().Uint64Var(&gasLimit, "gas-limit", 0, "Gas limit for the transaction")
	cmd.Flags().BoolVar(&simulate, "simulate", false, "Simulate the transaction without sending it")
	cmd.Flags().UintVar(&timeout, "timeout", 60, "Timeout (in seconds) for interactions with the JSONRPC API")
	cmd.Flags().StringVar(&safeAddress, "safe", "", "Address of the Safe contract")
	cmd.Flags().StringVar(&safeApi, "safe-api", "", "Safe API for the Safe Transaction Service (optional)")
	cmd.Flags().StringVar(&safeCreateCall, "safe-create-call", "", "Address of the CreateCall contract (optional)")
	cmd.Flags().Uint8Var(&safeOperationType, "safe-operation", 1, "Safe operation type: 0 (Call) or 1 (DelegateCall) - default is 1")
	cmd.Flags().StringVar(&safeSaltRaw, "safe-salt", "", "Salt to use for the Safe transaction")

	return cmd
}

func generateSafeDeployBytecode() ([]byte, error) {
	abiPacked, err := SafeMetaData.GetAbi()
	if err != nil {
		return nil, fmt.Errorf("failed to get ABI: %v", err)
	}

	constructorArguments, err := abiPacked.Pack("")
	if err != nil {
		return nil, fmt.Errorf("failed to pack constructor arguments: %v", err)
	}

	deployBytecode := append(common.FromHex(SafeMetaData.Bin), constructorArguments...)
	return deployBytecode, nil
}

func CreateApprovedHashesCommand() *cobra.Command {
	var contractAddressRaw, rpc string
	var contractAddress common.Address
	var timeout uint

	var blockNumberRaw, fromAddressRaw string
	var pending bool

	var arg0 common.Address
	var arg0Raw string
	var arg1 [32]byte
	var arg1Raw string

	var capture0 *big.Int

	cmd := &cobra.Command{
		Use:   "approved-hashes",
		Short: "Call the ApprovedHashes view method on a Safe contract",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if contractAddressRaw == "" {
				return fmt.Errorf("--contract not specified")
			} else if !common.IsHexAddress(contractAddressRaw) {
				return fmt.Errorf("--contract is not a valid Ethereum address")
			}
			contractAddress = common.HexToAddress(contractAddressRaw)

			if arg0Raw == "" {
				return fmt.Errorf("--arg-0 argument not specified")
			} else if !common.IsHexAddress(arg0Raw) {
				return fmt.Errorf("--arg-0 argument is not a valid Ethereum address")
			}
			arg0 = common.HexToAddress(arg0Raw)

			var arg1Intermediate []byte

			var arg1IntermediateHexDecodeErr error
			arg1Intermediate, arg1IntermediateHexDecodeErr = hex.DecodeString(arg1Raw)
			if arg1IntermediateHexDecodeErr != nil {
				return arg1IntermediateHexDecodeErr
			}

			copy(arg1[:], arg1Intermediate)

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			client, clientErr := NewClient(rpc)
			if clientErr != nil {
				return clientErr
			}

			contract, contractErr := NewSafe(contractAddress, client)
			if contractErr != nil {
				return contractErr
			}

			callOpts := bind.CallOpts{}
			SetCallParametersFromArgs(&callOpts, pending, fromAddressRaw, blockNumberRaw)

			session := SafeCallerSession{
				Contract: &contract.SafeCaller,
				CallOpts: callOpts,
			}

			var callErr error
			capture0, callErr = session.ApprovedHashes(
				arg0,
				arg1,
			)
			if callErr != nil {
				return callErr
			}

			cmd.Printf("0: %s\n", capture0.String())

			return nil
		},
	}

	cmd.Flags().StringVar(&rpc, "rpc", "", "URL of the JSONRPC API to use")
	cmd.Flags().StringVar(&blockNumberRaw, "block", "", "Block number at which to call the view method")
	cmd.Flags().BoolVar(&pending, "pending", false, "Set this flag if it's ok to call the view method against pending state")
	cmd.Flags().UintVar(&timeout, "timeout", 60, "Timeout (in seconds) for interactions with the JSONRPC API")
	cmd.Flags().StringVar(&contractAddressRaw, "contract", "", "Address of the contract to interact with")
	cmd.Flags().StringVar(&fromAddressRaw, "from", "", "Optional address for caller of the view method")

	cmd.Flags().StringVar(&arg0Raw, "arg-0", "", "arg-0 argument (common.Address)")
	cmd.Flags().StringVar(&arg1Raw, "arg-1", "", "arg-1 argument ([32]byte)")

	return cmd
}
func CreateCheckNsignaturesCommand() *cobra.Command {
	var contractAddressRaw, rpc string
	var contractAddress common.Address
	var timeout uint

	var blockNumberRaw, fromAddressRaw string
	var pending bool

	var dataHash [32]byte
	var dataHashRaw string
	var data []byte
	var dataRaw string
	var signatures []byte
	var signaturesRaw string
	var requiredSignatures *big.Int
	var requiredSignaturesRaw string

	cmd := &cobra.Command{
		Use:   "check-n-signatures",
		Short: "Call the CheckNSignatures view method on a Safe contract",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if contractAddressRaw == "" {
				return fmt.Errorf("--contract not specified")
			} else if !common.IsHexAddress(contractAddressRaw) {
				return fmt.Errorf("--contract is not a valid Ethereum address")
			}
			contractAddress = common.HexToAddress(contractAddressRaw)

			var dataHashIntermediate []byte

			var dataHashIntermediateHexDecodeErr error
			dataHashIntermediate, dataHashIntermediateHexDecodeErr = hex.DecodeString(dataHashRaw)
			if dataHashIntermediateHexDecodeErr != nil {
				return dataHashIntermediateHexDecodeErr
			}

			copy(dataHash[:], dataHashIntermediate)

			var dataIntermediate []byte

			var dataIntermediateHexDecodeErr error
			dataIntermediate, dataIntermediateHexDecodeErr = hex.DecodeString(dataRaw)
			if dataIntermediateHexDecodeErr != nil {
				return dataIntermediateHexDecodeErr
			}

			copy(data[:], dataIntermediate)

			var signaturesIntermediate []byte

			var signaturesIntermediateHexDecodeErr error
			signaturesIntermediate, signaturesIntermediateHexDecodeErr = hex.DecodeString(signaturesRaw)
			if signaturesIntermediateHexDecodeErr != nil {
				return signaturesIntermediateHexDecodeErr
			}

			copy(signatures[:], signaturesIntermediate)

			if requiredSignaturesRaw == "" {
				return fmt.Errorf("--required-signatures argument not specified")
			}
			requiredSignatures = new(big.Int)
			requiredSignatures.SetString(requiredSignaturesRaw, 0)

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			client, clientErr := NewClient(rpc)
			if clientErr != nil {
				return clientErr
			}

			contract, contractErr := NewSafe(contractAddress, client)
			if contractErr != nil {
				return contractErr
			}

			callOpts := bind.CallOpts{}
			SetCallParametersFromArgs(&callOpts, pending, fromAddressRaw, blockNumberRaw)

			session := SafeCallerSession{
				Contract: &contract.SafeCaller,
				CallOpts: callOpts,
			}

			var callErr error
			callErr = session.CheckNSignatures(
				dataHash,
				data,
				signatures,
				requiredSignatures,
			)
			if callErr != nil {
				return callErr
			}

			return nil
		},
	}

	cmd.Flags().StringVar(&rpc, "rpc", "", "URL of the JSONRPC API to use")
	cmd.Flags().StringVar(&blockNumberRaw, "block", "", "Block number at which to call the view method")
	cmd.Flags().BoolVar(&pending, "pending", false, "Set this flag if it's ok to call the view method against pending state")
	cmd.Flags().UintVar(&timeout, "timeout", 60, "Timeout (in seconds) for interactions with the JSONRPC API")
	cmd.Flags().StringVar(&contractAddressRaw, "contract", "", "Address of the contract to interact with")
	cmd.Flags().StringVar(&fromAddressRaw, "from", "", "Optional address for caller of the view method")

	cmd.Flags().StringVar(&dataHashRaw, "data-hash", "", "data-hash argument ([32]byte)")
	cmd.Flags().StringVar(&dataRaw, "data", "", "data argument ([]byte)")
	cmd.Flags().StringVar(&signaturesRaw, "signatures", "", "signatures argument ([]byte)")
	cmd.Flags().StringVar(&requiredSignaturesRaw, "required-signatures", "", "required-signatures argument")

	return cmd
}
func CreateCheckNsignatures0Command() *cobra.Command {
	var contractAddressRaw, rpc string
	var contractAddress common.Address
	var timeout uint

	var blockNumberRaw, fromAddressRaw string
	var pending bool

	var executor common.Address
	var executorRaw string
	var dataHash [32]byte
	var dataHashRaw string
	var signatures []byte
	var signaturesRaw string
	var requiredSignatures *big.Int
	var requiredSignaturesRaw string

	cmd := &cobra.Command{
		Use:   "check-n-signatures-0",
		Short: "Call the CheckNSignatures0 view method on a Safe contract",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if contractAddressRaw == "" {
				return fmt.Errorf("--contract not specified")
			} else if !common.IsHexAddress(contractAddressRaw) {
				return fmt.Errorf("--contract is not a valid Ethereum address")
			}
			contractAddress = common.HexToAddress(contractAddressRaw)

			if executorRaw == "" {
				return fmt.Errorf("--executor argument not specified")
			} else if !common.IsHexAddress(executorRaw) {
				return fmt.Errorf("--executor argument is not a valid Ethereum address")
			}
			executor = common.HexToAddress(executorRaw)

			var dataHashIntermediate []byte

			var dataHashIntermediateHexDecodeErr error
			dataHashIntermediate, dataHashIntermediateHexDecodeErr = hex.DecodeString(dataHashRaw)
			if dataHashIntermediateHexDecodeErr != nil {
				return dataHashIntermediateHexDecodeErr
			}

			copy(dataHash[:], dataHashIntermediate)

			var signaturesIntermediate []byte

			var signaturesIntermediateHexDecodeErr error
			signaturesIntermediate, signaturesIntermediateHexDecodeErr = hex.DecodeString(signaturesRaw)
			if signaturesIntermediateHexDecodeErr != nil {
				return signaturesIntermediateHexDecodeErr
			}

			copy(signatures[:], signaturesIntermediate)

			if requiredSignaturesRaw == "" {
				return fmt.Errorf("--required-signatures argument not specified")
			}
			requiredSignatures = new(big.Int)
			requiredSignatures.SetString(requiredSignaturesRaw, 0)

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			client, clientErr := NewClient(rpc)
			if clientErr != nil {
				return clientErr
			}

			contract, contractErr := NewSafe(contractAddress, client)
			if contractErr != nil {
				return contractErr
			}

			callOpts := bind.CallOpts{}
			SetCallParametersFromArgs(&callOpts, pending, fromAddressRaw, blockNumberRaw)

			session := SafeCallerSession{
				Contract: &contract.SafeCaller,
				CallOpts: callOpts,
			}

			var callErr error
			callErr = session.CheckNSignatures0(
				executor,
				dataHash,
				signatures,
				requiredSignatures,
			)
			if callErr != nil {
				return callErr
			}

			return nil
		},
	}

	cmd.Flags().StringVar(&rpc, "rpc", "", "URL of the JSONRPC API to use")
	cmd.Flags().StringVar(&blockNumberRaw, "block", "", "Block number at which to call the view method")
	cmd.Flags().BoolVar(&pending, "pending", false, "Set this flag if it's ok to call the view method against pending state")
	cmd.Flags().UintVar(&timeout, "timeout", 60, "Timeout (in seconds) for interactions with the JSONRPC API")
	cmd.Flags().StringVar(&contractAddressRaw, "contract", "", "Address of the contract to interact with")
	cmd.Flags().StringVar(&fromAddressRaw, "from", "", "Optional address for caller of the view method")

	cmd.Flags().StringVar(&executorRaw, "executor", "", "executor argument (common.Address)")
	cmd.Flags().StringVar(&dataHashRaw, "data-hash", "", "data-hash argument ([32]byte)")
	cmd.Flags().StringVar(&signaturesRaw, "signatures", "", "signatures argument ([]byte)")
	cmd.Flags().StringVar(&requiredSignaturesRaw, "required-signatures", "", "required-signatures argument")

	return cmd
}
func CreateCheckSignaturesCommand() *cobra.Command {
	var contractAddressRaw, rpc string
	var contractAddress common.Address
	var timeout uint

	var blockNumberRaw, fromAddressRaw string
	var pending bool

	var dataHash [32]byte
	var dataHashRaw string
	var data []byte
	var dataRaw string
	var signatures []byte
	var signaturesRaw string

	cmd := &cobra.Command{
		Use:   "check-signatures",
		Short: "Call the CheckSignatures view method on a Safe contract",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if contractAddressRaw == "" {
				return fmt.Errorf("--contract not specified")
			} else if !common.IsHexAddress(contractAddressRaw) {
				return fmt.Errorf("--contract is not a valid Ethereum address")
			}
			contractAddress = common.HexToAddress(contractAddressRaw)

			var dataHashIntermediate []byte

			var dataHashIntermediateHexDecodeErr error
			dataHashIntermediate, dataHashIntermediateHexDecodeErr = hex.DecodeString(dataHashRaw)
			if dataHashIntermediateHexDecodeErr != nil {
				return dataHashIntermediateHexDecodeErr
			}

			copy(dataHash[:], dataHashIntermediate)

			var dataIntermediate []byte

			var dataIntermediateHexDecodeErr error
			dataIntermediate, dataIntermediateHexDecodeErr = hex.DecodeString(dataRaw)
			if dataIntermediateHexDecodeErr != nil {
				return dataIntermediateHexDecodeErr
			}

			copy(data[:], dataIntermediate)

			var signaturesIntermediate []byte

			var signaturesIntermediateHexDecodeErr error
			signaturesIntermediate, signaturesIntermediateHexDecodeErr = hex.DecodeString(signaturesRaw)
			if signaturesIntermediateHexDecodeErr != nil {
				return signaturesIntermediateHexDecodeErr
			}

			copy(signatures[:], signaturesIntermediate)

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			client, clientErr := NewClient(rpc)
			if clientErr != nil {
				return clientErr
			}

			contract, contractErr := NewSafe(contractAddress, client)
			if contractErr != nil {
				return contractErr
			}

			callOpts := bind.CallOpts{}
			SetCallParametersFromArgs(&callOpts, pending, fromAddressRaw, blockNumberRaw)

			session := SafeCallerSession{
				Contract: &contract.SafeCaller,
				CallOpts: callOpts,
			}

			var callErr error
			callErr = session.CheckSignatures(
				dataHash,
				data,
				signatures,
			)
			if callErr != nil {
				return callErr
			}

			return nil
		},
	}

	cmd.Flags().StringVar(&rpc, "rpc", "", "URL of the JSONRPC API to use")
	cmd.Flags().StringVar(&blockNumberRaw, "block", "", "Block number at which to call the view method")
	cmd.Flags().BoolVar(&pending, "pending", false, "Set this flag if it's ok to call the view method against pending state")
	cmd.Flags().UintVar(&timeout, "timeout", 60, "Timeout (in seconds) for interactions with the JSONRPC API")
	cmd.Flags().StringVar(&contractAddressRaw, "contract", "", "Address of the contract to interact with")
	cmd.Flags().StringVar(&fromAddressRaw, "from", "", "Optional address for caller of the view method")

	cmd.Flags().StringVar(&dataHashRaw, "data-hash", "", "data-hash argument ([32]byte)")
	cmd.Flags().StringVar(&dataRaw, "data", "", "data argument ([]byte)")
	cmd.Flags().StringVar(&signaturesRaw, "signatures", "", "signatures argument ([]byte)")

	return cmd
}
func CreateCheckSignatures0Command() *cobra.Command {
	var contractAddressRaw, rpc string
	var contractAddress common.Address
	var timeout uint

	var blockNumberRaw, fromAddressRaw string
	var pending bool

	var dataHash [32]byte
	var dataHashRaw string
	var signatures []byte
	var signaturesRaw string

	cmd := &cobra.Command{
		Use:   "check-signatures-0",
		Short: "Call the CheckSignatures0 view method on a Safe contract",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if contractAddressRaw == "" {
				return fmt.Errorf("--contract not specified")
			} else if !common.IsHexAddress(contractAddressRaw) {
				return fmt.Errorf("--contract is not a valid Ethereum address")
			}
			contractAddress = common.HexToAddress(contractAddressRaw)

			var dataHashIntermediate []byte

			var dataHashIntermediateHexDecodeErr error
			dataHashIntermediate, dataHashIntermediateHexDecodeErr = hex.DecodeString(dataHashRaw)
			if dataHashIntermediateHexDecodeErr != nil {
				return dataHashIntermediateHexDecodeErr
			}

			copy(dataHash[:], dataHashIntermediate)

			var signaturesIntermediate []byte

			var signaturesIntermediateHexDecodeErr error
			signaturesIntermediate, signaturesIntermediateHexDecodeErr = hex.DecodeString(signaturesRaw)
			if signaturesIntermediateHexDecodeErr != nil {
				return signaturesIntermediateHexDecodeErr
			}

			copy(signatures[:], signaturesIntermediate)

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			client, clientErr := NewClient(rpc)
			if clientErr != nil {
				return clientErr
			}

			contract, contractErr := NewSafe(contractAddress, client)
			if contractErr != nil {
				return contractErr
			}

			callOpts := bind.CallOpts{}
			SetCallParametersFromArgs(&callOpts, pending, fromAddressRaw, blockNumberRaw)

			session := SafeCallerSession{
				Contract: &contract.SafeCaller,
				CallOpts: callOpts,
			}

			var callErr error
			callErr = session.CheckSignatures0(
				dataHash,
				signatures,
			)
			if callErr != nil {
				return callErr
			}

			return nil
		},
	}

	cmd.Flags().StringVar(&rpc, "rpc", "", "URL of the JSONRPC API to use")
	cmd.Flags().StringVar(&blockNumberRaw, "block", "", "Block number at which to call the view method")
	cmd.Flags().BoolVar(&pending, "pending", false, "Set this flag if it's ok to call the view method against pending state")
	cmd.Flags().UintVar(&timeout, "timeout", 60, "Timeout (in seconds) for interactions with the JSONRPC API")
	cmd.Flags().StringVar(&contractAddressRaw, "contract", "", "Address of the contract to interact with")
	cmd.Flags().StringVar(&fromAddressRaw, "from", "", "Optional address for caller of the view method")

	cmd.Flags().StringVar(&dataHashRaw, "data-hash", "", "data-hash argument ([32]byte)")
	cmd.Flags().StringVar(&signaturesRaw, "signatures", "", "signatures argument ([]byte)")

	return cmd
}
func CreateDomainSeparatorCommand() *cobra.Command {
	var contractAddressRaw, rpc string
	var contractAddress common.Address
	var timeout uint

	var blockNumberRaw, fromAddressRaw string
	var pending bool

	var capture0 [32]byte

	cmd := &cobra.Command{
		Use:   "domain-separator",
		Short: "Call the DomainSeparator view method on a Safe contract",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if contractAddressRaw == "" {
				return fmt.Errorf("--contract not specified")
			} else if !common.IsHexAddress(contractAddressRaw) {
				return fmt.Errorf("--contract is not a valid Ethereum address")
			}
			contractAddress = common.HexToAddress(contractAddressRaw)

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			client, clientErr := NewClient(rpc)
			if clientErr != nil {
				return clientErr
			}

			contract, contractErr := NewSafe(contractAddress, client)
			if contractErr != nil {
				return contractErr
			}

			callOpts := bind.CallOpts{}
			SetCallParametersFromArgs(&callOpts, pending, fromAddressRaw, blockNumberRaw)

			session := SafeCallerSession{
				Contract: &contract.SafeCaller,
				CallOpts: callOpts,
			}

			var callErr error
			capture0, callErr = session.DomainSeparator()
			if callErr != nil {
				return callErr
			}

			cmd.Printf("0: %v\n", capture0)

			return nil
		},
	}

	cmd.Flags().StringVar(&rpc, "rpc", "", "URL of the JSONRPC API to use")
	cmd.Flags().StringVar(&blockNumberRaw, "block", "", "Block number at which to call the view method")
	cmd.Flags().BoolVar(&pending, "pending", false, "Set this flag if it's ok to call the view method against pending state")
	cmd.Flags().UintVar(&timeout, "timeout", 60, "Timeout (in seconds) for interactions with the JSONRPC API")
	cmd.Flags().StringVar(&contractAddressRaw, "contract", "", "Address of the contract to interact with")
	cmd.Flags().StringVar(&fromAddressRaw, "from", "", "Optional address for caller of the view method")

	return cmd
}
func CreateGetModulesPaginatedCommand() *cobra.Command {
	var contractAddressRaw, rpc string
	var contractAddress common.Address
	var timeout uint

	var blockNumberRaw, fromAddressRaw string
	var pending bool

	var start common.Address
	var startRaw string
	var pageSize *big.Int
	var pageSizeRaw string

	var capture0 struct {
		Array []common.Address
		Next  common.Address
	}

	cmd := &cobra.Command{
		Use:   "get-modules-paginated",
		Short: "Call the GetModulesPaginated view method on a Safe contract",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if contractAddressRaw == "" {
				return fmt.Errorf("--contract not specified")
			} else if !common.IsHexAddress(contractAddressRaw) {
				return fmt.Errorf("--contract is not a valid Ethereum address")
			}
			contractAddress = common.HexToAddress(contractAddressRaw)

			if startRaw == "" {
				return fmt.Errorf("--start argument not specified")
			} else if !common.IsHexAddress(startRaw) {
				return fmt.Errorf("--start argument is not a valid Ethereum address")
			}
			start = common.HexToAddress(startRaw)

			if pageSizeRaw == "" {
				return fmt.Errorf("--page-size argument not specified")
			}
			pageSize = new(big.Int)
			pageSize.SetString(pageSizeRaw, 0)

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			client, clientErr := NewClient(rpc)
			if clientErr != nil {
				return clientErr
			}

			contract, contractErr := NewSafe(contractAddress, client)
			if contractErr != nil {
				return contractErr
			}

			callOpts := bind.CallOpts{}
			SetCallParametersFromArgs(&callOpts, pending, fromAddressRaw, blockNumberRaw)

			session := SafeCallerSession{
				Contract: &contract.SafeCaller,
				CallOpts: callOpts,
			}

			var callErr error
			capture0, callErr = session.GetModulesPaginated(
				start,
				pageSize,
			)
			if callErr != nil {
				return callErr
			}

			cmd.Printf("0: %v\n", capture0)

			return nil
		},
	}

	cmd.Flags().StringVar(&rpc, "rpc", "", "URL of the JSONRPC API to use")
	cmd.Flags().StringVar(&blockNumberRaw, "block", "", "Block number at which to call the view method")
	cmd.Flags().BoolVar(&pending, "pending", false, "Set this flag if it's ok to call the view method against pending state")
	cmd.Flags().UintVar(&timeout, "timeout", 60, "Timeout (in seconds) for interactions with the JSONRPC API")
	cmd.Flags().StringVar(&contractAddressRaw, "contract", "", "Address of the contract to interact with")
	cmd.Flags().StringVar(&fromAddressRaw, "from", "", "Optional address for caller of the view method")

	cmd.Flags().StringVar(&startRaw, "start", "", "start argument (common.Address)")
	cmd.Flags().StringVar(&pageSizeRaw, "page-size", "", "page-size argument")

	return cmd
}
func CreateGetOwnersCommand() *cobra.Command {
	var contractAddressRaw, rpc string
	var contractAddress common.Address
	var timeout uint

	var blockNumberRaw, fromAddressRaw string
	var pending bool

	var capture0 []common.Address

	cmd := &cobra.Command{
		Use:   "get-owners",
		Short: "Call the GetOwners view method on a Safe contract",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if contractAddressRaw == "" {
				return fmt.Errorf("--contract not specified")
			} else if !common.IsHexAddress(contractAddressRaw) {
				return fmt.Errorf("--contract is not a valid Ethereum address")
			}
			contractAddress = common.HexToAddress(contractAddressRaw)

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			client, clientErr := NewClient(rpc)
			if clientErr != nil {
				return clientErr
			}

			contract, contractErr := NewSafe(contractAddress, client)
			if contractErr != nil {
				return contractErr
			}

			callOpts := bind.CallOpts{}
			SetCallParametersFromArgs(&callOpts, pending, fromAddressRaw, blockNumberRaw)

			session := SafeCallerSession{
				Contract: &contract.SafeCaller,
				CallOpts: callOpts,
			}

			var callErr error
			capture0, callErr = session.GetOwners()
			if callErr != nil {
				return callErr
			}

			cmd.Printf("0: %v\n", capture0)

			return nil
		},
	}

	cmd.Flags().StringVar(&rpc, "rpc", "", "URL of the JSONRPC API to use")
	cmd.Flags().StringVar(&blockNumberRaw, "block", "", "Block number at which to call the view method")
	cmd.Flags().BoolVar(&pending, "pending", false, "Set this flag if it's ok to call the view method against pending state")
	cmd.Flags().UintVar(&timeout, "timeout", 60, "Timeout (in seconds) for interactions with the JSONRPC API")
	cmd.Flags().StringVar(&contractAddressRaw, "contract", "", "Address of the contract to interact with")
	cmd.Flags().StringVar(&fromAddressRaw, "from", "", "Optional address for caller of the view method")

	return cmd
}
func CreateGetStorageAtCommand() *cobra.Command {
	var contractAddressRaw, rpc string
	var contractAddress common.Address
	var timeout uint

	var blockNumberRaw, fromAddressRaw string
	var pending bool

	var offset *big.Int
	var offsetRaw string
	var length *big.Int
	var lengthRaw string

	var capture0 []byte

	cmd := &cobra.Command{
		Use:   "get-storage-at",
		Short: "Call the GetStorageAt view method on a Safe contract",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if contractAddressRaw == "" {
				return fmt.Errorf("--contract not specified")
			} else if !common.IsHexAddress(contractAddressRaw) {
				return fmt.Errorf("--contract is not a valid Ethereum address")
			}
			contractAddress = common.HexToAddress(contractAddressRaw)

			if offsetRaw == "" {
				return fmt.Errorf("--offset argument not specified")
			}
			offset = new(big.Int)
			offset.SetString(offsetRaw, 0)

			if lengthRaw == "" {
				return fmt.Errorf("--length argument not specified")
			}
			length = new(big.Int)
			length.SetString(lengthRaw, 0)

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			client, clientErr := NewClient(rpc)
			if clientErr != nil {
				return clientErr
			}

			contract, contractErr := NewSafe(contractAddress, client)
			if contractErr != nil {
				return contractErr
			}

			callOpts := bind.CallOpts{}
			SetCallParametersFromArgs(&callOpts, pending, fromAddressRaw, blockNumberRaw)

			session := SafeCallerSession{
				Contract: &contract.SafeCaller,
				CallOpts: callOpts,
			}

			var callErr error
			capture0, callErr = session.GetStorageAt(
				offset,
				length,
			)
			if callErr != nil {
				return callErr
			}

			cmd.Printf("0: %v\n", capture0)

			return nil
		},
	}

	cmd.Flags().StringVar(&rpc, "rpc", "", "URL of the JSONRPC API to use")
	cmd.Flags().StringVar(&blockNumberRaw, "block", "", "Block number at which to call the view method")
	cmd.Flags().BoolVar(&pending, "pending", false, "Set this flag if it's ok to call the view method against pending state")
	cmd.Flags().UintVar(&timeout, "timeout", 60, "Timeout (in seconds) for interactions with the JSONRPC API")
	cmd.Flags().StringVar(&contractAddressRaw, "contract", "", "Address of the contract to interact with")
	cmd.Flags().StringVar(&fromAddressRaw, "from", "", "Optional address for caller of the view method")

	cmd.Flags().StringVar(&offsetRaw, "offset", "", "offset argument")
	cmd.Flags().StringVar(&lengthRaw, "length", "", "length argument")

	return cmd
}
func CreateGetThresholdCommand() *cobra.Command {
	var contractAddressRaw, rpc string
	var contractAddress common.Address
	var timeout uint

	var blockNumberRaw, fromAddressRaw string
	var pending bool

	var capture0 *big.Int

	cmd := &cobra.Command{
		Use:   "get-threshold",
		Short: "Call the GetThreshold view method on a Safe contract",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if contractAddressRaw == "" {
				return fmt.Errorf("--contract not specified")
			} else if !common.IsHexAddress(contractAddressRaw) {
				return fmt.Errorf("--contract is not a valid Ethereum address")
			}
			contractAddress = common.HexToAddress(contractAddressRaw)

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			client, clientErr := NewClient(rpc)
			if clientErr != nil {
				return clientErr
			}

			contract, contractErr := NewSafe(contractAddress, client)
			if contractErr != nil {
				return contractErr
			}

			callOpts := bind.CallOpts{}
			SetCallParametersFromArgs(&callOpts, pending, fromAddressRaw, blockNumberRaw)

			session := SafeCallerSession{
				Contract: &contract.SafeCaller,
				CallOpts: callOpts,
			}

			var callErr error
			capture0, callErr = session.GetThreshold()
			if callErr != nil {
				return callErr
			}

			cmd.Printf("0: %s\n", capture0.String())

			return nil
		},
	}

	cmd.Flags().StringVar(&rpc, "rpc", "", "URL of the JSONRPC API to use")
	cmd.Flags().StringVar(&blockNumberRaw, "block", "", "Block number at which to call the view method")
	cmd.Flags().BoolVar(&pending, "pending", false, "Set this flag if it's ok to call the view method against pending state")
	cmd.Flags().UintVar(&timeout, "timeout", 60, "Timeout (in seconds) for interactions with the JSONRPC API")
	cmd.Flags().StringVar(&contractAddressRaw, "contract", "", "Address of the contract to interact with")
	cmd.Flags().StringVar(&fromAddressRaw, "from", "", "Optional address for caller of the view method")

	return cmd
}
func CreateGetTransactionHashCommand() *cobra.Command {
	var contractAddressRaw, rpc string
	var contractAddress common.Address
	var timeout uint

	var blockNumberRaw, fromAddressRaw string
	var pending bool

	var to0 common.Address
	var to0Raw string
	var value0 *big.Int
	var value0Raw string
	var data []byte
	var dataRaw string
	var operation uint8

	var safeTxGas *big.Int
	var safeTxGasRaw string
	var baseGas *big.Int
	var baseGasRaw string
	var gasPrice0 *big.Int
	var gasPrice0Raw string
	var gasToken common.Address
	var gasTokenRaw string
	var refundReceiver common.Address
	var refundReceiverRaw string
	var _nonce0 *big.Int
	var _nonce0Raw string

	var capture0 [32]byte

	cmd := &cobra.Command{
		Use:   "get-transaction-hash",
		Short: "Call the GetTransactionHash view method on a Safe contract",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if contractAddressRaw == "" {
				return fmt.Errorf("--contract not specified")
			} else if !common.IsHexAddress(contractAddressRaw) {
				return fmt.Errorf("--contract is not a valid Ethereum address")
			}
			contractAddress = common.HexToAddress(contractAddressRaw)

			if to0Raw == "" {
				return fmt.Errorf("--to-0 argument not specified")
			} else if !common.IsHexAddress(to0Raw) {
				return fmt.Errorf("--to-0 argument is not a valid Ethereum address")
			}
			to0 = common.HexToAddress(to0Raw)

			if value0Raw == "" {
				return fmt.Errorf("--value-0 argument not specified")
			}
			value0 = new(big.Int)
			value0.SetString(value0Raw, 0)

			var dataIntermediate []byte

			var dataIntermediateHexDecodeErr error
			dataIntermediate, dataIntermediateHexDecodeErr = hex.DecodeString(dataRaw)
			if dataIntermediateHexDecodeErr != nil {
				return dataIntermediateHexDecodeErr
			}

			copy(data[:], dataIntermediate)

			if safeTxGasRaw == "" {
				return fmt.Errorf("--safe-tx-gas argument not specified")
			}
			safeTxGas = new(big.Int)
			safeTxGas.SetString(safeTxGasRaw, 0)

			if baseGasRaw == "" {
				return fmt.Errorf("--base-gas argument not specified")
			}
			baseGas = new(big.Int)
			baseGas.SetString(baseGasRaw, 0)

			if gasPrice0Raw == "" {
				return fmt.Errorf("--gas-price-0 argument not specified")
			}
			gasPrice0 = new(big.Int)
			gasPrice0.SetString(gasPrice0Raw, 0)

			if gasTokenRaw == "" {
				return fmt.Errorf("--gas-token argument not specified")
			} else if !common.IsHexAddress(gasTokenRaw) {
				return fmt.Errorf("--gas-token argument is not a valid Ethereum address")
			}
			gasToken = common.HexToAddress(gasTokenRaw)

			if refundReceiverRaw == "" {
				return fmt.Errorf("--refund-receiver argument not specified")
			} else if !common.IsHexAddress(refundReceiverRaw) {
				return fmt.Errorf("--refund-receiver argument is not a valid Ethereum address")
			}
			refundReceiver = common.HexToAddress(refundReceiverRaw)

			if _nonce0Raw == "" {
				return fmt.Errorf("---nonce-0 argument not specified")
			}
			_nonce0 = new(big.Int)
			_nonce0.SetString(_nonce0Raw, 0)

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			client, clientErr := NewClient(rpc)
			if clientErr != nil {
				return clientErr
			}

			contract, contractErr := NewSafe(contractAddress, client)
			if contractErr != nil {
				return contractErr
			}

			callOpts := bind.CallOpts{}
			SetCallParametersFromArgs(&callOpts, pending, fromAddressRaw, blockNumberRaw)

			session := SafeCallerSession{
				Contract: &contract.SafeCaller,
				CallOpts: callOpts,
			}

			var callErr error
			capture0, callErr = session.GetTransactionHash(
				to0,
				value0,
				data,
				operation,
				safeTxGas,
				baseGas,
				gasPrice0,
				gasToken,
				refundReceiver,
				_nonce0,
			)
			if callErr != nil {
				return callErr
			}

			cmd.Printf("0: %v\n", capture0)

			return nil
		},
	}

	cmd.Flags().StringVar(&rpc, "rpc", "", "URL of the JSONRPC API to use")
	cmd.Flags().StringVar(&blockNumberRaw, "block", "", "Block number at which to call the view method")
	cmd.Flags().BoolVar(&pending, "pending", false, "Set this flag if it's ok to call the view method against pending state")
	cmd.Flags().UintVar(&timeout, "timeout", 60, "Timeout (in seconds) for interactions with the JSONRPC API")
	cmd.Flags().StringVar(&contractAddressRaw, "contract", "", "Address of the contract to interact with")
	cmd.Flags().StringVar(&fromAddressRaw, "from", "", "Optional address for caller of the view method")

	cmd.Flags().StringVar(&to0Raw, "to-0", "", "to-0 argument (common.Address)")
	cmd.Flags().StringVar(&value0Raw, "value-0", "", "value-0 argument")
	cmd.Flags().StringVar(&dataRaw, "data", "", "data argument ([]byte)")
	cmd.Flags().Uint8Var(&operation, "operation", 0, "operation argument")
	cmd.Flags().StringVar(&safeTxGasRaw, "safe-tx-gas", "", "safe-tx-gas argument")
	cmd.Flags().StringVar(&baseGasRaw, "base-gas", "", "base-gas argument")
	cmd.Flags().StringVar(&gasPrice0Raw, "gas-price-0", "", "gas-price-0 argument")
	cmd.Flags().StringVar(&gasTokenRaw, "gas-token", "", "gas-token argument (common.Address)")
	cmd.Flags().StringVar(&refundReceiverRaw, "refund-receiver", "", "refund-receiver argument (common.Address)")
	cmd.Flags().StringVar(&_nonce0Raw, "-nonce-0", "", "-nonce-0 argument")

	return cmd
}
func CreateIsModuleEnabledCommand() *cobra.Command {
	var contractAddressRaw, rpc string
	var contractAddress common.Address
	var timeout uint

	var blockNumberRaw, fromAddressRaw string
	var pending bool

	var module common.Address
	var moduleRaw string

	var capture0 bool

	cmd := &cobra.Command{
		Use:   "is-module-enabled",
		Short: "Call the IsModuleEnabled view method on a Safe contract",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if contractAddressRaw == "" {
				return fmt.Errorf("--contract not specified")
			} else if !common.IsHexAddress(contractAddressRaw) {
				return fmt.Errorf("--contract is not a valid Ethereum address")
			}
			contractAddress = common.HexToAddress(contractAddressRaw)

			if moduleRaw == "" {
				return fmt.Errorf("--module argument not specified")
			} else if !common.IsHexAddress(moduleRaw) {
				return fmt.Errorf("--module argument is not a valid Ethereum address")
			}
			module = common.HexToAddress(moduleRaw)

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			client, clientErr := NewClient(rpc)
			if clientErr != nil {
				return clientErr
			}

			contract, contractErr := NewSafe(contractAddress, client)
			if contractErr != nil {
				return contractErr
			}

			callOpts := bind.CallOpts{}
			SetCallParametersFromArgs(&callOpts, pending, fromAddressRaw, blockNumberRaw)

			session := SafeCallerSession{
				Contract: &contract.SafeCaller,
				CallOpts: callOpts,
			}

			var callErr error
			capture0, callErr = session.IsModuleEnabled(
				module,
			)
			if callErr != nil {
				return callErr
			}

			cmd.Printf("0: %t\n", capture0)

			return nil
		},
	}

	cmd.Flags().StringVar(&rpc, "rpc", "", "URL of the JSONRPC API to use")
	cmd.Flags().StringVar(&blockNumberRaw, "block", "", "Block number at which to call the view method")
	cmd.Flags().BoolVar(&pending, "pending", false, "Set this flag if it's ok to call the view method against pending state")
	cmd.Flags().UintVar(&timeout, "timeout", 60, "Timeout (in seconds) for interactions with the JSONRPC API")
	cmd.Flags().StringVar(&contractAddressRaw, "contract", "", "Address of the contract to interact with")
	cmd.Flags().StringVar(&fromAddressRaw, "from", "", "Optional address for caller of the view method")

	cmd.Flags().StringVar(&moduleRaw, "module", "", "module argument (common.Address)")

	return cmd
}
func CreateIsOwnerCommand() *cobra.Command {
	var contractAddressRaw, rpc string
	var contractAddress common.Address
	var timeout uint

	var blockNumberRaw, fromAddressRaw string
	var pending bool

	var owner common.Address
	var ownerRaw string

	var capture0 bool

	cmd := &cobra.Command{
		Use:   "is-owner",
		Short: "Call the IsOwner view method on a Safe contract",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if contractAddressRaw == "" {
				return fmt.Errorf("--contract not specified")
			} else if !common.IsHexAddress(contractAddressRaw) {
				return fmt.Errorf("--contract is not a valid Ethereum address")
			}
			contractAddress = common.HexToAddress(contractAddressRaw)

			if ownerRaw == "" {
				return fmt.Errorf("--owner argument not specified")
			} else if !common.IsHexAddress(ownerRaw) {
				return fmt.Errorf("--owner argument is not a valid Ethereum address")
			}
			owner = common.HexToAddress(ownerRaw)

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			client, clientErr := NewClient(rpc)
			if clientErr != nil {
				return clientErr
			}

			contract, contractErr := NewSafe(contractAddress, client)
			if contractErr != nil {
				return contractErr
			}

			callOpts := bind.CallOpts{}
			SetCallParametersFromArgs(&callOpts, pending, fromAddressRaw, blockNumberRaw)

			session := SafeCallerSession{
				Contract: &contract.SafeCaller,
				CallOpts: callOpts,
			}

			var callErr error
			capture0, callErr = session.IsOwner(
				owner,
			)
			if callErr != nil {
				return callErr
			}

			cmd.Printf("0: %t\n", capture0)

			return nil
		},
	}

	cmd.Flags().StringVar(&rpc, "rpc", "", "URL of the JSONRPC API to use")
	cmd.Flags().StringVar(&blockNumberRaw, "block", "", "Block number at which to call the view method")
	cmd.Flags().BoolVar(&pending, "pending", false, "Set this flag if it's ok to call the view method against pending state")
	cmd.Flags().UintVar(&timeout, "timeout", 60, "Timeout (in seconds) for interactions with the JSONRPC API")
	cmd.Flags().StringVar(&contractAddressRaw, "contract", "", "Address of the contract to interact with")
	cmd.Flags().StringVar(&fromAddressRaw, "from", "", "Optional address for caller of the view method")

	cmd.Flags().StringVar(&ownerRaw, "owner", "", "owner argument (common.Address)")

	return cmd
}
func CreateNonceCommand() *cobra.Command {
	var contractAddressRaw, rpc string
	var contractAddress common.Address
	var timeout uint

	var blockNumberRaw, fromAddressRaw string
	var pending bool

	var capture0 *big.Int

	cmd := &cobra.Command{
		Use:   "nonce",
		Short: "Call the Nonce view method on a Safe contract",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if contractAddressRaw == "" {
				return fmt.Errorf("--contract not specified")
			} else if !common.IsHexAddress(contractAddressRaw) {
				return fmt.Errorf("--contract is not a valid Ethereum address")
			}
			contractAddress = common.HexToAddress(contractAddressRaw)

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			client, clientErr := NewClient(rpc)
			if clientErr != nil {
				return clientErr
			}

			contract, contractErr := NewSafe(contractAddress, client)
			if contractErr != nil {
				return contractErr
			}

			callOpts := bind.CallOpts{}
			SetCallParametersFromArgs(&callOpts, pending, fromAddressRaw, blockNumberRaw)

			session := SafeCallerSession{
				Contract: &contract.SafeCaller,
				CallOpts: callOpts,
			}

			var callErr error
			capture0, callErr = session.Nonce()
			if callErr != nil {
				return callErr
			}

			cmd.Printf("0: %s\n", capture0.String())

			return nil
		},
	}

	cmd.Flags().StringVar(&rpc, "rpc", "", "URL of the JSONRPC API to use")
	cmd.Flags().StringVar(&blockNumberRaw, "block", "", "Block number at which to call the view method")
	cmd.Flags().BoolVar(&pending, "pending", false, "Set this flag if it's ok to call the view method against pending state")
	cmd.Flags().UintVar(&timeout, "timeout", 60, "Timeout (in seconds) for interactions with the JSONRPC API")
	cmd.Flags().StringVar(&contractAddressRaw, "contract", "", "Address of the contract to interact with")
	cmd.Flags().StringVar(&fromAddressRaw, "from", "", "Optional address for caller of the view method")

	return cmd
}
func CreateSignedMessagesCommand() *cobra.Command {
	var contractAddressRaw, rpc string
	var contractAddress common.Address
	var timeout uint

	var blockNumberRaw, fromAddressRaw string
	var pending bool

	var arg0 [32]byte
	var arg0Raw string

	var capture0 *big.Int

	cmd := &cobra.Command{
		Use:   "signed-messages",
		Short: "Call the SignedMessages view method on a Safe contract",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if contractAddressRaw == "" {
				return fmt.Errorf("--contract not specified")
			} else if !common.IsHexAddress(contractAddressRaw) {
				return fmt.Errorf("--contract is not a valid Ethereum address")
			}
			contractAddress = common.HexToAddress(contractAddressRaw)

			var arg0Intermediate []byte

			var arg0IntermediateHexDecodeErr error
			arg0Intermediate, arg0IntermediateHexDecodeErr = hex.DecodeString(arg0Raw)
			if arg0IntermediateHexDecodeErr != nil {
				return arg0IntermediateHexDecodeErr
			}

			copy(arg0[:], arg0Intermediate)

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			client, clientErr := NewClient(rpc)
			if clientErr != nil {
				return clientErr
			}

			contract, contractErr := NewSafe(contractAddress, client)
			if contractErr != nil {
				return contractErr
			}

			callOpts := bind.CallOpts{}
			SetCallParametersFromArgs(&callOpts, pending, fromAddressRaw, blockNumberRaw)

			session := SafeCallerSession{
				Contract: &contract.SafeCaller,
				CallOpts: callOpts,
			}

			var callErr error
			capture0, callErr = session.SignedMessages(
				arg0,
			)
			if callErr != nil {
				return callErr
			}

			cmd.Printf("0: %s\n", capture0.String())

			return nil
		},
	}

	cmd.Flags().StringVar(&rpc, "rpc", "", "URL of the JSONRPC API to use")
	cmd.Flags().StringVar(&blockNumberRaw, "block", "", "Block number at which to call the view method")
	cmd.Flags().BoolVar(&pending, "pending", false, "Set this flag if it's ok to call the view method against pending state")
	cmd.Flags().UintVar(&timeout, "timeout", 60, "Timeout (in seconds) for interactions with the JSONRPC API")
	cmd.Flags().StringVar(&contractAddressRaw, "contract", "", "Address of the contract to interact with")
	cmd.Flags().StringVar(&fromAddressRaw, "from", "", "Optional address for caller of the view method")

	cmd.Flags().StringVar(&arg0Raw, "arg-0", "", "arg-0 argument ([32]byte)")

	return cmd
}
func CreateVersionCommand() *cobra.Command {
	var contractAddressRaw, rpc string
	var contractAddress common.Address
	var timeout uint

	var blockNumberRaw, fromAddressRaw string
	var pending bool

	var capture0 string

	cmd := &cobra.Command{
		Use:   "version",
		Short: "Call the VERSION view method on a Safe contract",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if contractAddressRaw == "" {
				return fmt.Errorf("--contract not specified")
			} else if !common.IsHexAddress(contractAddressRaw) {
				return fmt.Errorf("--contract is not a valid Ethereum address")
			}
			contractAddress = common.HexToAddress(contractAddressRaw)

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			client, clientErr := NewClient(rpc)
			if clientErr != nil {
				return clientErr
			}

			contract, contractErr := NewSafe(contractAddress, client)
			if contractErr != nil {
				return contractErr
			}

			callOpts := bind.CallOpts{}
			SetCallParametersFromArgs(&callOpts, pending, fromAddressRaw, blockNumberRaw)

			session := SafeCallerSession{
				Contract: &contract.SafeCaller,
				CallOpts: callOpts,
			}

			var callErr error
			capture0, callErr = session.VERSION()
			if callErr != nil {
				return callErr
			}

			cmd.Printf("0: %s\n", capture0)

			return nil
		},
	}

	cmd.Flags().StringVar(&rpc, "rpc", "", "URL of the JSONRPC API to use")
	cmd.Flags().StringVar(&blockNumberRaw, "block", "", "Block number at which to call the view method")
	cmd.Flags().BoolVar(&pending, "pending", false, "Set this flag if it's ok to call the view method against pending state")
	cmd.Flags().UintVar(&timeout, "timeout", 60, "Timeout (in seconds) for interactions with the JSONRPC API")
	cmd.Flags().StringVar(&contractAddressRaw, "contract", "", "Address of the contract to interact with")
	cmd.Flags().StringVar(&fromAddressRaw, "from", "", "Optional address for caller of the view method")

	return cmd
}

func CreateAddOwnerWithThresholdCommand() *cobra.Command {
	var keyfile, nonce, password, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas, rpc, contractAddressRaw string
	var gasLimit uint64
	var simulate bool
	var timeout uint
	var contractAddress common.Address
	var safeAddress, safeApi string
	var safeOperationType uint8

	var owner common.Address
	var ownerRaw string
	var threshold *big.Int
	var thresholdRaw string

	cmd := &cobra.Command{
		Use:   "add-owner-with-threshold",
		Short: "Execute the AddOwnerWithThreshold method on a Safe contract",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if contractAddressRaw == "" {
				return fmt.Errorf("--contract not specified")
			} else if !common.IsHexAddress(contractAddressRaw) {
				return fmt.Errorf("--contract is not a valid Ethereum address")
			}
			contractAddress = common.HexToAddress(contractAddressRaw)

			if keyfile == "" {
				return fmt.Errorf("--keystore not specified (this should be a path to an Ethereum account keystore file)")
			}

			if rpc == "" {
				return fmt.Errorf("--rpc not specified (this should be a URL to an Ethereum JSONRPC API)")
			}

			if safeAddress != "" {
				if !common.IsHexAddress(safeAddress) {
					return fmt.Errorf("--safe is not a valid Ethereum address")
				}
				if safeApi == "" {
					client, clientErr := NewClient(rpc)
					if clientErr != nil {
						return clientErr
					}
					chainIDCtx, cancelChainIDCtx := NewChainContext(timeout)
					defer cancelChainIDCtx()
					chainID, chainIDErr := client.ChainID(chainIDCtx)
					if chainIDErr != nil {
						return chainIDErr
					}
					safeApi = fmt.Sprintf("https://safe-client.safe.global/v1/chains/%s/transactions/%s/propose", chainID.String(), safeAddress)
					fmt.Println("--safe-api not specified, using default (", safeApi, ")")
				}

				if SafeOperationType(safeOperationType).String() == "Unknown" {
					return fmt.Errorf("--safe-operation must be 0 (Call) or 1 (DelegateCall)")
				}
			}

			if ownerRaw == "" {
				return fmt.Errorf("--owner argument not specified")
			} else if !common.IsHexAddress(ownerRaw) {
				return fmt.Errorf("--owner argument is not a valid Ethereum address")
			}
			owner = common.HexToAddress(ownerRaw)

			if thresholdRaw == "" {
				return fmt.Errorf("--threshold argument not specified")
			}
			threshold = new(big.Int)
			threshold.SetString(thresholdRaw, 0)

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			client, clientErr := NewClient(rpc)
			if clientErr != nil {
				return clientErr
			}

			key, keyErr := KeyFromFile(keyfile, password)
			if keyErr != nil {
				return keyErr
			}

			chainIDCtx, cancelChainIDCtx := NewChainContext(timeout)
			defer cancelChainIDCtx()
			chainID, chainIDErr := client.ChainID(chainIDCtx)
			if chainIDErr != nil {
				return chainIDErr
			}

			transactionOpts, transactionOptsErr := bind.NewKeyedTransactorWithChainID(key.PrivateKey, chainID)
			if transactionOptsErr != nil {
				return transactionOptsErr
			}

			SetTransactionParametersFromArgs(transactionOpts, nonce, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas, gasLimit, simulate)

			contract, contractErr := NewSafe(contractAddress, client)
			if contractErr != nil {
				return contractErr
			}

			session := SafeTransactorSession{
				Contract:     &contract.SafeTransactor,
				TransactOpts: *transactionOpts,
			}

			if safeAddress != "" {
				// Generate transaction data
				transaction, err := session.AddOwnerWithThreshold(

					owner,
					threshold,
				)

				if err != nil {
					return err
				}

				// Create Safe proposal for transaction
				value := transactionOpts.Value
				if value == nil {
					value = big.NewInt(0)
				}
				err = CreateSafeProposal(client, key, common.HexToAddress(safeAddress), contractAddress, transaction.Data(), value, safeApi, SafeOperationType(safeOperationType))
				if err != nil {
					return fmt.Errorf("failed to create Safe proposal: %v", err)
				}

				return nil
			}

			transaction, err := session.AddOwnerWithThreshold(

				owner,
				threshold,
			)
			if err != nil {
				return err
			}

			cmd.Printf("Transaction hash: %s\n", transaction.Hash().Hex())
			if transactionOpts.NoSend {
				estimationMessage := ethereum.CallMsg{
					From: transactionOpts.From,
					To:   &contractAddress,
					Data: transaction.Data(),
				}

				gasEstimationCtx, cancelGasEstimationCtx := NewChainContext(timeout)
				defer cancelGasEstimationCtx()

				gasEstimate, gasEstimateErr := client.EstimateGas(gasEstimationCtx, estimationMessage)
				if gasEstimateErr != nil {
					return gasEstimateErr
				}

				transactionBinary, transactionBinaryErr := transaction.MarshalBinary()
				if transactionBinaryErr != nil {
					return transactionBinaryErr
				}
				transactionBinaryHex := hex.EncodeToString(transactionBinary)

				cmd.Printf("Transaction: %s\nEstimated gas: %d\n", transactionBinaryHex, gasEstimate)
			} else {
				cmd.Println("Transaction submitted")
			}

			return nil
		},
	}

	cmd.Flags().StringVar(&rpc, "rpc", "", "URL of the JSONRPC API to use")
	cmd.Flags().StringVar(&keyfile, "keyfile", "", "Path to the keystore file to use for the transaction")
	cmd.Flags().StringVar(&password, "password", "", "Password to use to unlock the keystore (if not specified, you will be prompted for the password when the command executes)")
	cmd.Flags().StringVar(&nonce, "nonce", "", "Nonce to use for the transaction")
	cmd.Flags().StringVar(&value, "value", "", "Value to send with the transaction")
	cmd.Flags().StringVar(&gasPrice, "gas-price", "", "Gas price to use for the transaction")
	cmd.Flags().StringVar(&maxFeePerGas, "max-fee-per-gas", "", "Maximum fee per gas to use for the (EIP-1559) transaction")
	cmd.Flags().StringVar(&maxPriorityFeePerGas, "max-priority-fee-per-gas", "", "Maximum priority fee per gas to use for the (EIP-1559) transaction")
	cmd.Flags().Uint64Var(&gasLimit, "gas-limit", 0, "Gas limit for the transaction")
	cmd.Flags().BoolVar(&simulate, "simulate", false, "Simulate the transaction without sending it")
	cmd.Flags().UintVar(&timeout, "timeout", 60, "Timeout (in seconds) for interactions with the JSONRPC API")
	cmd.Flags().StringVar(&contractAddressRaw, "contract", "", "Address of the contract to interact with")
	cmd.Flags().StringVar(&safeAddress, "safe", "", "Address of the Safe contract")
	cmd.Flags().StringVar(&safeApi, "safe-api", "", "Safe API for the Safe Transaction Service (optional)")
	cmd.Flags().Uint8Var(&safeOperationType, "safe-operation", 0, "Safe operation type: 0 (Call) or 1 (DelegateCall)")

	cmd.Flags().StringVar(&ownerRaw, "owner", "", "owner argument (common.Address)")
	cmd.Flags().StringVar(&thresholdRaw, "threshold", "", "threshold argument")

	return cmd
}
func CreateApproveHashCommand() *cobra.Command {
	var keyfile, nonce, password, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas, rpc, contractAddressRaw string
	var gasLimit uint64
	var simulate bool
	var timeout uint
	var contractAddress common.Address
	var safeAddress, safeApi string
	var safeOperationType uint8

	var hashToApprove [32]byte
	var hashToApproveRaw string

	cmd := &cobra.Command{
		Use:   "approve-hash",
		Short: "Execute the ApproveHash method on a Safe contract",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if contractAddressRaw == "" {
				return fmt.Errorf("--contract not specified")
			} else if !common.IsHexAddress(contractAddressRaw) {
				return fmt.Errorf("--contract is not a valid Ethereum address")
			}
			contractAddress = common.HexToAddress(contractAddressRaw)

			if keyfile == "" {
				return fmt.Errorf("--keystore not specified (this should be a path to an Ethereum account keystore file)")
			}

			if rpc == "" {
				return fmt.Errorf("--rpc not specified (this should be a URL to an Ethereum JSONRPC API)")
			}

			if safeAddress != "" {
				if !common.IsHexAddress(safeAddress) {
					return fmt.Errorf("--safe is not a valid Ethereum address")
				}
				if safeApi == "" {
					client, clientErr := NewClient(rpc)
					if clientErr != nil {
						return clientErr
					}
					chainIDCtx, cancelChainIDCtx := NewChainContext(timeout)
					defer cancelChainIDCtx()
					chainID, chainIDErr := client.ChainID(chainIDCtx)
					if chainIDErr != nil {
						return chainIDErr
					}
					safeApi = fmt.Sprintf("https://safe-client.safe.global/v1/chains/%s/transactions/%s/propose", chainID.String(), safeAddress)
					fmt.Println("--safe-api not specified, using default (", safeApi, ")")
				}

				if SafeOperationType(safeOperationType).String() == "Unknown" {
					return fmt.Errorf("--safe-operation must be 0 (Call) or 1 (DelegateCall)")
				}
			}

			var hashToApproveIntermediate []byte

			var hashToApproveIntermediateHexDecodeErr error
			hashToApproveIntermediate, hashToApproveIntermediateHexDecodeErr = hex.DecodeString(hashToApproveRaw)
			if hashToApproveIntermediateHexDecodeErr != nil {
				return hashToApproveIntermediateHexDecodeErr
			}

			copy(hashToApprove[:], hashToApproveIntermediate)

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			client, clientErr := NewClient(rpc)
			if clientErr != nil {
				return clientErr
			}

			key, keyErr := KeyFromFile(keyfile, password)
			if keyErr != nil {
				return keyErr
			}

			chainIDCtx, cancelChainIDCtx := NewChainContext(timeout)
			defer cancelChainIDCtx()
			chainID, chainIDErr := client.ChainID(chainIDCtx)
			if chainIDErr != nil {
				return chainIDErr
			}

			transactionOpts, transactionOptsErr := bind.NewKeyedTransactorWithChainID(key.PrivateKey, chainID)
			if transactionOptsErr != nil {
				return transactionOptsErr
			}

			SetTransactionParametersFromArgs(transactionOpts, nonce, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas, gasLimit, simulate)

			contract, contractErr := NewSafe(contractAddress, client)
			if contractErr != nil {
				return contractErr
			}

			session := SafeTransactorSession{
				Contract:     &contract.SafeTransactor,
				TransactOpts: *transactionOpts,
			}

			if safeAddress != "" {
				// Generate transaction data
				transaction, err := session.ApproveHash(

					hashToApprove,
				)

				if err != nil {
					return err
				}

				// Create Safe proposal for transaction
				value := transactionOpts.Value
				if value == nil {
					value = big.NewInt(0)
				}
				err = CreateSafeProposal(client, key, common.HexToAddress(safeAddress), contractAddress, transaction.Data(), value, safeApi, SafeOperationType(safeOperationType))
				if err != nil {
					return fmt.Errorf("failed to create Safe proposal: %v", err)
				}

				return nil
			}

			transaction, err := session.ApproveHash(

				hashToApprove,
			)
			if err != nil {
				return err
			}

			cmd.Printf("Transaction hash: %s\n", transaction.Hash().Hex())
			if transactionOpts.NoSend {
				estimationMessage := ethereum.CallMsg{
					From: transactionOpts.From,
					To:   &contractAddress,
					Data: transaction.Data(),
				}

				gasEstimationCtx, cancelGasEstimationCtx := NewChainContext(timeout)
				defer cancelGasEstimationCtx()

				gasEstimate, gasEstimateErr := client.EstimateGas(gasEstimationCtx, estimationMessage)
				if gasEstimateErr != nil {
					return gasEstimateErr
				}

				transactionBinary, transactionBinaryErr := transaction.MarshalBinary()
				if transactionBinaryErr != nil {
					return transactionBinaryErr
				}
				transactionBinaryHex := hex.EncodeToString(transactionBinary)

				cmd.Printf("Transaction: %s\nEstimated gas: %d\n", transactionBinaryHex, gasEstimate)
			} else {
				cmd.Println("Transaction submitted")
			}

			return nil
		},
	}

	cmd.Flags().StringVar(&rpc, "rpc", "", "URL of the JSONRPC API to use")
	cmd.Flags().StringVar(&keyfile, "keyfile", "", "Path to the keystore file to use for the transaction")
	cmd.Flags().StringVar(&password, "password", "", "Password to use to unlock the keystore (if not specified, you will be prompted for the password when the command executes)")
	cmd.Flags().StringVar(&nonce, "nonce", "", "Nonce to use for the transaction")
	cmd.Flags().StringVar(&value, "value", "", "Value to send with the transaction")
	cmd.Flags().StringVar(&gasPrice, "gas-price", "", "Gas price to use for the transaction")
	cmd.Flags().StringVar(&maxFeePerGas, "max-fee-per-gas", "", "Maximum fee per gas to use for the (EIP-1559) transaction")
	cmd.Flags().StringVar(&maxPriorityFeePerGas, "max-priority-fee-per-gas", "", "Maximum priority fee per gas to use for the (EIP-1559) transaction")
	cmd.Flags().Uint64Var(&gasLimit, "gas-limit", 0, "Gas limit for the transaction")
	cmd.Flags().BoolVar(&simulate, "simulate", false, "Simulate the transaction without sending it")
	cmd.Flags().UintVar(&timeout, "timeout", 60, "Timeout (in seconds) for interactions with the JSONRPC API")
	cmd.Flags().StringVar(&contractAddressRaw, "contract", "", "Address of the contract to interact with")
	cmd.Flags().StringVar(&safeAddress, "safe", "", "Address of the Safe contract")
	cmd.Flags().StringVar(&safeApi, "safe-api", "", "Safe API for the Safe Transaction Service (optional)")
	cmd.Flags().Uint8Var(&safeOperationType, "safe-operation", 0, "Safe operation type: 0 (Call) or 1 (DelegateCall)")

	cmd.Flags().StringVar(&hashToApproveRaw, "hash-to-approve", "", "hash-to-approve argument ([32]byte)")

	return cmd
}
func CreateChangeThresholdCommand() *cobra.Command {
	var keyfile, nonce, password, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas, rpc, contractAddressRaw string
	var gasLimit uint64
	var simulate bool
	var timeout uint
	var contractAddress common.Address
	var safeAddress, safeApi string
	var safeOperationType uint8

	var threshold *big.Int
	var thresholdRaw string

	cmd := &cobra.Command{
		Use:   "change-threshold",
		Short: "Execute the ChangeThreshold method on a Safe contract",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if contractAddressRaw == "" {
				return fmt.Errorf("--contract not specified")
			} else if !common.IsHexAddress(contractAddressRaw) {
				return fmt.Errorf("--contract is not a valid Ethereum address")
			}
			contractAddress = common.HexToAddress(contractAddressRaw)

			if keyfile == "" {
				return fmt.Errorf("--keystore not specified (this should be a path to an Ethereum account keystore file)")
			}

			if rpc == "" {
				return fmt.Errorf("--rpc not specified (this should be a URL to an Ethereum JSONRPC API)")
			}

			if safeAddress != "" {
				if !common.IsHexAddress(safeAddress) {
					return fmt.Errorf("--safe is not a valid Ethereum address")
				}
				if safeApi == "" {
					client, clientErr := NewClient(rpc)
					if clientErr != nil {
						return clientErr
					}
					chainIDCtx, cancelChainIDCtx := NewChainContext(timeout)
					defer cancelChainIDCtx()
					chainID, chainIDErr := client.ChainID(chainIDCtx)
					if chainIDErr != nil {
						return chainIDErr
					}
					safeApi = fmt.Sprintf("https://safe-client.safe.global/v1/chains/%s/transactions/%s/propose", chainID.String(), safeAddress)
					fmt.Println("--safe-api not specified, using default (", safeApi, ")")
				}

				if SafeOperationType(safeOperationType).String() == "Unknown" {
					return fmt.Errorf("--safe-operation must be 0 (Call) or 1 (DelegateCall)")
				}
			}

			if thresholdRaw == "" {
				return fmt.Errorf("--threshold argument not specified")
			}
			threshold = new(big.Int)
			threshold.SetString(thresholdRaw, 0)

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			client, clientErr := NewClient(rpc)
			if clientErr != nil {
				return clientErr
			}

			key, keyErr := KeyFromFile(keyfile, password)
			if keyErr != nil {
				return keyErr
			}

			chainIDCtx, cancelChainIDCtx := NewChainContext(timeout)
			defer cancelChainIDCtx()
			chainID, chainIDErr := client.ChainID(chainIDCtx)
			if chainIDErr != nil {
				return chainIDErr
			}

			transactionOpts, transactionOptsErr := bind.NewKeyedTransactorWithChainID(key.PrivateKey, chainID)
			if transactionOptsErr != nil {
				return transactionOptsErr
			}

			SetTransactionParametersFromArgs(transactionOpts, nonce, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas, gasLimit, simulate)

			contract, contractErr := NewSafe(contractAddress, client)
			if contractErr != nil {
				return contractErr
			}

			session := SafeTransactorSession{
				Contract:     &contract.SafeTransactor,
				TransactOpts: *transactionOpts,
			}

			if safeAddress != "" {
				// Generate transaction data
				transaction, err := session.ChangeThreshold(

					threshold,
				)

				if err != nil {
					return err
				}

				// Create Safe proposal for transaction
				value := transactionOpts.Value
				if value == nil {
					value = big.NewInt(0)
				}
				err = CreateSafeProposal(client, key, common.HexToAddress(safeAddress), contractAddress, transaction.Data(), value, safeApi, SafeOperationType(safeOperationType))
				if err != nil {
					return fmt.Errorf("failed to create Safe proposal: %v", err)
				}

				return nil
			}

			transaction, err := session.ChangeThreshold(

				threshold,
			)
			if err != nil {
				return err
			}

			cmd.Printf("Transaction hash: %s\n", transaction.Hash().Hex())
			if transactionOpts.NoSend {
				estimationMessage := ethereum.CallMsg{
					From: transactionOpts.From,
					To:   &contractAddress,
					Data: transaction.Data(),
				}

				gasEstimationCtx, cancelGasEstimationCtx := NewChainContext(timeout)
				defer cancelGasEstimationCtx()

				gasEstimate, gasEstimateErr := client.EstimateGas(gasEstimationCtx, estimationMessage)
				if gasEstimateErr != nil {
					return gasEstimateErr
				}

				transactionBinary, transactionBinaryErr := transaction.MarshalBinary()
				if transactionBinaryErr != nil {
					return transactionBinaryErr
				}
				transactionBinaryHex := hex.EncodeToString(transactionBinary)

				cmd.Printf("Transaction: %s\nEstimated gas: %d\n", transactionBinaryHex, gasEstimate)
			} else {
				cmd.Println("Transaction submitted")
			}

			return nil
		},
	}

	cmd.Flags().StringVar(&rpc, "rpc", "", "URL of the JSONRPC API to use")
	cmd.Flags().StringVar(&keyfile, "keyfile", "", "Path to the keystore file to use for the transaction")
	cmd.Flags().StringVar(&password, "password", "", "Password to use to unlock the keystore (if not specified, you will be prompted for the password when the command executes)")
	cmd.Flags().StringVar(&nonce, "nonce", "", "Nonce to use for the transaction")
	cmd.Flags().StringVar(&value, "value", "", "Value to send with the transaction")
	cmd.Flags().StringVar(&gasPrice, "gas-price", "", "Gas price to use for the transaction")
	cmd.Flags().StringVar(&maxFeePerGas, "max-fee-per-gas", "", "Maximum fee per gas to use for the (EIP-1559) transaction")
	cmd.Flags().StringVar(&maxPriorityFeePerGas, "max-priority-fee-per-gas", "", "Maximum priority fee per gas to use for the (EIP-1559) transaction")
	cmd.Flags().Uint64Var(&gasLimit, "gas-limit", 0, "Gas limit for the transaction")
	cmd.Flags().BoolVar(&simulate, "simulate", false, "Simulate the transaction without sending it")
	cmd.Flags().UintVar(&timeout, "timeout", 60, "Timeout (in seconds) for interactions with the JSONRPC API")
	cmd.Flags().StringVar(&contractAddressRaw, "contract", "", "Address of the contract to interact with")
	cmd.Flags().StringVar(&safeAddress, "safe", "", "Address of the Safe contract")
	cmd.Flags().StringVar(&safeApi, "safe-api", "", "Safe API for the Safe Transaction Service (optional)")
	cmd.Flags().Uint8Var(&safeOperationType, "safe-operation", 0, "Safe operation type: 0 (Call) or 1 (DelegateCall)")

	cmd.Flags().StringVar(&thresholdRaw, "threshold", "", "threshold argument")

	return cmd
}
func CreateDisableModuleCommand() *cobra.Command {
	var keyfile, nonce, password, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas, rpc, contractAddressRaw string
	var gasLimit uint64
	var simulate bool
	var timeout uint
	var contractAddress common.Address
	var safeAddress, safeApi string
	var safeOperationType uint8

	var prevModule common.Address
	var prevModuleRaw string
	var module common.Address
	var moduleRaw string

	cmd := &cobra.Command{
		Use:   "disable-module",
		Short: "Execute the DisableModule method on a Safe contract",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if contractAddressRaw == "" {
				return fmt.Errorf("--contract not specified")
			} else if !common.IsHexAddress(contractAddressRaw) {
				return fmt.Errorf("--contract is not a valid Ethereum address")
			}
			contractAddress = common.HexToAddress(contractAddressRaw)

			if keyfile == "" {
				return fmt.Errorf("--keystore not specified (this should be a path to an Ethereum account keystore file)")
			}

			if rpc == "" {
				return fmt.Errorf("--rpc not specified (this should be a URL to an Ethereum JSONRPC API)")
			}

			if safeAddress != "" {
				if !common.IsHexAddress(safeAddress) {
					return fmt.Errorf("--safe is not a valid Ethereum address")
				}
				if safeApi == "" {
					client, clientErr := NewClient(rpc)
					if clientErr != nil {
						return clientErr
					}
					chainIDCtx, cancelChainIDCtx := NewChainContext(timeout)
					defer cancelChainIDCtx()
					chainID, chainIDErr := client.ChainID(chainIDCtx)
					if chainIDErr != nil {
						return chainIDErr
					}
					safeApi = fmt.Sprintf("https://safe-client.safe.global/v1/chains/%s/transactions/%s/propose", chainID.String(), safeAddress)
					fmt.Println("--safe-api not specified, using default (", safeApi, ")")
				}

				if SafeOperationType(safeOperationType).String() == "Unknown" {
					return fmt.Errorf("--safe-operation must be 0 (Call) or 1 (DelegateCall)")
				}
			}

			if prevModuleRaw == "" {
				return fmt.Errorf("--prev-module argument not specified")
			} else if !common.IsHexAddress(prevModuleRaw) {
				return fmt.Errorf("--prev-module argument is not a valid Ethereum address")
			}
			prevModule = common.HexToAddress(prevModuleRaw)

			if moduleRaw == "" {
				return fmt.Errorf("--module argument not specified")
			} else if !common.IsHexAddress(moduleRaw) {
				return fmt.Errorf("--module argument is not a valid Ethereum address")
			}
			module = common.HexToAddress(moduleRaw)

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			client, clientErr := NewClient(rpc)
			if clientErr != nil {
				return clientErr
			}

			key, keyErr := KeyFromFile(keyfile, password)
			if keyErr != nil {
				return keyErr
			}

			chainIDCtx, cancelChainIDCtx := NewChainContext(timeout)
			defer cancelChainIDCtx()
			chainID, chainIDErr := client.ChainID(chainIDCtx)
			if chainIDErr != nil {
				return chainIDErr
			}

			transactionOpts, transactionOptsErr := bind.NewKeyedTransactorWithChainID(key.PrivateKey, chainID)
			if transactionOptsErr != nil {
				return transactionOptsErr
			}

			SetTransactionParametersFromArgs(transactionOpts, nonce, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas, gasLimit, simulate)

			contract, contractErr := NewSafe(contractAddress, client)
			if contractErr != nil {
				return contractErr
			}

			session := SafeTransactorSession{
				Contract:     &contract.SafeTransactor,
				TransactOpts: *transactionOpts,
			}

			if safeAddress != "" {
				// Generate transaction data
				transaction, err := session.DisableModule(

					prevModule,
					module,
				)

				if err != nil {
					return err
				}

				// Create Safe proposal for transaction
				value := transactionOpts.Value
				if value == nil {
					value = big.NewInt(0)
				}
				err = CreateSafeProposal(client, key, common.HexToAddress(safeAddress), contractAddress, transaction.Data(), value, safeApi, SafeOperationType(safeOperationType))
				if err != nil {
					return fmt.Errorf("failed to create Safe proposal: %v", err)
				}

				return nil
			}

			transaction, err := session.DisableModule(

				prevModule,
				module,
			)
			if err != nil {
				return err
			}

			cmd.Printf("Transaction hash: %s\n", transaction.Hash().Hex())
			if transactionOpts.NoSend {
				estimationMessage := ethereum.CallMsg{
					From: transactionOpts.From,
					To:   &contractAddress,
					Data: transaction.Data(),
				}

				gasEstimationCtx, cancelGasEstimationCtx := NewChainContext(timeout)
				defer cancelGasEstimationCtx()

				gasEstimate, gasEstimateErr := client.EstimateGas(gasEstimationCtx, estimationMessage)
				if gasEstimateErr != nil {
					return gasEstimateErr
				}

				transactionBinary, transactionBinaryErr := transaction.MarshalBinary()
				if transactionBinaryErr != nil {
					return transactionBinaryErr
				}
				transactionBinaryHex := hex.EncodeToString(transactionBinary)

				cmd.Printf("Transaction: %s\nEstimated gas: %d\n", transactionBinaryHex, gasEstimate)
			} else {
				cmd.Println("Transaction submitted")
			}

			return nil
		},
	}

	cmd.Flags().StringVar(&rpc, "rpc", "", "URL of the JSONRPC API to use")
	cmd.Flags().StringVar(&keyfile, "keyfile", "", "Path to the keystore file to use for the transaction")
	cmd.Flags().StringVar(&password, "password", "", "Password to use to unlock the keystore (if not specified, you will be prompted for the password when the command executes)")
	cmd.Flags().StringVar(&nonce, "nonce", "", "Nonce to use for the transaction")
	cmd.Flags().StringVar(&value, "value", "", "Value to send with the transaction")
	cmd.Flags().StringVar(&gasPrice, "gas-price", "", "Gas price to use for the transaction")
	cmd.Flags().StringVar(&maxFeePerGas, "max-fee-per-gas", "", "Maximum fee per gas to use for the (EIP-1559) transaction")
	cmd.Flags().StringVar(&maxPriorityFeePerGas, "max-priority-fee-per-gas", "", "Maximum priority fee per gas to use for the (EIP-1559) transaction")
	cmd.Flags().Uint64Var(&gasLimit, "gas-limit", 0, "Gas limit for the transaction")
	cmd.Flags().BoolVar(&simulate, "simulate", false, "Simulate the transaction without sending it")
	cmd.Flags().UintVar(&timeout, "timeout", 60, "Timeout (in seconds) for interactions with the JSONRPC API")
	cmd.Flags().StringVar(&contractAddressRaw, "contract", "", "Address of the contract to interact with")
	cmd.Flags().StringVar(&safeAddress, "safe", "", "Address of the Safe contract")
	cmd.Flags().StringVar(&safeApi, "safe-api", "", "Safe API for the Safe Transaction Service (optional)")
	cmd.Flags().Uint8Var(&safeOperationType, "safe-operation", 0, "Safe operation type: 0 (Call) or 1 (DelegateCall)")

	cmd.Flags().StringVar(&prevModuleRaw, "prev-module", "", "prev-module argument (common.Address)")
	cmd.Flags().StringVar(&moduleRaw, "module", "", "module argument (common.Address)")

	return cmd
}
func CreateEnableModuleCommand() *cobra.Command {
	var keyfile, nonce, password, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas, rpc, contractAddressRaw string
	var gasLimit uint64
	var simulate bool
	var timeout uint
	var contractAddress common.Address
	var safeAddress, safeApi string
	var safeOperationType uint8

	var module common.Address
	var moduleRaw string

	cmd := &cobra.Command{
		Use:   "enable-module",
		Short: "Execute the EnableModule method on a Safe contract",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if contractAddressRaw == "" {
				return fmt.Errorf("--contract not specified")
			} else if !common.IsHexAddress(contractAddressRaw) {
				return fmt.Errorf("--contract is not a valid Ethereum address")
			}
			contractAddress = common.HexToAddress(contractAddressRaw)

			if keyfile == "" {
				return fmt.Errorf("--keystore not specified (this should be a path to an Ethereum account keystore file)")
			}

			if rpc == "" {
				return fmt.Errorf("--rpc not specified (this should be a URL to an Ethereum JSONRPC API)")
			}

			if safeAddress != "" {
				if !common.IsHexAddress(safeAddress) {
					return fmt.Errorf("--safe is not a valid Ethereum address")
				}
				if safeApi == "" {
					client, clientErr := NewClient(rpc)
					if clientErr != nil {
						return clientErr
					}
					chainIDCtx, cancelChainIDCtx := NewChainContext(timeout)
					defer cancelChainIDCtx()
					chainID, chainIDErr := client.ChainID(chainIDCtx)
					if chainIDErr != nil {
						return chainIDErr
					}
					safeApi = fmt.Sprintf("https://safe-client.safe.global/v1/chains/%s/transactions/%s/propose", chainID.String(), safeAddress)
					fmt.Println("--safe-api not specified, using default (", safeApi, ")")
				}

				if SafeOperationType(safeOperationType).String() == "Unknown" {
					return fmt.Errorf("--safe-operation must be 0 (Call) or 1 (DelegateCall)")
				}
			}

			if moduleRaw == "" {
				return fmt.Errorf("--module argument not specified")
			} else if !common.IsHexAddress(moduleRaw) {
				return fmt.Errorf("--module argument is not a valid Ethereum address")
			}
			module = common.HexToAddress(moduleRaw)

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			client, clientErr := NewClient(rpc)
			if clientErr != nil {
				return clientErr
			}

			key, keyErr := KeyFromFile(keyfile, password)
			if keyErr != nil {
				return keyErr
			}

			chainIDCtx, cancelChainIDCtx := NewChainContext(timeout)
			defer cancelChainIDCtx()
			chainID, chainIDErr := client.ChainID(chainIDCtx)
			if chainIDErr != nil {
				return chainIDErr
			}

			transactionOpts, transactionOptsErr := bind.NewKeyedTransactorWithChainID(key.PrivateKey, chainID)
			if transactionOptsErr != nil {
				return transactionOptsErr
			}

			SetTransactionParametersFromArgs(transactionOpts, nonce, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas, gasLimit, simulate)

			contract, contractErr := NewSafe(contractAddress, client)
			if contractErr != nil {
				return contractErr
			}

			session := SafeTransactorSession{
				Contract:     &contract.SafeTransactor,
				TransactOpts: *transactionOpts,
			}

			if safeAddress != "" {
				// Generate transaction data
				transaction, err := session.EnableModule(

					module,
				)

				if err != nil {
					return err
				}

				// Create Safe proposal for transaction
				value := transactionOpts.Value
				if value == nil {
					value = big.NewInt(0)
				}
				err = CreateSafeProposal(client, key, common.HexToAddress(safeAddress), contractAddress, transaction.Data(), value, safeApi, SafeOperationType(safeOperationType))
				if err != nil {
					return fmt.Errorf("failed to create Safe proposal: %v", err)
				}

				return nil
			}

			transaction, err := session.EnableModule(

				module,
			)
			if err != nil {
				return err
			}

			cmd.Printf("Transaction hash: %s\n", transaction.Hash().Hex())
			if transactionOpts.NoSend {
				estimationMessage := ethereum.CallMsg{
					From: transactionOpts.From,
					To:   &contractAddress,
					Data: transaction.Data(),
				}

				gasEstimationCtx, cancelGasEstimationCtx := NewChainContext(timeout)
				defer cancelGasEstimationCtx()

				gasEstimate, gasEstimateErr := client.EstimateGas(gasEstimationCtx, estimationMessage)
				if gasEstimateErr != nil {
					return gasEstimateErr
				}

				transactionBinary, transactionBinaryErr := transaction.MarshalBinary()
				if transactionBinaryErr != nil {
					return transactionBinaryErr
				}
				transactionBinaryHex := hex.EncodeToString(transactionBinary)

				cmd.Printf("Transaction: %s\nEstimated gas: %d\n", transactionBinaryHex, gasEstimate)
			} else {
				cmd.Println("Transaction submitted")
			}

			return nil
		},
	}

	cmd.Flags().StringVar(&rpc, "rpc", "", "URL of the JSONRPC API to use")
	cmd.Flags().StringVar(&keyfile, "keyfile", "", "Path to the keystore file to use for the transaction")
	cmd.Flags().StringVar(&password, "password", "", "Password to use to unlock the keystore (if not specified, you will be prompted for the password when the command executes)")
	cmd.Flags().StringVar(&nonce, "nonce", "", "Nonce to use for the transaction")
	cmd.Flags().StringVar(&value, "value", "", "Value to send with the transaction")
	cmd.Flags().StringVar(&gasPrice, "gas-price", "", "Gas price to use for the transaction")
	cmd.Flags().StringVar(&maxFeePerGas, "max-fee-per-gas", "", "Maximum fee per gas to use for the (EIP-1559) transaction")
	cmd.Flags().StringVar(&maxPriorityFeePerGas, "max-priority-fee-per-gas", "", "Maximum priority fee per gas to use for the (EIP-1559) transaction")
	cmd.Flags().Uint64Var(&gasLimit, "gas-limit", 0, "Gas limit for the transaction")
	cmd.Flags().BoolVar(&simulate, "simulate", false, "Simulate the transaction without sending it")
	cmd.Flags().UintVar(&timeout, "timeout", 60, "Timeout (in seconds) for interactions with the JSONRPC API")
	cmd.Flags().StringVar(&contractAddressRaw, "contract", "", "Address of the contract to interact with")
	cmd.Flags().StringVar(&safeAddress, "safe", "", "Address of the Safe contract")
	cmd.Flags().StringVar(&safeApi, "safe-api", "", "Safe API for the Safe Transaction Service (optional)")
	cmd.Flags().Uint8Var(&safeOperationType, "safe-operation", 0, "Safe operation type: 0 (Call) or 1 (DelegateCall)")

	cmd.Flags().StringVar(&moduleRaw, "module", "", "module argument (common.Address)")

	return cmd
}
func CreateExecTransactionCommand() *cobra.Command {
	var keyfile, nonce, password, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas, rpc, contractAddressRaw string
	var gasLimit uint64
	var simulate bool
	var timeout uint
	var contractAddress common.Address
	var safeAddress, safeApi string
	var safeOperationType uint8

	var to0 common.Address
	var to0Raw string
	var value0 *big.Int
	var value0Raw string
	var data []byte
	var dataRaw string
	var operation uint8

	var safeTxGas *big.Int
	var safeTxGasRaw string
	var baseGas *big.Int
	var baseGasRaw string
	var gasPrice0 *big.Int
	var gasPrice0Raw string
	var gasToken common.Address
	var gasTokenRaw string
	var refundReceiver common.Address
	var refundReceiverRaw string
	var signatures []byte
	var signaturesRaw string

	cmd := &cobra.Command{
		Use:   "exec-transaction",
		Short: "Execute the ExecTransaction method on a Safe contract",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if contractAddressRaw == "" {
				return fmt.Errorf("--contract not specified")
			} else if !common.IsHexAddress(contractAddressRaw) {
				return fmt.Errorf("--contract is not a valid Ethereum address")
			}
			contractAddress = common.HexToAddress(contractAddressRaw)

			if keyfile == "" {
				return fmt.Errorf("--keystore not specified (this should be a path to an Ethereum account keystore file)")
			}

			if rpc == "" {
				return fmt.Errorf("--rpc not specified (this should be a URL to an Ethereum JSONRPC API)")
			}

			if safeAddress != "" {
				if !common.IsHexAddress(safeAddress) {
					return fmt.Errorf("--safe is not a valid Ethereum address")
				}
				if safeApi == "" {
					client, clientErr := NewClient(rpc)
					if clientErr != nil {
						return clientErr
					}
					chainIDCtx, cancelChainIDCtx := NewChainContext(timeout)
					defer cancelChainIDCtx()
					chainID, chainIDErr := client.ChainID(chainIDCtx)
					if chainIDErr != nil {
						return chainIDErr
					}
					safeApi = fmt.Sprintf("https://safe-client.safe.global/v1/chains/%s/transactions/%s/propose", chainID.String(), safeAddress)
					fmt.Println("--safe-api not specified, using default (", safeApi, ")")
				}

				if SafeOperationType(safeOperationType).String() == "Unknown" {
					return fmt.Errorf("--safe-operation must be 0 (Call) or 1 (DelegateCall)")
				}
			}

			if to0Raw == "" {
				return fmt.Errorf("--to-0 argument not specified")
			} else if !common.IsHexAddress(to0Raw) {
				return fmt.Errorf("--to-0 argument is not a valid Ethereum address")
			}
			to0 = common.HexToAddress(to0Raw)

			if value0Raw == "" {
				return fmt.Errorf("--value-0 argument not specified")
			}
			value0 = new(big.Int)
			value0.SetString(value0Raw, 0)

			var dataIntermediate []byte

			var dataIntermediateHexDecodeErr error
			dataIntermediate, dataIntermediateHexDecodeErr = hex.DecodeString(dataRaw)
			if dataIntermediateHexDecodeErr != nil {
				return dataIntermediateHexDecodeErr
			}

			copy(data[:], dataIntermediate)

			if safeTxGasRaw == "" {
				return fmt.Errorf("--safe-tx-gas argument not specified")
			}
			safeTxGas = new(big.Int)
			safeTxGas.SetString(safeTxGasRaw, 0)

			if baseGasRaw == "" {
				return fmt.Errorf("--base-gas argument not specified")
			}
			baseGas = new(big.Int)
			baseGas.SetString(baseGasRaw, 0)

			if gasPrice0Raw == "" {
				return fmt.Errorf("--gas-price-0 argument not specified")
			}
			gasPrice0 = new(big.Int)
			gasPrice0.SetString(gasPrice0Raw, 0)

			if gasTokenRaw == "" {
				return fmt.Errorf("--gas-token argument not specified")
			} else if !common.IsHexAddress(gasTokenRaw) {
				return fmt.Errorf("--gas-token argument is not a valid Ethereum address")
			}
			gasToken = common.HexToAddress(gasTokenRaw)

			if refundReceiverRaw == "" {
				return fmt.Errorf("--refund-receiver argument not specified")
			} else if !common.IsHexAddress(refundReceiverRaw) {
				return fmt.Errorf("--refund-receiver argument is not a valid Ethereum address")
			}
			refundReceiver = common.HexToAddress(refundReceiverRaw)

			var signaturesIntermediate []byte

			var signaturesIntermediateHexDecodeErr error
			signaturesIntermediate, signaturesIntermediateHexDecodeErr = hex.DecodeString(signaturesRaw)
			if signaturesIntermediateHexDecodeErr != nil {
				return signaturesIntermediateHexDecodeErr
			}

			copy(signatures[:], signaturesIntermediate)

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			client, clientErr := NewClient(rpc)
			if clientErr != nil {
				return clientErr
			}

			key, keyErr := KeyFromFile(keyfile, password)
			if keyErr != nil {
				return keyErr
			}

			chainIDCtx, cancelChainIDCtx := NewChainContext(timeout)
			defer cancelChainIDCtx()
			chainID, chainIDErr := client.ChainID(chainIDCtx)
			if chainIDErr != nil {
				return chainIDErr
			}

			transactionOpts, transactionOptsErr := bind.NewKeyedTransactorWithChainID(key.PrivateKey, chainID)
			if transactionOptsErr != nil {
				return transactionOptsErr
			}

			SetTransactionParametersFromArgs(transactionOpts, nonce, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas, gasLimit, simulate)

			contract, contractErr := NewSafe(contractAddress, client)
			if contractErr != nil {
				return contractErr
			}

			session := SafeTransactorSession{
				Contract:     &contract.SafeTransactor,
				TransactOpts: *transactionOpts,
			}

			if safeAddress != "" {
				// Generate transaction data
				transaction, err := session.ExecTransaction(

					to0,
					value0,
					data,
					operation,
					safeTxGas,
					baseGas,
					gasPrice0,
					gasToken,
					refundReceiver,
					signatures,
				)

				if err != nil {
					return err
				}

				// Create Safe proposal for transaction
				value := transactionOpts.Value
				if value == nil {
					value = big.NewInt(0)
				}
				err = CreateSafeProposal(client, key, common.HexToAddress(safeAddress), contractAddress, transaction.Data(), value, safeApi, SafeOperationType(safeOperationType))
				if err != nil {
					return fmt.Errorf("failed to create Safe proposal: %v", err)
				}

				return nil
			}

			transaction, err := session.ExecTransaction(

				to0,
				value0,
				data,
				operation,
				safeTxGas,
				baseGas,
				gasPrice0,
				gasToken,
				refundReceiver,
				signatures,
			)
			if err != nil {
				return err
			}

			cmd.Printf("Transaction hash: %s\n", transaction.Hash().Hex())
			if transactionOpts.NoSend {
				estimationMessage := ethereum.CallMsg{
					From: transactionOpts.From,
					To:   &contractAddress,
					Data: transaction.Data(),
				}

				gasEstimationCtx, cancelGasEstimationCtx := NewChainContext(timeout)
				defer cancelGasEstimationCtx()

				gasEstimate, gasEstimateErr := client.EstimateGas(gasEstimationCtx, estimationMessage)
				if gasEstimateErr != nil {
					return gasEstimateErr
				}

				transactionBinary, transactionBinaryErr := transaction.MarshalBinary()
				if transactionBinaryErr != nil {
					return transactionBinaryErr
				}
				transactionBinaryHex := hex.EncodeToString(transactionBinary)

				cmd.Printf("Transaction: %s\nEstimated gas: %d\n", transactionBinaryHex, gasEstimate)
			} else {
				cmd.Println("Transaction submitted")
			}

			return nil
		},
	}

	cmd.Flags().StringVar(&rpc, "rpc", "", "URL of the JSONRPC API to use")
	cmd.Flags().StringVar(&keyfile, "keyfile", "", "Path to the keystore file to use for the transaction")
	cmd.Flags().StringVar(&password, "password", "", "Password to use to unlock the keystore (if not specified, you will be prompted for the password when the command executes)")
	cmd.Flags().StringVar(&nonce, "nonce", "", "Nonce to use for the transaction")
	cmd.Flags().StringVar(&value, "value", "", "Value to send with the transaction")
	cmd.Flags().StringVar(&gasPrice, "gas-price", "", "Gas price to use for the transaction")
	cmd.Flags().StringVar(&maxFeePerGas, "max-fee-per-gas", "", "Maximum fee per gas to use for the (EIP-1559) transaction")
	cmd.Flags().StringVar(&maxPriorityFeePerGas, "max-priority-fee-per-gas", "", "Maximum priority fee per gas to use for the (EIP-1559) transaction")
	cmd.Flags().Uint64Var(&gasLimit, "gas-limit", 0, "Gas limit for the transaction")
	cmd.Flags().BoolVar(&simulate, "simulate", false, "Simulate the transaction without sending it")
	cmd.Flags().UintVar(&timeout, "timeout", 60, "Timeout (in seconds) for interactions with the JSONRPC API")
	cmd.Flags().StringVar(&contractAddressRaw, "contract", "", "Address of the contract to interact with")
	cmd.Flags().StringVar(&safeAddress, "safe", "", "Address of the Safe contract")
	cmd.Flags().StringVar(&safeApi, "safe-api", "", "Safe API for the Safe Transaction Service (optional)")
	cmd.Flags().Uint8Var(&safeOperationType, "safe-operation", 0, "Safe operation type: 0 (Call) or 1 (DelegateCall)")

	cmd.Flags().StringVar(&to0Raw, "to-0", "", "to-0 argument (common.Address)")
	cmd.Flags().StringVar(&value0Raw, "value-0", "", "value-0 argument")
	cmd.Flags().StringVar(&dataRaw, "data", "", "data argument ([]byte)")
	cmd.Flags().Uint8Var(&operation, "operation", 0, "operation argument")
	cmd.Flags().StringVar(&safeTxGasRaw, "safe-tx-gas", "", "safe-tx-gas argument")
	cmd.Flags().StringVar(&baseGasRaw, "base-gas", "", "base-gas argument")
	cmd.Flags().StringVar(&gasPrice0Raw, "gas-price-0", "", "gas-price-0 argument")
	cmd.Flags().StringVar(&gasTokenRaw, "gas-token", "", "gas-token argument (common.Address)")
	cmd.Flags().StringVar(&refundReceiverRaw, "refund-receiver", "", "refund-receiver argument (common.Address)")
	cmd.Flags().StringVar(&signaturesRaw, "signatures", "", "signatures argument ([]byte)")

	return cmd
}
func CreateExecTransactionFromModuleCommand() *cobra.Command {
	var keyfile, nonce, password, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas, rpc, contractAddressRaw string
	var gasLimit uint64
	var simulate bool
	var timeout uint
	var contractAddress common.Address
	var safeAddress, safeApi string
	var safeOperationType uint8

	var to0 common.Address
	var to0Raw string
	var value0 *big.Int
	var value0Raw string
	var data []byte
	var dataRaw string
	var operation uint8

	cmd := &cobra.Command{
		Use:   "exec-transaction-from-module",
		Short: "Execute the ExecTransactionFromModule method on a Safe contract",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if contractAddressRaw == "" {
				return fmt.Errorf("--contract not specified")
			} else if !common.IsHexAddress(contractAddressRaw) {
				return fmt.Errorf("--contract is not a valid Ethereum address")
			}
			contractAddress = common.HexToAddress(contractAddressRaw)

			if keyfile == "" {
				return fmt.Errorf("--keystore not specified (this should be a path to an Ethereum account keystore file)")
			}

			if rpc == "" {
				return fmt.Errorf("--rpc not specified (this should be a URL to an Ethereum JSONRPC API)")
			}

			if safeAddress != "" {
				if !common.IsHexAddress(safeAddress) {
					return fmt.Errorf("--safe is not a valid Ethereum address")
				}
				if safeApi == "" {
					client, clientErr := NewClient(rpc)
					if clientErr != nil {
						return clientErr
					}
					chainIDCtx, cancelChainIDCtx := NewChainContext(timeout)
					defer cancelChainIDCtx()
					chainID, chainIDErr := client.ChainID(chainIDCtx)
					if chainIDErr != nil {
						return chainIDErr
					}
					safeApi = fmt.Sprintf("https://safe-client.safe.global/v1/chains/%s/transactions/%s/propose", chainID.String(), safeAddress)
					fmt.Println("--safe-api not specified, using default (", safeApi, ")")
				}

				if SafeOperationType(safeOperationType).String() == "Unknown" {
					return fmt.Errorf("--safe-operation must be 0 (Call) or 1 (DelegateCall)")
				}
			}

			if to0Raw == "" {
				return fmt.Errorf("--to-0 argument not specified")
			} else if !common.IsHexAddress(to0Raw) {
				return fmt.Errorf("--to-0 argument is not a valid Ethereum address")
			}
			to0 = common.HexToAddress(to0Raw)

			if value0Raw == "" {
				return fmt.Errorf("--value-0 argument not specified")
			}
			value0 = new(big.Int)
			value0.SetString(value0Raw, 0)

			var dataIntermediate []byte

			var dataIntermediateHexDecodeErr error
			dataIntermediate, dataIntermediateHexDecodeErr = hex.DecodeString(dataRaw)
			if dataIntermediateHexDecodeErr != nil {
				return dataIntermediateHexDecodeErr
			}

			copy(data[:], dataIntermediate)

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			client, clientErr := NewClient(rpc)
			if clientErr != nil {
				return clientErr
			}

			key, keyErr := KeyFromFile(keyfile, password)
			if keyErr != nil {
				return keyErr
			}

			chainIDCtx, cancelChainIDCtx := NewChainContext(timeout)
			defer cancelChainIDCtx()
			chainID, chainIDErr := client.ChainID(chainIDCtx)
			if chainIDErr != nil {
				return chainIDErr
			}

			transactionOpts, transactionOptsErr := bind.NewKeyedTransactorWithChainID(key.PrivateKey, chainID)
			if transactionOptsErr != nil {
				return transactionOptsErr
			}

			SetTransactionParametersFromArgs(transactionOpts, nonce, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas, gasLimit, simulate)

			contract, contractErr := NewSafe(contractAddress, client)
			if contractErr != nil {
				return contractErr
			}

			session := SafeTransactorSession{
				Contract:     &contract.SafeTransactor,
				TransactOpts: *transactionOpts,
			}

			if safeAddress != "" {
				// Generate transaction data
				transaction, err := session.ExecTransactionFromModule(

					to0,
					value0,
					data,
					operation,
				)

				if err != nil {
					return err
				}

				// Create Safe proposal for transaction
				value := transactionOpts.Value
				if value == nil {
					value = big.NewInt(0)
				}
				err = CreateSafeProposal(client, key, common.HexToAddress(safeAddress), contractAddress, transaction.Data(), value, safeApi, SafeOperationType(safeOperationType))
				if err != nil {
					return fmt.Errorf("failed to create Safe proposal: %v", err)
				}

				return nil
			}

			transaction, err := session.ExecTransactionFromModule(

				to0,
				value0,
				data,
				operation,
			)
			if err != nil {
				return err
			}

			cmd.Printf("Transaction hash: %s\n", transaction.Hash().Hex())
			if transactionOpts.NoSend {
				estimationMessage := ethereum.CallMsg{
					From: transactionOpts.From,
					To:   &contractAddress,
					Data: transaction.Data(),
				}

				gasEstimationCtx, cancelGasEstimationCtx := NewChainContext(timeout)
				defer cancelGasEstimationCtx()

				gasEstimate, gasEstimateErr := client.EstimateGas(gasEstimationCtx, estimationMessage)
				if gasEstimateErr != nil {
					return gasEstimateErr
				}

				transactionBinary, transactionBinaryErr := transaction.MarshalBinary()
				if transactionBinaryErr != nil {
					return transactionBinaryErr
				}
				transactionBinaryHex := hex.EncodeToString(transactionBinary)

				cmd.Printf("Transaction: %s\nEstimated gas: %d\n", transactionBinaryHex, gasEstimate)
			} else {
				cmd.Println("Transaction submitted")
			}

			return nil
		},
	}

	cmd.Flags().StringVar(&rpc, "rpc", "", "URL of the JSONRPC API to use")
	cmd.Flags().StringVar(&keyfile, "keyfile", "", "Path to the keystore file to use for the transaction")
	cmd.Flags().StringVar(&password, "password", "", "Password to use to unlock the keystore (if not specified, you will be prompted for the password when the command executes)")
	cmd.Flags().StringVar(&nonce, "nonce", "", "Nonce to use for the transaction")
	cmd.Flags().StringVar(&value, "value", "", "Value to send with the transaction")
	cmd.Flags().StringVar(&gasPrice, "gas-price", "", "Gas price to use for the transaction")
	cmd.Flags().StringVar(&maxFeePerGas, "max-fee-per-gas", "", "Maximum fee per gas to use for the (EIP-1559) transaction")
	cmd.Flags().StringVar(&maxPriorityFeePerGas, "max-priority-fee-per-gas", "", "Maximum priority fee per gas to use for the (EIP-1559) transaction")
	cmd.Flags().Uint64Var(&gasLimit, "gas-limit", 0, "Gas limit for the transaction")
	cmd.Flags().BoolVar(&simulate, "simulate", false, "Simulate the transaction without sending it")
	cmd.Flags().UintVar(&timeout, "timeout", 60, "Timeout (in seconds) for interactions with the JSONRPC API")
	cmd.Flags().StringVar(&contractAddressRaw, "contract", "", "Address of the contract to interact with")
	cmd.Flags().StringVar(&safeAddress, "safe", "", "Address of the Safe contract")
	cmd.Flags().StringVar(&safeApi, "safe-api", "", "Safe API for the Safe Transaction Service (optional)")
	cmd.Flags().Uint8Var(&safeOperationType, "safe-operation", 0, "Safe operation type: 0 (Call) or 1 (DelegateCall)")

	cmd.Flags().StringVar(&to0Raw, "to-0", "", "to-0 argument (common.Address)")
	cmd.Flags().StringVar(&value0Raw, "value-0", "", "value-0 argument")
	cmd.Flags().StringVar(&dataRaw, "data", "", "data argument ([]byte)")
	cmd.Flags().Uint8Var(&operation, "operation", 0, "operation argument")

	return cmd
}
func CreateExecTransactionFromModuleReturnDataCommand() *cobra.Command {
	var keyfile, nonce, password, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas, rpc, contractAddressRaw string
	var gasLimit uint64
	var simulate bool
	var timeout uint
	var contractAddress common.Address
	var safeAddress, safeApi string
	var safeOperationType uint8

	var to0 common.Address
	var to0Raw string
	var value0 *big.Int
	var value0Raw string
	var data []byte
	var dataRaw string
	var operation uint8

	cmd := &cobra.Command{
		Use:   "exec-transaction-from-module-return-data",
		Short: "Execute the ExecTransactionFromModuleReturnData method on a Safe contract",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if contractAddressRaw == "" {
				return fmt.Errorf("--contract not specified")
			} else if !common.IsHexAddress(contractAddressRaw) {
				return fmt.Errorf("--contract is not a valid Ethereum address")
			}
			contractAddress = common.HexToAddress(contractAddressRaw)

			if keyfile == "" {
				return fmt.Errorf("--keystore not specified (this should be a path to an Ethereum account keystore file)")
			}

			if rpc == "" {
				return fmt.Errorf("--rpc not specified (this should be a URL to an Ethereum JSONRPC API)")
			}

			if safeAddress != "" {
				if !common.IsHexAddress(safeAddress) {
					return fmt.Errorf("--safe is not a valid Ethereum address")
				}
				if safeApi == "" {
					client, clientErr := NewClient(rpc)
					if clientErr != nil {
						return clientErr
					}
					chainIDCtx, cancelChainIDCtx := NewChainContext(timeout)
					defer cancelChainIDCtx()
					chainID, chainIDErr := client.ChainID(chainIDCtx)
					if chainIDErr != nil {
						return chainIDErr
					}
					safeApi = fmt.Sprintf("https://safe-client.safe.global/v1/chains/%s/transactions/%s/propose", chainID.String(), safeAddress)
					fmt.Println("--safe-api not specified, using default (", safeApi, ")")
				}

				if SafeOperationType(safeOperationType).String() == "Unknown" {
					return fmt.Errorf("--safe-operation must be 0 (Call) or 1 (DelegateCall)")
				}
			}

			if to0Raw == "" {
				return fmt.Errorf("--to-0 argument not specified")
			} else if !common.IsHexAddress(to0Raw) {
				return fmt.Errorf("--to-0 argument is not a valid Ethereum address")
			}
			to0 = common.HexToAddress(to0Raw)

			if value0Raw == "" {
				return fmt.Errorf("--value-0 argument not specified")
			}
			value0 = new(big.Int)
			value0.SetString(value0Raw, 0)

			var dataIntermediate []byte

			var dataIntermediateHexDecodeErr error
			dataIntermediate, dataIntermediateHexDecodeErr = hex.DecodeString(dataRaw)
			if dataIntermediateHexDecodeErr != nil {
				return dataIntermediateHexDecodeErr
			}

			copy(data[:], dataIntermediate)

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			client, clientErr := NewClient(rpc)
			if clientErr != nil {
				return clientErr
			}

			key, keyErr := KeyFromFile(keyfile, password)
			if keyErr != nil {
				return keyErr
			}

			chainIDCtx, cancelChainIDCtx := NewChainContext(timeout)
			defer cancelChainIDCtx()
			chainID, chainIDErr := client.ChainID(chainIDCtx)
			if chainIDErr != nil {
				return chainIDErr
			}

			transactionOpts, transactionOptsErr := bind.NewKeyedTransactorWithChainID(key.PrivateKey, chainID)
			if transactionOptsErr != nil {
				return transactionOptsErr
			}

			SetTransactionParametersFromArgs(transactionOpts, nonce, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas, gasLimit, simulate)

			contract, contractErr := NewSafe(contractAddress, client)
			if contractErr != nil {
				return contractErr
			}

			session := SafeTransactorSession{
				Contract:     &contract.SafeTransactor,
				TransactOpts: *transactionOpts,
			}

			if safeAddress != "" {
				// Generate transaction data
				transaction, err := session.ExecTransactionFromModuleReturnData(

					to0,
					value0,
					data,
					operation,
				)

				if err != nil {
					return err
				}

				// Create Safe proposal for transaction
				value := transactionOpts.Value
				if value == nil {
					value = big.NewInt(0)
				}
				err = CreateSafeProposal(client, key, common.HexToAddress(safeAddress), contractAddress, transaction.Data(), value, safeApi, SafeOperationType(safeOperationType))
				if err != nil {
					return fmt.Errorf("failed to create Safe proposal: %v", err)
				}

				return nil
			}

			transaction, err := session.ExecTransactionFromModuleReturnData(

				to0,
				value0,
				data,
				operation,
			)
			if err != nil {
				return err
			}

			cmd.Printf("Transaction hash: %s\n", transaction.Hash().Hex())
			if transactionOpts.NoSend {
				estimationMessage := ethereum.CallMsg{
					From: transactionOpts.From,
					To:   &contractAddress,
					Data: transaction.Data(),
				}

				gasEstimationCtx, cancelGasEstimationCtx := NewChainContext(timeout)
				defer cancelGasEstimationCtx()

				gasEstimate, gasEstimateErr := client.EstimateGas(gasEstimationCtx, estimationMessage)
				if gasEstimateErr != nil {
					return gasEstimateErr
				}

				transactionBinary, transactionBinaryErr := transaction.MarshalBinary()
				if transactionBinaryErr != nil {
					return transactionBinaryErr
				}
				transactionBinaryHex := hex.EncodeToString(transactionBinary)

				cmd.Printf("Transaction: %s\nEstimated gas: %d\n", transactionBinaryHex, gasEstimate)
			} else {
				cmd.Println("Transaction submitted")
			}

			return nil
		},
	}

	cmd.Flags().StringVar(&rpc, "rpc", "", "URL of the JSONRPC API to use")
	cmd.Flags().StringVar(&keyfile, "keyfile", "", "Path to the keystore file to use for the transaction")
	cmd.Flags().StringVar(&password, "password", "", "Password to use to unlock the keystore (if not specified, you will be prompted for the password when the command executes)")
	cmd.Flags().StringVar(&nonce, "nonce", "", "Nonce to use for the transaction")
	cmd.Flags().StringVar(&value, "value", "", "Value to send with the transaction")
	cmd.Flags().StringVar(&gasPrice, "gas-price", "", "Gas price to use for the transaction")
	cmd.Flags().StringVar(&maxFeePerGas, "max-fee-per-gas", "", "Maximum fee per gas to use for the (EIP-1559) transaction")
	cmd.Flags().StringVar(&maxPriorityFeePerGas, "max-priority-fee-per-gas", "", "Maximum priority fee per gas to use for the (EIP-1559) transaction")
	cmd.Flags().Uint64Var(&gasLimit, "gas-limit", 0, "Gas limit for the transaction")
	cmd.Flags().BoolVar(&simulate, "simulate", false, "Simulate the transaction without sending it")
	cmd.Flags().UintVar(&timeout, "timeout", 60, "Timeout (in seconds) for interactions with the JSONRPC API")
	cmd.Flags().StringVar(&contractAddressRaw, "contract", "", "Address of the contract to interact with")
	cmd.Flags().StringVar(&safeAddress, "safe", "", "Address of the Safe contract")
	cmd.Flags().StringVar(&safeApi, "safe-api", "", "Safe API for the Safe Transaction Service (optional)")
	cmd.Flags().Uint8Var(&safeOperationType, "safe-operation", 0, "Safe operation type: 0 (Call) or 1 (DelegateCall)")

	cmd.Flags().StringVar(&to0Raw, "to-0", "", "to-0 argument (common.Address)")
	cmd.Flags().StringVar(&value0Raw, "value-0", "", "value-0 argument")
	cmd.Flags().StringVar(&dataRaw, "data", "", "data argument ([]byte)")
	cmd.Flags().Uint8Var(&operation, "operation", 0, "operation argument")

	return cmd
}
func CreateFallbackCommand() *cobra.Command {
	var keyfile, nonce, password, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas, rpc, contractAddressRaw string
	var gasLimit uint64
	var simulate bool
	var timeout uint
	var contractAddress common.Address
	var safeAddress, safeApi string
	var safeOperationType uint8

	var calldata []byte
	var calldataRaw string

	cmd := &cobra.Command{
		Use:   "fallback",
		Short: "Execute the Fallback method on a Safe contract",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if contractAddressRaw == "" {
				return fmt.Errorf("--contract not specified")
			} else if !common.IsHexAddress(contractAddressRaw) {
				return fmt.Errorf("--contract is not a valid Ethereum address")
			}
			contractAddress = common.HexToAddress(contractAddressRaw)

			if keyfile == "" {
				return fmt.Errorf("--keystore not specified (this should be a path to an Ethereum account keystore file)")
			}

			if rpc == "" {
				return fmt.Errorf("--rpc not specified (this should be a URL to an Ethereum JSONRPC API)")
			}

			if safeAddress != "" {
				if !common.IsHexAddress(safeAddress) {
					return fmt.Errorf("--safe is not a valid Ethereum address")
				}
				if safeApi == "" {
					client, clientErr := NewClient(rpc)
					if clientErr != nil {
						return clientErr
					}
					chainIDCtx, cancelChainIDCtx := NewChainContext(timeout)
					defer cancelChainIDCtx()
					chainID, chainIDErr := client.ChainID(chainIDCtx)
					if chainIDErr != nil {
						return chainIDErr
					}
					safeApi = fmt.Sprintf("https://safe-client.safe.global/v1/chains/%s/transactions/%s/propose", chainID.String(), safeAddress)
					fmt.Println("--safe-api not specified, using default (", safeApi, ")")
				}

				if SafeOperationType(safeOperationType).String() == "Unknown" {
					return fmt.Errorf("--safe-operation must be 0 (Call) or 1 (DelegateCall)")
				}
			}

			var calldataIntermediate []byte

			var calldataIntermediateHexDecodeErr error
			calldataIntermediate, calldataIntermediateHexDecodeErr = hex.DecodeString(calldataRaw)
			if calldataIntermediateHexDecodeErr != nil {
				return calldataIntermediateHexDecodeErr
			}

			copy(calldata[:], calldataIntermediate)

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			client, clientErr := NewClient(rpc)
			if clientErr != nil {
				return clientErr
			}

			key, keyErr := KeyFromFile(keyfile, password)
			if keyErr != nil {
				return keyErr
			}

			chainIDCtx, cancelChainIDCtx := NewChainContext(timeout)
			defer cancelChainIDCtx()
			chainID, chainIDErr := client.ChainID(chainIDCtx)
			if chainIDErr != nil {
				return chainIDErr
			}

			transactionOpts, transactionOptsErr := bind.NewKeyedTransactorWithChainID(key.PrivateKey, chainID)
			if transactionOptsErr != nil {
				return transactionOptsErr
			}

			SetTransactionParametersFromArgs(transactionOpts, nonce, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas, gasLimit, simulate)

			contract, contractErr := NewSafe(contractAddress, client)
			if contractErr != nil {
				return contractErr
			}

			session := SafeTransactorSession{
				Contract:     &contract.SafeTransactor,
				TransactOpts: *transactionOpts,
			}

			if safeAddress != "" {
				// Generate transaction data
				transaction, err := session.Fallback(

					calldata,
				)

				if err != nil {
					return err
				}

				// Create Safe proposal for transaction
				value := transactionOpts.Value
				if value == nil {
					value = big.NewInt(0)
				}
				err = CreateSafeProposal(client, key, common.HexToAddress(safeAddress), contractAddress, transaction.Data(), value, safeApi, SafeOperationType(safeOperationType))
				if err != nil {
					return fmt.Errorf("failed to create Safe proposal: %v", err)
				}

				return nil
			}

			transaction, err := session.Fallback(

				calldata,
			)
			if err != nil {
				return err
			}

			cmd.Printf("Transaction hash: %s\n", transaction.Hash().Hex())
			if transactionOpts.NoSend {
				estimationMessage := ethereum.CallMsg{
					From: transactionOpts.From,
					To:   &contractAddress,
					Data: transaction.Data(),
				}

				gasEstimationCtx, cancelGasEstimationCtx := NewChainContext(timeout)
				defer cancelGasEstimationCtx()

				gasEstimate, gasEstimateErr := client.EstimateGas(gasEstimationCtx, estimationMessage)
				if gasEstimateErr != nil {
					return gasEstimateErr
				}

				transactionBinary, transactionBinaryErr := transaction.MarshalBinary()
				if transactionBinaryErr != nil {
					return transactionBinaryErr
				}
				transactionBinaryHex := hex.EncodeToString(transactionBinary)

				cmd.Printf("Transaction: %s\nEstimated gas: %d\n", transactionBinaryHex, gasEstimate)
			} else {
				cmd.Println("Transaction submitted")
			}

			return nil
		},
	}

	cmd.Flags().StringVar(&rpc, "rpc", "", "URL of the JSONRPC API to use")
	cmd.Flags().StringVar(&keyfile, "keyfile", "", "Path to the keystore file to use for the transaction")
	cmd.Flags().StringVar(&password, "password", "", "Password to use to unlock the keystore (if not specified, you will be prompted for the password when the command executes)")
	cmd.Flags().StringVar(&nonce, "nonce", "", "Nonce to use for the transaction")
	cmd.Flags().StringVar(&value, "value", "", "Value to send with the transaction")
	cmd.Flags().StringVar(&gasPrice, "gas-price", "", "Gas price to use for the transaction")
	cmd.Flags().StringVar(&maxFeePerGas, "max-fee-per-gas", "", "Maximum fee per gas to use for the (EIP-1559) transaction")
	cmd.Flags().StringVar(&maxPriorityFeePerGas, "max-priority-fee-per-gas", "", "Maximum priority fee per gas to use for the (EIP-1559) transaction")
	cmd.Flags().Uint64Var(&gasLimit, "gas-limit", 0, "Gas limit for the transaction")
	cmd.Flags().BoolVar(&simulate, "simulate", false, "Simulate the transaction without sending it")
	cmd.Flags().UintVar(&timeout, "timeout", 60, "Timeout (in seconds) for interactions with the JSONRPC API")
	cmd.Flags().StringVar(&contractAddressRaw, "contract", "", "Address of the contract to interact with")
	cmd.Flags().StringVar(&safeAddress, "safe", "", "Address of the Safe contract")
	cmd.Flags().StringVar(&safeApi, "safe-api", "", "Safe API for the Safe Transaction Service (optional)")
	cmd.Flags().Uint8Var(&safeOperationType, "safe-operation", 0, "Safe operation type: 0 (Call) or 1 (DelegateCall)")

	cmd.Flags().StringVar(&calldataRaw, "calldata", "", "calldata argument ([]byte)")

	return cmd
}
func CreateReceiveCommand() *cobra.Command {
	var keyfile, nonce, password, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas, rpc, contractAddressRaw string
	var gasLimit uint64
	var simulate bool
	var timeout uint
	var contractAddress common.Address
	var safeAddress, safeApi string
	var safeOperationType uint8

	cmd := &cobra.Command{
		Use:   "receive",
		Short: "Execute the Receive method on a Safe contract",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if contractAddressRaw == "" {
				return fmt.Errorf("--contract not specified")
			} else if !common.IsHexAddress(contractAddressRaw) {
				return fmt.Errorf("--contract is not a valid Ethereum address")
			}
			contractAddress = common.HexToAddress(contractAddressRaw)

			if keyfile == "" {
				return fmt.Errorf("--keystore not specified (this should be a path to an Ethereum account keystore file)")
			}

			if rpc == "" {
				return fmt.Errorf("--rpc not specified (this should be a URL to an Ethereum JSONRPC API)")
			}

			if safeAddress != "" {
				if !common.IsHexAddress(safeAddress) {
					return fmt.Errorf("--safe is not a valid Ethereum address")
				}
				if safeApi == "" {
					client, clientErr := NewClient(rpc)
					if clientErr != nil {
						return clientErr
					}
					chainIDCtx, cancelChainIDCtx := NewChainContext(timeout)
					defer cancelChainIDCtx()
					chainID, chainIDErr := client.ChainID(chainIDCtx)
					if chainIDErr != nil {
						return chainIDErr
					}
					safeApi = fmt.Sprintf("https://safe-client.safe.global/v1/chains/%s/transactions/%s/propose", chainID.String(), safeAddress)
					fmt.Println("--safe-api not specified, using default (", safeApi, ")")
				}

				if SafeOperationType(safeOperationType).String() == "Unknown" {
					return fmt.Errorf("--safe-operation must be 0 (Call) or 1 (DelegateCall)")
				}
			}

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			client, clientErr := NewClient(rpc)
			if clientErr != nil {
				return clientErr
			}

			key, keyErr := KeyFromFile(keyfile, password)
			if keyErr != nil {
				return keyErr
			}

			chainIDCtx, cancelChainIDCtx := NewChainContext(timeout)
			defer cancelChainIDCtx()
			chainID, chainIDErr := client.ChainID(chainIDCtx)
			if chainIDErr != nil {
				return chainIDErr
			}

			transactionOpts, transactionOptsErr := bind.NewKeyedTransactorWithChainID(key.PrivateKey, chainID)
			if transactionOptsErr != nil {
				return transactionOptsErr
			}

			SetTransactionParametersFromArgs(transactionOpts, nonce, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas, gasLimit, simulate)

			contract, contractErr := NewSafe(contractAddress, client)
			if contractErr != nil {
				return contractErr
			}

			session := SafeTransactorSession{
				Contract:     &contract.SafeTransactor,
				TransactOpts: *transactionOpts,
			}

			if safeAddress != "" {
				// Generate transaction data
				transaction, err := session.Receive()

				if err != nil {
					return err
				}

				// Create Safe proposal for transaction
				value := transactionOpts.Value
				if value == nil {
					value = big.NewInt(0)
				}
				err = CreateSafeProposal(client, key, common.HexToAddress(safeAddress), contractAddress, transaction.Data(), value, safeApi, SafeOperationType(safeOperationType))
				if err != nil {
					return fmt.Errorf("failed to create Safe proposal: %v", err)
				}

				return nil
			}

			transaction, err := session.Receive()
			if err != nil {
				return err
			}

			cmd.Printf("Transaction hash: %s\n", transaction.Hash().Hex())
			if transactionOpts.NoSend {
				estimationMessage := ethereum.CallMsg{
					From: transactionOpts.From,
					To:   &contractAddress,
					Data: transaction.Data(),
				}

				gasEstimationCtx, cancelGasEstimationCtx := NewChainContext(timeout)
				defer cancelGasEstimationCtx()

				gasEstimate, gasEstimateErr := client.EstimateGas(gasEstimationCtx, estimationMessage)
				if gasEstimateErr != nil {
					return gasEstimateErr
				}

				transactionBinary, transactionBinaryErr := transaction.MarshalBinary()
				if transactionBinaryErr != nil {
					return transactionBinaryErr
				}
				transactionBinaryHex := hex.EncodeToString(transactionBinary)

				cmd.Printf("Transaction: %s\nEstimated gas: %d\n", transactionBinaryHex, gasEstimate)
			} else {
				cmd.Println("Transaction submitted")
			}

			return nil
		},
	}

	cmd.Flags().StringVar(&rpc, "rpc", "", "URL of the JSONRPC API to use")
	cmd.Flags().StringVar(&keyfile, "keyfile", "", "Path to the keystore file to use for the transaction")
	cmd.Flags().StringVar(&password, "password", "", "Password to use to unlock the keystore (if not specified, you will be prompted for the password when the command executes)")
	cmd.Flags().StringVar(&nonce, "nonce", "", "Nonce to use for the transaction")
	cmd.Flags().StringVar(&value, "value", "", "Value to send with the transaction")
	cmd.Flags().StringVar(&gasPrice, "gas-price", "", "Gas price to use for the transaction")
	cmd.Flags().StringVar(&maxFeePerGas, "max-fee-per-gas", "", "Maximum fee per gas to use for the (EIP-1559) transaction")
	cmd.Flags().StringVar(&maxPriorityFeePerGas, "max-priority-fee-per-gas", "", "Maximum priority fee per gas to use for the (EIP-1559) transaction")
	cmd.Flags().Uint64Var(&gasLimit, "gas-limit", 0, "Gas limit for the transaction")
	cmd.Flags().BoolVar(&simulate, "simulate", false, "Simulate the transaction without sending it")
	cmd.Flags().UintVar(&timeout, "timeout", 60, "Timeout (in seconds) for interactions with the JSONRPC API")
	cmd.Flags().StringVar(&contractAddressRaw, "contract", "", "Address of the contract to interact with")
	cmd.Flags().StringVar(&safeAddress, "safe", "", "Address of the Safe contract")
	cmd.Flags().StringVar(&safeApi, "safe-api", "", "Safe API for the Safe Transaction Service (optional)")
	cmd.Flags().Uint8Var(&safeOperationType, "safe-operation", 0, "Safe operation type: 0 (Call) or 1 (DelegateCall)")

	return cmd
}
func CreateRemoveOwnerCommand() *cobra.Command {
	var keyfile, nonce, password, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas, rpc, contractAddressRaw string
	var gasLimit uint64
	var simulate bool
	var timeout uint
	var contractAddress common.Address
	var safeAddress, safeApi string
	var safeOperationType uint8

	var prevOwner common.Address
	var prevOwnerRaw string
	var owner common.Address
	var ownerRaw string
	var threshold *big.Int
	var thresholdRaw string

	cmd := &cobra.Command{
		Use:   "remove-owner",
		Short: "Execute the RemoveOwner method on a Safe contract",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if contractAddressRaw == "" {
				return fmt.Errorf("--contract not specified")
			} else if !common.IsHexAddress(contractAddressRaw) {
				return fmt.Errorf("--contract is not a valid Ethereum address")
			}
			contractAddress = common.HexToAddress(contractAddressRaw)

			if keyfile == "" {
				return fmt.Errorf("--keystore not specified (this should be a path to an Ethereum account keystore file)")
			}

			if rpc == "" {
				return fmt.Errorf("--rpc not specified (this should be a URL to an Ethereum JSONRPC API)")
			}

			if safeAddress != "" {
				if !common.IsHexAddress(safeAddress) {
					return fmt.Errorf("--safe is not a valid Ethereum address")
				}
				if safeApi == "" {
					client, clientErr := NewClient(rpc)
					if clientErr != nil {
						return clientErr
					}
					chainIDCtx, cancelChainIDCtx := NewChainContext(timeout)
					defer cancelChainIDCtx()
					chainID, chainIDErr := client.ChainID(chainIDCtx)
					if chainIDErr != nil {
						return chainIDErr
					}
					safeApi = fmt.Sprintf("https://safe-client.safe.global/v1/chains/%s/transactions/%s/propose", chainID.String(), safeAddress)
					fmt.Println("--safe-api not specified, using default (", safeApi, ")")
				}

				if SafeOperationType(safeOperationType).String() == "Unknown" {
					return fmt.Errorf("--safe-operation must be 0 (Call) or 1 (DelegateCall)")
				}
			}

			if prevOwnerRaw == "" {
				return fmt.Errorf("--prev-owner argument not specified")
			} else if !common.IsHexAddress(prevOwnerRaw) {
				return fmt.Errorf("--prev-owner argument is not a valid Ethereum address")
			}
			prevOwner = common.HexToAddress(prevOwnerRaw)

			if ownerRaw == "" {
				return fmt.Errorf("--owner argument not specified")
			} else if !common.IsHexAddress(ownerRaw) {
				return fmt.Errorf("--owner argument is not a valid Ethereum address")
			}
			owner = common.HexToAddress(ownerRaw)

			if thresholdRaw == "" {
				return fmt.Errorf("--threshold argument not specified")
			}
			threshold = new(big.Int)
			threshold.SetString(thresholdRaw, 0)

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			client, clientErr := NewClient(rpc)
			if clientErr != nil {
				return clientErr
			}

			key, keyErr := KeyFromFile(keyfile, password)
			if keyErr != nil {
				return keyErr
			}

			chainIDCtx, cancelChainIDCtx := NewChainContext(timeout)
			defer cancelChainIDCtx()
			chainID, chainIDErr := client.ChainID(chainIDCtx)
			if chainIDErr != nil {
				return chainIDErr
			}

			transactionOpts, transactionOptsErr := bind.NewKeyedTransactorWithChainID(key.PrivateKey, chainID)
			if transactionOptsErr != nil {
				return transactionOptsErr
			}

			SetTransactionParametersFromArgs(transactionOpts, nonce, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas, gasLimit, simulate)

			contract, contractErr := NewSafe(contractAddress, client)
			if contractErr != nil {
				return contractErr
			}

			session := SafeTransactorSession{
				Contract:     &contract.SafeTransactor,
				TransactOpts: *transactionOpts,
			}

			if safeAddress != "" {
				// Generate transaction data
				transaction, err := session.RemoveOwner(

					prevOwner,
					owner,
					threshold,
				)

				if err != nil {
					return err
				}

				// Create Safe proposal for transaction
				value := transactionOpts.Value
				if value == nil {
					value = big.NewInt(0)
				}
				err = CreateSafeProposal(client, key, common.HexToAddress(safeAddress), contractAddress, transaction.Data(), value, safeApi, SafeOperationType(safeOperationType))
				if err != nil {
					return fmt.Errorf("failed to create Safe proposal: %v", err)
				}

				return nil
			}

			transaction, err := session.RemoveOwner(

				prevOwner,
				owner,
				threshold,
			)
			if err != nil {
				return err
			}

			cmd.Printf("Transaction hash: %s\n", transaction.Hash().Hex())
			if transactionOpts.NoSend {
				estimationMessage := ethereum.CallMsg{
					From: transactionOpts.From,
					To:   &contractAddress,
					Data: transaction.Data(),
				}

				gasEstimationCtx, cancelGasEstimationCtx := NewChainContext(timeout)
				defer cancelGasEstimationCtx()

				gasEstimate, gasEstimateErr := client.EstimateGas(gasEstimationCtx, estimationMessage)
				if gasEstimateErr != nil {
					return gasEstimateErr
				}

				transactionBinary, transactionBinaryErr := transaction.MarshalBinary()
				if transactionBinaryErr != nil {
					return transactionBinaryErr
				}
				transactionBinaryHex := hex.EncodeToString(transactionBinary)

				cmd.Printf("Transaction: %s\nEstimated gas: %d\n", transactionBinaryHex, gasEstimate)
			} else {
				cmd.Println("Transaction submitted")
			}

			return nil
		},
	}

	cmd.Flags().StringVar(&rpc, "rpc", "", "URL of the JSONRPC API to use")
	cmd.Flags().StringVar(&keyfile, "keyfile", "", "Path to the keystore file to use for the transaction")
	cmd.Flags().StringVar(&password, "password", "", "Password to use to unlock the keystore (if not specified, you will be prompted for the password when the command executes)")
	cmd.Flags().StringVar(&nonce, "nonce", "", "Nonce to use for the transaction")
	cmd.Flags().StringVar(&value, "value", "", "Value to send with the transaction")
	cmd.Flags().StringVar(&gasPrice, "gas-price", "", "Gas price to use for the transaction")
	cmd.Flags().StringVar(&maxFeePerGas, "max-fee-per-gas", "", "Maximum fee per gas to use for the (EIP-1559) transaction")
	cmd.Flags().StringVar(&maxPriorityFeePerGas, "max-priority-fee-per-gas", "", "Maximum priority fee per gas to use for the (EIP-1559) transaction")
	cmd.Flags().Uint64Var(&gasLimit, "gas-limit", 0, "Gas limit for the transaction")
	cmd.Flags().BoolVar(&simulate, "simulate", false, "Simulate the transaction without sending it")
	cmd.Flags().UintVar(&timeout, "timeout", 60, "Timeout (in seconds) for interactions with the JSONRPC API")
	cmd.Flags().StringVar(&contractAddressRaw, "contract", "", "Address of the contract to interact with")
	cmd.Flags().StringVar(&safeAddress, "safe", "", "Address of the Safe contract")
	cmd.Flags().StringVar(&safeApi, "safe-api", "", "Safe API for the Safe Transaction Service (optional)")
	cmd.Flags().Uint8Var(&safeOperationType, "safe-operation", 0, "Safe operation type: 0 (Call) or 1 (DelegateCall)")

	cmd.Flags().StringVar(&prevOwnerRaw, "prev-owner", "", "prev-owner argument (common.Address)")
	cmd.Flags().StringVar(&ownerRaw, "owner", "", "owner argument (common.Address)")
	cmd.Flags().StringVar(&thresholdRaw, "threshold", "", "threshold argument")

	return cmd
}
func CreateSetFallbackHandlerCommand() *cobra.Command {
	var keyfile, nonce, password, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas, rpc, contractAddressRaw string
	var gasLimit uint64
	var simulate bool
	var timeout uint
	var contractAddress common.Address
	var safeAddress, safeApi string
	var safeOperationType uint8

	var handler common.Address
	var handlerRaw string

	cmd := &cobra.Command{
		Use:   "set-fallback-handler",
		Short: "Execute the SetFallbackHandler method on a Safe contract",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if contractAddressRaw == "" {
				return fmt.Errorf("--contract not specified")
			} else if !common.IsHexAddress(contractAddressRaw) {
				return fmt.Errorf("--contract is not a valid Ethereum address")
			}
			contractAddress = common.HexToAddress(contractAddressRaw)

			if keyfile == "" {
				return fmt.Errorf("--keystore not specified (this should be a path to an Ethereum account keystore file)")
			}

			if rpc == "" {
				return fmt.Errorf("--rpc not specified (this should be a URL to an Ethereum JSONRPC API)")
			}

			if safeAddress != "" {
				if !common.IsHexAddress(safeAddress) {
					return fmt.Errorf("--safe is not a valid Ethereum address")
				}
				if safeApi == "" {
					client, clientErr := NewClient(rpc)
					if clientErr != nil {
						return clientErr
					}
					chainIDCtx, cancelChainIDCtx := NewChainContext(timeout)
					defer cancelChainIDCtx()
					chainID, chainIDErr := client.ChainID(chainIDCtx)
					if chainIDErr != nil {
						return chainIDErr
					}
					safeApi = fmt.Sprintf("https://safe-client.safe.global/v1/chains/%s/transactions/%s/propose", chainID.String(), safeAddress)
					fmt.Println("--safe-api not specified, using default (", safeApi, ")")
				}

				if SafeOperationType(safeOperationType).String() == "Unknown" {
					return fmt.Errorf("--safe-operation must be 0 (Call) or 1 (DelegateCall)")
				}
			}

			if handlerRaw == "" {
				return fmt.Errorf("--handler argument not specified")
			} else if !common.IsHexAddress(handlerRaw) {
				return fmt.Errorf("--handler argument is not a valid Ethereum address")
			}
			handler = common.HexToAddress(handlerRaw)

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			client, clientErr := NewClient(rpc)
			if clientErr != nil {
				return clientErr
			}

			key, keyErr := KeyFromFile(keyfile, password)
			if keyErr != nil {
				return keyErr
			}

			chainIDCtx, cancelChainIDCtx := NewChainContext(timeout)
			defer cancelChainIDCtx()
			chainID, chainIDErr := client.ChainID(chainIDCtx)
			if chainIDErr != nil {
				return chainIDErr
			}

			transactionOpts, transactionOptsErr := bind.NewKeyedTransactorWithChainID(key.PrivateKey, chainID)
			if transactionOptsErr != nil {
				return transactionOptsErr
			}

			SetTransactionParametersFromArgs(transactionOpts, nonce, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas, gasLimit, simulate)

			contract, contractErr := NewSafe(contractAddress, client)
			if contractErr != nil {
				return contractErr
			}

			session := SafeTransactorSession{
				Contract:     &contract.SafeTransactor,
				TransactOpts: *transactionOpts,
			}

			if safeAddress != "" {
				// Generate transaction data
				transaction, err := session.SetFallbackHandler(

					handler,
				)

				if err != nil {
					return err
				}

				// Create Safe proposal for transaction
				value := transactionOpts.Value
				if value == nil {
					value = big.NewInt(0)
				}
				err = CreateSafeProposal(client, key, common.HexToAddress(safeAddress), contractAddress, transaction.Data(), value, safeApi, SafeOperationType(safeOperationType))
				if err != nil {
					return fmt.Errorf("failed to create Safe proposal: %v", err)
				}

				return nil
			}

			transaction, err := session.SetFallbackHandler(

				handler,
			)
			if err != nil {
				return err
			}

			cmd.Printf("Transaction hash: %s\n", transaction.Hash().Hex())
			if transactionOpts.NoSend {
				estimationMessage := ethereum.CallMsg{
					From: transactionOpts.From,
					To:   &contractAddress,
					Data: transaction.Data(),
				}

				gasEstimationCtx, cancelGasEstimationCtx := NewChainContext(timeout)
				defer cancelGasEstimationCtx()

				gasEstimate, gasEstimateErr := client.EstimateGas(gasEstimationCtx, estimationMessage)
				if gasEstimateErr != nil {
					return gasEstimateErr
				}

				transactionBinary, transactionBinaryErr := transaction.MarshalBinary()
				if transactionBinaryErr != nil {
					return transactionBinaryErr
				}
				transactionBinaryHex := hex.EncodeToString(transactionBinary)

				cmd.Printf("Transaction: %s\nEstimated gas: %d\n", transactionBinaryHex, gasEstimate)
			} else {
				cmd.Println("Transaction submitted")
			}

			return nil
		},
	}

	cmd.Flags().StringVar(&rpc, "rpc", "", "URL of the JSONRPC API to use")
	cmd.Flags().StringVar(&keyfile, "keyfile", "", "Path to the keystore file to use for the transaction")
	cmd.Flags().StringVar(&password, "password", "", "Password to use to unlock the keystore (if not specified, you will be prompted for the password when the command executes)")
	cmd.Flags().StringVar(&nonce, "nonce", "", "Nonce to use for the transaction")
	cmd.Flags().StringVar(&value, "value", "", "Value to send with the transaction")
	cmd.Flags().StringVar(&gasPrice, "gas-price", "", "Gas price to use for the transaction")
	cmd.Flags().StringVar(&maxFeePerGas, "max-fee-per-gas", "", "Maximum fee per gas to use for the (EIP-1559) transaction")
	cmd.Flags().StringVar(&maxPriorityFeePerGas, "max-priority-fee-per-gas", "", "Maximum priority fee per gas to use for the (EIP-1559) transaction")
	cmd.Flags().Uint64Var(&gasLimit, "gas-limit", 0, "Gas limit for the transaction")
	cmd.Flags().BoolVar(&simulate, "simulate", false, "Simulate the transaction without sending it")
	cmd.Flags().UintVar(&timeout, "timeout", 60, "Timeout (in seconds) for interactions with the JSONRPC API")
	cmd.Flags().StringVar(&contractAddressRaw, "contract", "", "Address of the contract to interact with")
	cmd.Flags().StringVar(&safeAddress, "safe", "", "Address of the Safe contract")
	cmd.Flags().StringVar(&safeApi, "safe-api", "", "Safe API for the Safe Transaction Service (optional)")
	cmd.Flags().Uint8Var(&safeOperationType, "safe-operation", 0, "Safe operation type: 0 (Call) or 1 (DelegateCall)")

	cmd.Flags().StringVar(&handlerRaw, "handler", "", "handler argument (common.Address)")

	return cmd
}
func CreateSetGuardCommand() *cobra.Command {
	var keyfile, nonce, password, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas, rpc, contractAddressRaw string
	var gasLimit uint64
	var simulate bool
	var timeout uint
	var contractAddress common.Address
	var safeAddress, safeApi string
	var safeOperationType uint8

	var guard common.Address
	var guardRaw string

	cmd := &cobra.Command{
		Use:   "set-guard",
		Short: "Execute the SetGuard method on a Safe contract",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if contractAddressRaw == "" {
				return fmt.Errorf("--contract not specified")
			} else if !common.IsHexAddress(contractAddressRaw) {
				return fmt.Errorf("--contract is not a valid Ethereum address")
			}
			contractAddress = common.HexToAddress(contractAddressRaw)

			if keyfile == "" {
				return fmt.Errorf("--keystore not specified (this should be a path to an Ethereum account keystore file)")
			}

			if rpc == "" {
				return fmt.Errorf("--rpc not specified (this should be a URL to an Ethereum JSONRPC API)")
			}

			if safeAddress != "" {
				if !common.IsHexAddress(safeAddress) {
					return fmt.Errorf("--safe is not a valid Ethereum address")
				}
				if safeApi == "" {
					client, clientErr := NewClient(rpc)
					if clientErr != nil {
						return clientErr
					}
					chainIDCtx, cancelChainIDCtx := NewChainContext(timeout)
					defer cancelChainIDCtx()
					chainID, chainIDErr := client.ChainID(chainIDCtx)
					if chainIDErr != nil {
						return chainIDErr
					}
					safeApi = fmt.Sprintf("https://safe-client.safe.global/v1/chains/%s/transactions/%s/propose", chainID.String(), safeAddress)
					fmt.Println("--safe-api not specified, using default (", safeApi, ")")
				}

				if SafeOperationType(safeOperationType).String() == "Unknown" {
					return fmt.Errorf("--safe-operation must be 0 (Call) or 1 (DelegateCall)")
				}
			}

			if guardRaw == "" {
				return fmt.Errorf("--guard argument not specified")
			} else if !common.IsHexAddress(guardRaw) {
				return fmt.Errorf("--guard argument is not a valid Ethereum address")
			}
			guard = common.HexToAddress(guardRaw)

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			client, clientErr := NewClient(rpc)
			if clientErr != nil {
				return clientErr
			}

			key, keyErr := KeyFromFile(keyfile, password)
			if keyErr != nil {
				return keyErr
			}

			chainIDCtx, cancelChainIDCtx := NewChainContext(timeout)
			defer cancelChainIDCtx()
			chainID, chainIDErr := client.ChainID(chainIDCtx)
			if chainIDErr != nil {
				return chainIDErr
			}

			transactionOpts, transactionOptsErr := bind.NewKeyedTransactorWithChainID(key.PrivateKey, chainID)
			if transactionOptsErr != nil {
				return transactionOptsErr
			}

			SetTransactionParametersFromArgs(transactionOpts, nonce, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas, gasLimit, simulate)

			contract, contractErr := NewSafe(contractAddress, client)
			if contractErr != nil {
				return contractErr
			}

			session := SafeTransactorSession{
				Contract:     &contract.SafeTransactor,
				TransactOpts: *transactionOpts,
			}

			if safeAddress != "" {
				// Generate transaction data
				transaction, err := session.SetGuard(

					guard,
				)

				if err != nil {
					return err
				}

				// Create Safe proposal for transaction
				value := transactionOpts.Value
				if value == nil {
					value = big.NewInt(0)
				}
				err = CreateSafeProposal(client, key, common.HexToAddress(safeAddress), contractAddress, transaction.Data(), value, safeApi, SafeOperationType(safeOperationType))
				if err != nil {
					return fmt.Errorf("failed to create Safe proposal: %v", err)
				}

				return nil
			}

			transaction, err := session.SetGuard(

				guard,
			)
			if err != nil {
				return err
			}

			cmd.Printf("Transaction hash: %s\n", transaction.Hash().Hex())
			if transactionOpts.NoSend {
				estimationMessage := ethereum.CallMsg{
					From: transactionOpts.From,
					To:   &contractAddress,
					Data: transaction.Data(),
				}

				gasEstimationCtx, cancelGasEstimationCtx := NewChainContext(timeout)
				defer cancelGasEstimationCtx()

				gasEstimate, gasEstimateErr := client.EstimateGas(gasEstimationCtx, estimationMessage)
				if gasEstimateErr != nil {
					return gasEstimateErr
				}

				transactionBinary, transactionBinaryErr := transaction.MarshalBinary()
				if transactionBinaryErr != nil {
					return transactionBinaryErr
				}
				transactionBinaryHex := hex.EncodeToString(transactionBinary)

				cmd.Printf("Transaction: %s\nEstimated gas: %d\n", transactionBinaryHex, gasEstimate)
			} else {
				cmd.Println("Transaction submitted")
			}

			return nil
		},
	}

	cmd.Flags().StringVar(&rpc, "rpc", "", "URL of the JSONRPC API to use")
	cmd.Flags().StringVar(&keyfile, "keyfile", "", "Path to the keystore file to use for the transaction")
	cmd.Flags().StringVar(&password, "password", "", "Password to use to unlock the keystore (if not specified, you will be prompted for the password when the command executes)")
	cmd.Flags().StringVar(&nonce, "nonce", "", "Nonce to use for the transaction")
	cmd.Flags().StringVar(&value, "value", "", "Value to send with the transaction")
	cmd.Flags().StringVar(&gasPrice, "gas-price", "", "Gas price to use for the transaction")
	cmd.Flags().StringVar(&maxFeePerGas, "max-fee-per-gas", "", "Maximum fee per gas to use for the (EIP-1559) transaction")
	cmd.Flags().StringVar(&maxPriorityFeePerGas, "max-priority-fee-per-gas", "", "Maximum priority fee per gas to use for the (EIP-1559) transaction")
	cmd.Flags().Uint64Var(&gasLimit, "gas-limit", 0, "Gas limit for the transaction")
	cmd.Flags().BoolVar(&simulate, "simulate", false, "Simulate the transaction without sending it")
	cmd.Flags().UintVar(&timeout, "timeout", 60, "Timeout (in seconds) for interactions with the JSONRPC API")
	cmd.Flags().StringVar(&contractAddressRaw, "contract", "", "Address of the contract to interact with")
	cmd.Flags().StringVar(&safeAddress, "safe", "", "Address of the Safe contract")
	cmd.Flags().StringVar(&safeApi, "safe-api", "", "Safe API for the Safe Transaction Service (optional)")
	cmd.Flags().Uint8Var(&safeOperationType, "safe-operation", 0, "Safe operation type: 0 (Call) or 1 (DelegateCall)")

	cmd.Flags().StringVar(&guardRaw, "guard", "", "guard argument (common.Address)")

	return cmd
}
func CreateSetModuleGuardCommand() *cobra.Command {
	var keyfile, nonce, password, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas, rpc, contractAddressRaw string
	var gasLimit uint64
	var simulate bool
	var timeout uint
	var contractAddress common.Address
	var safeAddress, safeApi string
	var safeOperationType uint8

	var moduleGuard common.Address
	var moduleGuardRaw string

	cmd := &cobra.Command{
		Use:   "set-module-guard",
		Short: "Execute the SetModuleGuard method on a Safe contract",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if contractAddressRaw == "" {
				return fmt.Errorf("--contract not specified")
			} else if !common.IsHexAddress(contractAddressRaw) {
				return fmt.Errorf("--contract is not a valid Ethereum address")
			}
			contractAddress = common.HexToAddress(contractAddressRaw)

			if keyfile == "" {
				return fmt.Errorf("--keystore not specified (this should be a path to an Ethereum account keystore file)")
			}

			if rpc == "" {
				return fmt.Errorf("--rpc not specified (this should be a URL to an Ethereum JSONRPC API)")
			}

			if safeAddress != "" {
				if !common.IsHexAddress(safeAddress) {
					return fmt.Errorf("--safe is not a valid Ethereum address")
				}
				if safeApi == "" {
					client, clientErr := NewClient(rpc)
					if clientErr != nil {
						return clientErr
					}
					chainIDCtx, cancelChainIDCtx := NewChainContext(timeout)
					defer cancelChainIDCtx()
					chainID, chainIDErr := client.ChainID(chainIDCtx)
					if chainIDErr != nil {
						return chainIDErr
					}
					safeApi = fmt.Sprintf("https://safe-client.safe.global/v1/chains/%s/transactions/%s/propose", chainID.String(), safeAddress)
					fmt.Println("--safe-api not specified, using default (", safeApi, ")")
				}

				if SafeOperationType(safeOperationType).String() == "Unknown" {
					return fmt.Errorf("--safe-operation must be 0 (Call) or 1 (DelegateCall)")
				}
			}

			if moduleGuardRaw == "" {
				return fmt.Errorf("--module-guard argument not specified")
			} else if !common.IsHexAddress(moduleGuardRaw) {
				return fmt.Errorf("--module-guard argument is not a valid Ethereum address")
			}
			moduleGuard = common.HexToAddress(moduleGuardRaw)

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			client, clientErr := NewClient(rpc)
			if clientErr != nil {
				return clientErr
			}

			key, keyErr := KeyFromFile(keyfile, password)
			if keyErr != nil {
				return keyErr
			}

			chainIDCtx, cancelChainIDCtx := NewChainContext(timeout)
			defer cancelChainIDCtx()
			chainID, chainIDErr := client.ChainID(chainIDCtx)
			if chainIDErr != nil {
				return chainIDErr
			}

			transactionOpts, transactionOptsErr := bind.NewKeyedTransactorWithChainID(key.PrivateKey, chainID)
			if transactionOptsErr != nil {
				return transactionOptsErr
			}

			SetTransactionParametersFromArgs(transactionOpts, nonce, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas, gasLimit, simulate)

			contract, contractErr := NewSafe(contractAddress, client)
			if contractErr != nil {
				return contractErr
			}

			session := SafeTransactorSession{
				Contract:     &contract.SafeTransactor,
				TransactOpts: *transactionOpts,
			}

			if safeAddress != "" {
				// Generate transaction data
				transaction, err := session.SetModuleGuard(

					moduleGuard,
				)

				if err != nil {
					return err
				}

				// Create Safe proposal for transaction
				value := transactionOpts.Value
				if value == nil {
					value = big.NewInt(0)
				}
				err = CreateSafeProposal(client, key, common.HexToAddress(safeAddress), contractAddress, transaction.Data(), value, safeApi, SafeOperationType(safeOperationType))
				if err != nil {
					return fmt.Errorf("failed to create Safe proposal: %v", err)
				}

				return nil
			}

			transaction, err := session.SetModuleGuard(

				moduleGuard,
			)
			if err != nil {
				return err
			}

			cmd.Printf("Transaction hash: %s\n", transaction.Hash().Hex())
			if transactionOpts.NoSend {
				estimationMessage := ethereum.CallMsg{
					From: transactionOpts.From,
					To:   &contractAddress,
					Data: transaction.Data(),
				}

				gasEstimationCtx, cancelGasEstimationCtx := NewChainContext(timeout)
				defer cancelGasEstimationCtx()

				gasEstimate, gasEstimateErr := client.EstimateGas(gasEstimationCtx, estimationMessage)
				if gasEstimateErr != nil {
					return gasEstimateErr
				}

				transactionBinary, transactionBinaryErr := transaction.MarshalBinary()
				if transactionBinaryErr != nil {
					return transactionBinaryErr
				}
				transactionBinaryHex := hex.EncodeToString(transactionBinary)

				cmd.Printf("Transaction: %s\nEstimated gas: %d\n", transactionBinaryHex, gasEstimate)
			} else {
				cmd.Println("Transaction submitted")
			}

			return nil
		},
	}

	cmd.Flags().StringVar(&rpc, "rpc", "", "URL of the JSONRPC API to use")
	cmd.Flags().StringVar(&keyfile, "keyfile", "", "Path to the keystore file to use for the transaction")
	cmd.Flags().StringVar(&password, "password", "", "Password to use to unlock the keystore (if not specified, you will be prompted for the password when the command executes)")
	cmd.Flags().StringVar(&nonce, "nonce", "", "Nonce to use for the transaction")
	cmd.Flags().StringVar(&value, "value", "", "Value to send with the transaction")
	cmd.Flags().StringVar(&gasPrice, "gas-price", "", "Gas price to use for the transaction")
	cmd.Flags().StringVar(&maxFeePerGas, "max-fee-per-gas", "", "Maximum fee per gas to use for the (EIP-1559) transaction")
	cmd.Flags().StringVar(&maxPriorityFeePerGas, "max-priority-fee-per-gas", "", "Maximum priority fee per gas to use for the (EIP-1559) transaction")
	cmd.Flags().Uint64Var(&gasLimit, "gas-limit", 0, "Gas limit for the transaction")
	cmd.Flags().BoolVar(&simulate, "simulate", false, "Simulate the transaction without sending it")
	cmd.Flags().UintVar(&timeout, "timeout", 60, "Timeout (in seconds) for interactions with the JSONRPC API")
	cmd.Flags().StringVar(&contractAddressRaw, "contract", "", "Address of the contract to interact with")
	cmd.Flags().StringVar(&safeAddress, "safe", "", "Address of the Safe contract")
	cmd.Flags().StringVar(&safeApi, "safe-api", "", "Safe API for the Safe Transaction Service (optional)")
	cmd.Flags().Uint8Var(&safeOperationType, "safe-operation", 0, "Safe operation type: 0 (Call) or 1 (DelegateCall)")

	cmd.Flags().StringVar(&moduleGuardRaw, "module-guard", "", "module-guard argument (common.Address)")

	return cmd
}
func CreateSetupCommand() *cobra.Command {
	var keyfile, nonce, password, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas, rpc, contractAddressRaw string
	var gasLimit uint64
	var simulate bool
	var timeout uint
	var contractAddress common.Address
	var safeAddress, safeApi string
	var safeOperationType uint8

	var owners []common.Address
	var ownersRaw string
	var threshold *big.Int
	var thresholdRaw string
	var to0 common.Address
	var to0Raw string
	var data []byte
	var dataRaw string
	var fallbackHandler common.Address
	var fallbackHandlerRaw string
	var paymentToken common.Address
	var paymentTokenRaw string
	var payment *big.Int
	var paymentRaw string
	var paymentReceiver common.Address
	var paymentReceiverRaw string

	cmd := &cobra.Command{
		Use:   "setup",
		Short: "Execute the Setup method on a Safe contract",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if contractAddressRaw == "" {
				return fmt.Errorf("--contract not specified")
			} else if !common.IsHexAddress(contractAddressRaw) {
				return fmt.Errorf("--contract is not a valid Ethereum address")
			}
			contractAddress = common.HexToAddress(contractAddressRaw)

			if keyfile == "" {
				return fmt.Errorf("--keystore not specified (this should be a path to an Ethereum account keystore file)")
			}

			if rpc == "" {
				return fmt.Errorf("--rpc not specified (this should be a URL to an Ethereum JSONRPC API)")
			}

			if safeAddress != "" {
				if !common.IsHexAddress(safeAddress) {
					return fmt.Errorf("--safe is not a valid Ethereum address")
				}
				if safeApi == "" {
					client, clientErr := NewClient(rpc)
					if clientErr != nil {
						return clientErr
					}
					chainIDCtx, cancelChainIDCtx := NewChainContext(timeout)
					defer cancelChainIDCtx()
					chainID, chainIDErr := client.ChainID(chainIDCtx)
					if chainIDErr != nil {
						return chainIDErr
					}
					safeApi = fmt.Sprintf("https://safe-client.safe.global/v1/chains/%s/transactions/%s/propose", chainID.String(), safeAddress)
					fmt.Println("--safe-api not specified, using default (", safeApi, ")")
				}

				if SafeOperationType(safeOperationType).String() == "Unknown" {
					return fmt.Errorf("--safe-operation must be 0 (Call) or 1 (DelegateCall)")
				}
			}

			if ownersRaw == "" {
				return fmt.Errorf("--owners argument not specified")
			} else if strings.HasPrefix(ownersRaw, "@") {
				filename := strings.TrimPrefix(ownersRaw, "@")
				contents, readErr := os.ReadFile(filename)
				if readErr != nil {
					return readErr
				}
				unmarshalErr := json.Unmarshal(contents, &owners)
				if unmarshalErr != nil {
					return unmarshalErr
				}
			} else {
				unmarshalErr := json.Unmarshal([]byte(ownersRaw), &owners)
				if unmarshalErr != nil {
					return unmarshalErr
				}
			}

			if thresholdRaw == "" {
				return fmt.Errorf("--threshold argument not specified")
			}
			threshold = new(big.Int)
			threshold.SetString(thresholdRaw, 0)

			if to0Raw == "" {
				return fmt.Errorf("--to-0 argument not specified")
			} else if !common.IsHexAddress(to0Raw) {
				return fmt.Errorf("--to-0 argument is not a valid Ethereum address")
			}
			to0 = common.HexToAddress(to0Raw)

			var dataIntermediate []byte

			var dataIntermediateHexDecodeErr error
			dataIntermediate, dataIntermediateHexDecodeErr = hex.DecodeString(dataRaw)
			if dataIntermediateHexDecodeErr != nil {
				return dataIntermediateHexDecodeErr
			}

			copy(data[:], dataIntermediate)

			if fallbackHandlerRaw == "" {
				return fmt.Errorf("--fallback-handler argument not specified")
			} else if !common.IsHexAddress(fallbackHandlerRaw) {
				return fmt.Errorf("--fallback-handler argument is not a valid Ethereum address")
			}
			fallbackHandler = common.HexToAddress(fallbackHandlerRaw)

			if paymentTokenRaw == "" {
				return fmt.Errorf("--payment-token argument not specified")
			} else if !common.IsHexAddress(paymentTokenRaw) {
				return fmt.Errorf("--payment-token argument is not a valid Ethereum address")
			}
			paymentToken = common.HexToAddress(paymentTokenRaw)

			if paymentRaw == "" {
				return fmt.Errorf("--payment argument not specified")
			}
			payment = new(big.Int)
			payment.SetString(paymentRaw, 0)

			if paymentReceiverRaw == "" {
				return fmt.Errorf("--payment-receiver argument not specified")
			} else if !common.IsHexAddress(paymentReceiverRaw) {
				return fmt.Errorf("--payment-receiver argument is not a valid Ethereum address")
			}
			paymentReceiver = common.HexToAddress(paymentReceiverRaw)

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			client, clientErr := NewClient(rpc)
			if clientErr != nil {
				return clientErr
			}

			key, keyErr := KeyFromFile(keyfile, password)
			if keyErr != nil {
				return keyErr
			}

			chainIDCtx, cancelChainIDCtx := NewChainContext(timeout)
			defer cancelChainIDCtx()
			chainID, chainIDErr := client.ChainID(chainIDCtx)
			if chainIDErr != nil {
				return chainIDErr
			}

			transactionOpts, transactionOptsErr := bind.NewKeyedTransactorWithChainID(key.PrivateKey, chainID)
			if transactionOptsErr != nil {
				return transactionOptsErr
			}

			SetTransactionParametersFromArgs(transactionOpts, nonce, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas, gasLimit, simulate)

			contract, contractErr := NewSafe(contractAddress, client)
			if contractErr != nil {
				return contractErr
			}

			session := SafeTransactorSession{
				Contract:     &contract.SafeTransactor,
				TransactOpts: *transactionOpts,
			}

			if safeAddress != "" {
				// Generate transaction data
				transaction, err := session.Setup(

					owners,
					threshold,
					to0,
					data,
					fallbackHandler,
					paymentToken,
					payment,
					paymentReceiver,
				)

				if err != nil {
					return err
				}

				// Create Safe proposal for transaction
				value := transactionOpts.Value
				if value == nil {
					value = big.NewInt(0)
				}
				err = CreateSafeProposal(client, key, common.HexToAddress(safeAddress), contractAddress, transaction.Data(), value, safeApi, SafeOperationType(safeOperationType))
				if err != nil {
					return fmt.Errorf("failed to create Safe proposal: %v", err)
				}

				return nil
			}

			transaction, err := session.Setup(

				owners,
				threshold,
				to0,
				data,
				fallbackHandler,
				paymentToken,
				payment,
				paymentReceiver,
			)
			if err != nil {
				return err
			}

			cmd.Printf("Transaction hash: %s\n", transaction.Hash().Hex())
			if transactionOpts.NoSend {
				estimationMessage := ethereum.CallMsg{
					From: transactionOpts.From,
					To:   &contractAddress,
					Data: transaction.Data(),
				}

				gasEstimationCtx, cancelGasEstimationCtx := NewChainContext(timeout)
				defer cancelGasEstimationCtx()

				gasEstimate, gasEstimateErr := client.EstimateGas(gasEstimationCtx, estimationMessage)
				if gasEstimateErr != nil {
					return gasEstimateErr
				}

				transactionBinary, transactionBinaryErr := transaction.MarshalBinary()
				if transactionBinaryErr != nil {
					return transactionBinaryErr
				}
				transactionBinaryHex := hex.EncodeToString(transactionBinary)

				cmd.Printf("Transaction: %s\nEstimated gas: %d\n", transactionBinaryHex, gasEstimate)
			} else {
				cmd.Println("Transaction submitted")
			}

			return nil
		},
	}

	cmd.Flags().StringVar(&rpc, "rpc", "", "URL of the JSONRPC API to use")
	cmd.Flags().StringVar(&keyfile, "keyfile", "", "Path to the keystore file to use for the transaction")
	cmd.Flags().StringVar(&password, "password", "", "Password to use to unlock the keystore (if not specified, you will be prompted for the password when the command executes)")
	cmd.Flags().StringVar(&nonce, "nonce", "", "Nonce to use for the transaction")
	cmd.Flags().StringVar(&value, "value", "", "Value to send with the transaction")
	cmd.Flags().StringVar(&gasPrice, "gas-price", "", "Gas price to use for the transaction")
	cmd.Flags().StringVar(&maxFeePerGas, "max-fee-per-gas", "", "Maximum fee per gas to use for the (EIP-1559) transaction")
	cmd.Flags().StringVar(&maxPriorityFeePerGas, "max-priority-fee-per-gas", "", "Maximum priority fee per gas to use for the (EIP-1559) transaction")
	cmd.Flags().Uint64Var(&gasLimit, "gas-limit", 0, "Gas limit for the transaction")
	cmd.Flags().BoolVar(&simulate, "simulate", false, "Simulate the transaction without sending it")
	cmd.Flags().UintVar(&timeout, "timeout", 60, "Timeout (in seconds) for interactions with the JSONRPC API")
	cmd.Flags().StringVar(&contractAddressRaw, "contract", "", "Address of the contract to interact with")
	cmd.Flags().StringVar(&safeAddress, "safe", "", "Address of the Safe contract")
	cmd.Flags().StringVar(&safeApi, "safe-api", "", "Safe API for the Safe Transaction Service (optional)")
	cmd.Flags().Uint8Var(&safeOperationType, "safe-operation", 0, "Safe operation type: 0 (Call) or 1 (DelegateCall)")

	cmd.Flags().StringVar(&ownersRaw, "owners", "", "owners argument ([]common.Address)")
	cmd.Flags().StringVar(&thresholdRaw, "threshold", "", "threshold argument")
	cmd.Flags().StringVar(&to0Raw, "to-0", "", "to-0 argument (common.Address)")
	cmd.Flags().StringVar(&dataRaw, "data", "", "data argument ([]byte)")
	cmd.Flags().StringVar(&fallbackHandlerRaw, "fallback-handler", "", "fallback-handler argument (common.Address)")
	cmd.Flags().StringVar(&paymentTokenRaw, "payment-token", "", "payment-token argument (common.Address)")
	cmd.Flags().StringVar(&paymentRaw, "payment", "", "payment argument")
	cmd.Flags().StringVar(&paymentReceiverRaw, "payment-receiver", "", "payment-receiver argument (common.Address)")

	return cmd
}
func CreateSimulateAndRevertCommand() *cobra.Command {
	var keyfile, nonce, password, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas, rpc, contractAddressRaw string
	var gasLimit uint64
	var simulate bool
	var timeout uint
	var contractAddress common.Address
	var safeAddress, safeApi string
	var safeOperationType uint8

	var targetContract common.Address
	var targetContractRaw string
	var calldataPayload []byte
	var calldataPayloadRaw string

	cmd := &cobra.Command{
		Use:   "simulate-and-revert",
		Short: "Execute the SimulateAndRevert method on a Safe contract",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if contractAddressRaw == "" {
				return fmt.Errorf("--contract not specified")
			} else if !common.IsHexAddress(contractAddressRaw) {
				return fmt.Errorf("--contract is not a valid Ethereum address")
			}
			contractAddress = common.HexToAddress(contractAddressRaw)

			if keyfile == "" {
				return fmt.Errorf("--keystore not specified (this should be a path to an Ethereum account keystore file)")
			}

			if rpc == "" {
				return fmt.Errorf("--rpc not specified (this should be a URL to an Ethereum JSONRPC API)")
			}

			if safeAddress != "" {
				if !common.IsHexAddress(safeAddress) {
					return fmt.Errorf("--safe is not a valid Ethereum address")
				}
				if safeApi == "" {
					client, clientErr := NewClient(rpc)
					if clientErr != nil {
						return clientErr
					}
					chainIDCtx, cancelChainIDCtx := NewChainContext(timeout)
					defer cancelChainIDCtx()
					chainID, chainIDErr := client.ChainID(chainIDCtx)
					if chainIDErr != nil {
						return chainIDErr
					}
					safeApi = fmt.Sprintf("https://safe-client.safe.global/v1/chains/%s/transactions/%s/propose", chainID.String(), safeAddress)
					fmt.Println("--safe-api not specified, using default (", safeApi, ")")
				}

				if SafeOperationType(safeOperationType).String() == "Unknown" {
					return fmt.Errorf("--safe-operation must be 0 (Call) or 1 (DelegateCall)")
				}
			}

			if targetContractRaw == "" {
				return fmt.Errorf("--target-contract argument not specified")
			} else if !common.IsHexAddress(targetContractRaw) {
				return fmt.Errorf("--target-contract argument is not a valid Ethereum address")
			}
			targetContract = common.HexToAddress(targetContractRaw)

			var calldataPayloadIntermediate []byte

			var calldataPayloadIntermediateHexDecodeErr error
			calldataPayloadIntermediate, calldataPayloadIntermediateHexDecodeErr = hex.DecodeString(calldataPayloadRaw)
			if calldataPayloadIntermediateHexDecodeErr != nil {
				return calldataPayloadIntermediateHexDecodeErr
			}

			copy(calldataPayload[:], calldataPayloadIntermediate)

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			client, clientErr := NewClient(rpc)
			if clientErr != nil {
				return clientErr
			}

			key, keyErr := KeyFromFile(keyfile, password)
			if keyErr != nil {
				return keyErr
			}

			chainIDCtx, cancelChainIDCtx := NewChainContext(timeout)
			defer cancelChainIDCtx()
			chainID, chainIDErr := client.ChainID(chainIDCtx)
			if chainIDErr != nil {
				return chainIDErr
			}

			transactionOpts, transactionOptsErr := bind.NewKeyedTransactorWithChainID(key.PrivateKey, chainID)
			if transactionOptsErr != nil {
				return transactionOptsErr
			}

			SetTransactionParametersFromArgs(transactionOpts, nonce, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas, gasLimit, simulate)

			contract, contractErr := NewSafe(contractAddress, client)
			if contractErr != nil {
				return contractErr
			}

			session := SafeTransactorSession{
				Contract:     &contract.SafeTransactor,
				TransactOpts: *transactionOpts,
			}

			if safeAddress != "" {
				// Generate transaction data
				transaction, err := session.SimulateAndRevert(

					targetContract,
					calldataPayload,
				)

				if err != nil {
					return err
				}

				// Create Safe proposal for transaction
				value := transactionOpts.Value
				if value == nil {
					value = big.NewInt(0)
				}
				err = CreateSafeProposal(client, key, common.HexToAddress(safeAddress), contractAddress, transaction.Data(), value, safeApi, SafeOperationType(safeOperationType))
				if err != nil {
					return fmt.Errorf("failed to create Safe proposal: %v", err)
				}

				return nil
			}

			transaction, err := session.SimulateAndRevert(

				targetContract,
				calldataPayload,
			)
			if err != nil {
				return err
			}

			cmd.Printf("Transaction hash: %s\n", transaction.Hash().Hex())
			if transactionOpts.NoSend {
				estimationMessage := ethereum.CallMsg{
					From: transactionOpts.From,
					To:   &contractAddress,
					Data: transaction.Data(),
				}

				gasEstimationCtx, cancelGasEstimationCtx := NewChainContext(timeout)
				defer cancelGasEstimationCtx()

				gasEstimate, gasEstimateErr := client.EstimateGas(gasEstimationCtx, estimationMessage)
				if gasEstimateErr != nil {
					return gasEstimateErr
				}

				transactionBinary, transactionBinaryErr := transaction.MarshalBinary()
				if transactionBinaryErr != nil {
					return transactionBinaryErr
				}
				transactionBinaryHex := hex.EncodeToString(transactionBinary)

				cmd.Printf("Transaction: %s\nEstimated gas: %d\n", transactionBinaryHex, gasEstimate)
			} else {
				cmd.Println("Transaction submitted")
			}

			return nil
		},
	}

	cmd.Flags().StringVar(&rpc, "rpc", "", "URL of the JSONRPC API to use")
	cmd.Flags().StringVar(&keyfile, "keyfile", "", "Path to the keystore file to use for the transaction")
	cmd.Flags().StringVar(&password, "password", "", "Password to use to unlock the keystore (if not specified, you will be prompted for the password when the command executes)")
	cmd.Flags().StringVar(&nonce, "nonce", "", "Nonce to use for the transaction")
	cmd.Flags().StringVar(&value, "value", "", "Value to send with the transaction")
	cmd.Flags().StringVar(&gasPrice, "gas-price", "", "Gas price to use for the transaction")
	cmd.Flags().StringVar(&maxFeePerGas, "max-fee-per-gas", "", "Maximum fee per gas to use for the (EIP-1559) transaction")
	cmd.Flags().StringVar(&maxPriorityFeePerGas, "max-priority-fee-per-gas", "", "Maximum priority fee per gas to use for the (EIP-1559) transaction")
	cmd.Flags().Uint64Var(&gasLimit, "gas-limit", 0, "Gas limit for the transaction")
	cmd.Flags().BoolVar(&simulate, "simulate", false, "Simulate the transaction without sending it")
	cmd.Flags().UintVar(&timeout, "timeout", 60, "Timeout (in seconds) for interactions with the JSONRPC API")
	cmd.Flags().StringVar(&contractAddressRaw, "contract", "", "Address of the contract to interact with")
	cmd.Flags().StringVar(&safeAddress, "safe", "", "Address of the Safe contract")
	cmd.Flags().StringVar(&safeApi, "safe-api", "", "Safe API for the Safe Transaction Service (optional)")
	cmd.Flags().Uint8Var(&safeOperationType, "safe-operation", 0, "Safe operation type: 0 (Call) or 1 (DelegateCall)")

	cmd.Flags().StringVar(&targetContractRaw, "target-contract", "", "target-contract argument (common.Address)")
	cmd.Flags().StringVar(&calldataPayloadRaw, "calldata-payload", "", "calldata-payload argument ([]byte)")

	return cmd
}
func CreateSwapOwnerCommand() *cobra.Command {
	var keyfile, nonce, password, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas, rpc, contractAddressRaw string
	var gasLimit uint64
	var simulate bool
	var timeout uint
	var contractAddress common.Address
	var safeAddress, safeApi string
	var safeOperationType uint8

	var prevOwner common.Address
	var prevOwnerRaw string
	var oldOwner common.Address
	var oldOwnerRaw string
	var newOwner common.Address
	var newOwnerRaw string

	cmd := &cobra.Command{
		Use:   "swap-owner",
		Short: "Execute the SwapOwner method on a Safe contract",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if contractAddressRaw == "" {
				return fmt.Errorf("--contract not specified")
			} else if !common.IsHexAddress(contractAddressRaw) {
				return fmt.Errorf("--contract is not a valid Ethereum address")
			}
			contractAddress = common.HexToAddress(contractAddressRaw)

			if keyfile == "" {
				return fmt.Errorf("--keystore not specified (this should be a path to an Ethereum account keystore file)")
			}

			if rpc == "" {
				return fmt.Errorf("--rpc not specified (this should be a URL to an Ethereum JSONRPC API)")
			}

			if safeAddress != "" {
				if !common.IsHexAddress(safeAddress) {
					return fmt.Errorf("--safe is not a valid Ethereum address")
				}
				if safeApi == "" {
					client, clientErr := NewClient(rpc)
					if clientErr != nil {
						return clientErr
					}
					chainIDCtx, cancelChainIDCtx := NewChainContext(timeout)
					defer cancelChainIDCtx()
					chainID, chainIDErr := client.ChainID(chainIDCtx)
					if chainIDErr != nil {
						return chainIDErr
					}
					safeApi = fmt.Sprintf("https://safe-client.safe.global/v1/chains/%s/transactions/%s/propose", chainID.String(), safeAddress)
					fmt.Println("--safe-api not specified, using default (", safeApi, ")")
				}

				if SafeOperationType(safeOperationType).String() == "Unknown" {
					return fmt.Errorf("--safe-operation must be 0 (Call) or 1 (DelegateCall)")
				}
			}

			if prevOwnerRaw == "" {
				return fmt.Errorf("--prev-owner argument not specified")
			} else if !common.IsHexAddress(prevOwnerRaw) {
				return fmt.Errorf("--prev-owner argument is not a valid Ethereum address")
			}
			prevOwner = common.HexToAddress(prevOwnerRaw)

			if oldOwnerRaw == "" {
				return fmt.Errorf("--old-owner argument not specified")
			} else if !common.IsHexAddress(oldOwnerRaw) {
				return fmt.Errorf("--old-owner argument is not a valid Ethereum address")
			}
			oldOwner = common.HexToAddress(oldOwnerRaw)

			if newOwnerRaw == "" {
				return fmt.Errorf("--new-owner argument not specified")
			} else if !common.IsHexAddress(newOwnerRaw) {
				return fmt.Errorf("--new-owner argument is not a valid Ethereum address")
			}
			newOwner = common.HexToAddress(newOwnerRaw)

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			client, clientErr := NewClient(rpc)
			if clientErr != nil {
				return clientErr
			}

			key, keyErr := KeyFromFile(keyfile, password)
			if keyErr != nil {
				return keyErr
			}

			chainIDCtx, cancelChainIDCtx := NewChainContext(timeout)
			defer cancelChainIDCtx()
			chainID, chainIDErr := client.ChainID(chainIDCtx)
			if chainIDErr != nil {
				return chainIDErr
			}

			transactionOpts, transactionOptsErr := bind.NewKeyedTransactorWithChainID(key.PrivateKey, chainID)
			if transactionOptsErr != nil {
				return transactionOptsErr
			}

			SetTransactionParametersFromArgs(transactionOpts, nonce, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas, gasLimit, simulate)

			contract, contractErr := NewSafe(contractAddress, client)
			if contractErr != nil {
				return contractErr
			}

			session := SafeTransactorSession{
				Contract:     &contract.SafeTransactor,
				TransactOpts: *transactionOpts,
			}

			if safeAddress != "" {
				// Generate transaction data
				transaction, err := session.SwapOwner(

					prevOwner,
					oldOwner,
					newOwner,
				)

				if err != nil {
					return err
				}

				// Create Safe proposal for transaction
				value := transactionOpts.Value
				if value == nil {
					value = big.NewInt(0)
				}
				err = CreateSafeProposal(client, key, common.HexToAddress(safeAddress), contractAddress, transaction.Data(), value, safeApi, SafeOperationType(safeOperationType))
				if err != nil {
					return fmt.Errorf("failed to create Safe proposal: %v", err)
				}

				return nil
			}

			transaction, err := session.SwapOwner(

				prevOwner,
				oldOwner,
				newOwner,
			)
			if err != nil {
				return err
			}

			cmd.Printf("Transaction hash: %s\n", transaction.Hash().Hex())
			if transactionOpts.NoSend {
				estimationMessage := ethereum.CallMsg{
					From: transactionOpts.From,
					To:   &contractAddress,
					Data: transaction.Data(),
				}

				gasEstimationCtx, cancelGasEstimationCtx := NewChainContext(timeout)
				defer cancelGasEstimationCtx()

				gasEstimate, gasEstimateErr := client.EstimateGas(gasEstimationCtx, estimationMessage)
				if gasEstimateErr != nil {
					return gasEstimateErr
				}

				transactionBinary, transactionBinaryErr := transaction.MarshalBinary()
				if transactionBinaryErr != nil {
					return transactionBinaryErr
				}
				transactionBinaryHex := hex.EncodeToString(transactionBinary)

				cmd.Printf("Transaction: %s\nEstimated gas: %d\n", transactionBinaryHex, gasEstimate)
			} else {
				cmd.Println("Transaction submitted")
			}

			return nil
		},
	}

	cmd.Flags().StringVar(&rpc, "rpc", "", "URL of the JSONRPC API to use")
	cmd.Flags().StringVar(&keyfile, "keyfile", "", "Path to the keystore file to use for the transaction")
	cmd.Flags().StringVar(&password, "password", "", "Password to use to unlock the keystore (if not specified, you will be prompted for the password when the command executes)")
	cmd.Flags().StringVar(&nonce, "nonce", "", "Nonce to use for the transaction")
	cmd.Flags().StringVar(&value, "value", "", "Value to send with the transaction")
	cmd.Flags().StringVar(&gasPrice, "gas-price", "", "Gas price to use for the transaction")
	cmd.Flags().StringVar(&maxFeePerGas, "max-fee-per-gas", "", "Maximum fee per gas to use for the (EIP-1559) transaction")
	cmd.Flags().StringVar(&maxPriorityFeePerGas, "max-priority-fee-per-gas", "", "Maximum priority fee per gas to use for the (EIP-1559) transaction")
	cmd.Flags().Uint64Var(&gasLimit, "gas-limit", 0, "Gas limit for the transaction")
	cmd.Flags().BoolVar(&simulate, "simulate", false, "Simulate the transaction without sending it")
	cmd.Flags().UintVar(&timeout, "timeout", 60, "Timeout (in seconds) for interactions with the JSONRPC API")
	cmd.Flags().StringVar(&contractAddressRaw, "contract", "", "Address of the contract to interact with")
	cmd.Flags().StringVar(&safeAddress, "safe", "", "Address of the Safe contract")
	cmd.Flags().StringVar(&safeApi, "safe-api", "", "Safe API for the Safe Transaction Service (optional)")
	cmd.Flags().Uint8Var(&safeOperationType, "safe-operation", 0, "Safe operation type: 0 (Call) or 1 (DelegateCall)")

	cmd.Flags().StringVar(&prevOwnerRaw, "prev-owner", "", "prev-owner argument (common.Address)")
	cmd.Flags().StringVar(&oldOwnerRaw, "old-owner", "", "old-owner argument (common.Address)")
	cmd.Flags().StringVar(&newOwnerRaw, "new-owner", "", "new-owner argument (common.Address)")

	return cmd
}

var ErrNoRPCURL error = errors.New("no RPC URL provided -- please pass an RPC URL from the command line or set the SAFE_RPC_URL environment variable")

// Generates an Ethereum client to the JSONRPC API at the given URL. If rpcURL is empty, then it
// attempts to read the RPC URL from the SAFE_RPC_URL environment variable. If that is empty,
// too, then it returns an error.
func NewClient(rpcURL string) (*ethclient.Client, error) {
	if rpcURL == "" {
		rpcURL = os.Getenv("SAFE_RPC_URL")
	}

	if rpcURL == "" {
		return nil, ErrNoRPCURL
	}

	client, err := ethclient.Dial(rpcURL)
	return client, err
}

// Creates a new context to be used when interacting with the chain client.
func NewChainContext(timeout uint) (context.Context, context.CancelFunc) {
	baseCtx := context.Background()
	parsedTimeout := time.Duration(timeout) * time.Second
	ctx, cancel := context.WithTimeout(baseCtx, parsedTimeout)
	return ctx, cancel
}

// Unlocks a key from a keystore (byte contents of a keystore file) with the given password.
func UnlockKeystore(keystoreData []byte, password string) (*keystore.Key, error) {
	key, err := keystore.DecryptKey(keystoreData, password)
	return key, err
}

// Loads a key from file, prompting the user for the password if it is not provided as a function argument.
func KeyFromFile(keystoreFile string, password string) (*keystore.Key, error) {
	var emptyKey *keystore.Key
	keystoreContent, readErr := os.ReadFile(keystoreFile)
	if readErr != nil {
		return emptyKey, readErr
	}

	// If password is "", prompt user for password.
	if password == "" {
		fmt.Printf("Please provide a password for keystore (%s): ", keystoreFile)
		passwordRaw, inputErr := term.ReadPassword(int(os.Stdin.Fd()))
		if inputErr != nil {
			return emptyKey, fmt.Errorf("error reading password: %s", inputErr.Error())
		}
		fmt.Print("\n")
		password = string(passwordRaw)
	}

	key, err := UnlockKeystore(keystoreContent, password)
	return key, err
}

// This method is used to set the parameters on a view call from command line arguments (represented mostly as
// strings).
func SetCallParametersFromArgs(opts *bind.CallOpts, pending bool, fromAddress, blockNumber string) {
	if pending {
		opts.Pending = true
	}

	if fromAddress != "" {
		opts.From = common.HexToAddress(fromAddress)
	}

	if blockNumber != "" {
		opts.BlockNumber = new(big.Int)
		opts.BlockNumber.SetString(blockNumber, 0)
	}
}

// This method is used to set the parameters on a transaction from command line arguments (represented mostly as
// strings).
func SetTransactionParametersFromArgs(opts *bind.TransactOpts, nonce, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas string, gasLimit uint64, noSend bool) {
	if nonce != "" {
		opts.Nonce = new(big.Int)
		opts.Nonce.SetString(nonce, 0)
	}

	if value != "" {
		opts.Value = new(big.Int)
		opts.Value.SetString(value, 0)
	}

	if gasPrice != "" {
		opts.GasPrice = new(big.Int)
		opts.GasPrice.SetString(gasPrice, 0)
	}

	if maxFeePerGas != "" {
		opts.GasFeeCap = new(big.Int)
		opts.GasFeeCap.SetString(maxFeePerGas, 0)
	}

	if maxPriorityFeePerGas != "" {
		opts.GasTipCap = new(big.Int)
		opts.GasTipCap.SetString(maxPriorityFeePerGas, 0)
	}

	if gasLimit != 0 {
		opts.GasLimit = gasLimit
	}

	opts.NoSend = noSend
}

func CreateSafeCommand() *cobra.Command {
	cmd := &cobra.Command{
		Use:   "safe",
		Short: "Interact with the Safe contract",
		Run: func(cmd *cobra.Command, args []string) {
			cmd.Help()
		},
	}

	cmd.SetOut(os.Stdout)

	DeployGroup := &cobra.Group{
		ID: "deploy", Title: "Commands which deploy contracts",
	}
	cmd.AddGroup(DeployGroup)
	ViewGroup := &cobra.Group{
		ID: "view", Title: "Commands which view contract state",
	}
	TransactGroup := &cobra.Group{
		ID: "transact", Title: "Commands which submit transactions",
	}
	cmd.AddGroup(ViewGroup, TransactGroup)

	cmdDeploySafe := CreateSafeDeploymentCommand()
	cmdDeploySafe.GroupID = DeployGroup.ID
	cmd.AddCommand(cmdDeploySafe)

	cmdViewApprovedHashes := CreateApprovedHashesCommand()
	cmdViewApprovedHashes.GroupID = ViewGroup.ID
	cmd.AddCommand(cmdViewApprovedHashes)
	cmdViewCheckNSignatures := CreateCheckNsignaturesCommand()
	cmdViewCheckNSignatures.GroupID = ViewGroup.ID
	cmd.AddCommand(cmdViewCheckNSignatures)
	cmdViewCheckNSignatures0 := CreateCheckNsignatures0Command()
	cmdViewCheckNSignatures0.GroupID = ViewGroup.ID
	cmd.AddCommand(cmdViewCheckNSignatures0)
	cmdViewCheckSignatures := CreateCheckSignaturesCommand()
	cmdViewCheckSignatures.GroupID = ViewGroup.ID
	cmd.AddCommand(cmdViewCheckSignatures)
	cmdViewCheckSignatures0 := CreateCheckSignatures0Command()
	cmdViewCheckSignatures0.GroupID = ViewGroup.ID
	cmd.AddCommand(cmdViewCheckSignatures0)
	cmdViewDomainSeparator := CreateDomainSeparatorCommand()
	cmdViewDomainSeparator.GroupID = ViewGroup.ID
	cmd.AddCommand(cmdViewDomainSeparator)
	cmdViewGetModulesPaginated := CreateGetModulesPaginatedCommand()
	cmdViewGetModulesPaginated.GroupID = ViewGroup.ID
	cmd.AddCommand(cmdViewGetModulesPaginated)
	cmdViewGetOwners := CreateGetOwnersCommand()
	cmdViewGetOwners.GroupID = ViewGroup.ID
	cmd.AddCommand(cmdViewGetOwners)
	cmdViewGetStorageAt := CreateGetStorageAtCommand()
	cmdViewGetStorageAt.GroupID = ViewGroup.ID
	cmd.AddCommand(cmdViewGetStorageAt)
	cmdViewGetThreshold := CreateGetThresholdCommand()
	cmdViewGetThreshold.GroupID = ViewGroup.ID
	cmd.AddCommand(cmdViewGetThreshold)
	cmdViewGetTransactionHash := CreateGetTransactionHashCommand()
	cmdViewGetTransactionHash.GroupID = ViewGroup.ID
	cmd.AddCommand(cmdViewGetTransactionHash)
	cmdViewIsModuleEnabled := CreateIsModuleEnabledCommand()
	cmdViewIsModuleEnabled.GroupID = ViewGroup.ID
	cmd.AddCommand(cmdViewIsModuleEnabled)
	cmdViewIsOwner := CreateIsOwnerCommand()
	cmdViewIsOwner.GroupID = ViewGroup.ID
	cmd.AddCommand(cmdViewIsOwner)
	cmdViewNonce := CreateNonceCommand()
	cmdViewNonce.GroupID = ViewGroup.ID
	cmd.AddCommand(cmdViewNonce)
	cmdViewSignedMessages := CreateSignedMessagesCommand()
	cmdViewSignedMessages.GroupID = ViewGroup.ID
	cmd.AddCommand(cmdViewSignedMessages)
	cmdViewVERSION := CreateVersionCommand()
	cmdViewVERSION.GroupID = ViewGroup.ID
	cmd.AddCommand(cmdViewVERSION)

	cmdTransactAddOwnerWithThreshold := CreateAddOwnerWithThresholdCommand()
	cmdTransactAddOwnerWithThreshold.GroupID = TransactGroup.ID
	cmd.AddCommand(cmdTransactAddOwnerWithThreshold)
	cmdTransactApproveHash := CreateApproveHashCommand()
	cmdTransactApproveHash.GroupID = TransactGroup.ID
	cmd.AddCommand(cmdTransactApproveHash)
	cmdTransactChangeThreshold := CreateChangeThresholdCommand()
	cmdTransactChangeThreshold.GroupID = TransactGroup.ID
	cmd.AddCommand(cmdTransactChangeThreshold)
	cmdTransactDisableModule := CreateDisableModuleCommand()
	cmdTransactDisableModule.GroupID = TransactGroup.ID
	cmd.AddCommand(cmdTransactDisableModule)
	cmdTransactEnableModule := CreateEnableModuleCommand()
	cmdTransactEnableModule.GroupID = TransactGroup.ID
	cmd.AddCommand(cmdTransactEnableModule)
	cmdTransactExecTransaction := CreateExecTransactionCommand()
	cmdTransactExecTransaction.GroupID = TransactGroup.ID
	cmd.AddCommand(cmdTransactExecTransaction)
	cmdTransactExecTransactionFromModule := CreateExecTransactionFromModuleCommand()
	cmdTransactExecTransactionFromModule.GroupID = TransactGroup.ID
	cmd.AddCommand(cmdTransactExecTransactionFromModule)
	cmdTransactExecTransactionFromModuleReturnData := CreateExecTransactionFromModuleReturnDataCommand()
	cmdTransactExecTransactionFromModuleReturnData.GroupID = TransactGroup.ID
	cmd.AddCommand(cmdTransactExecTransactionFromModuleReturnData)
	cmdTransactFallback := CreateFallbackCommand()
	cmdTransactFallback.GroupID = TransactGroup.ID
	cmd.AddCommand(cmdTransactFallback)
	cmdTransactReceive := CreateReceiveCommand()
	cmdTransactReceive.GroupID = TransactGroup.ID
	cmd.AddCommand(cmdTransactReceive)
	cmdTransactRemoveOwner := CreateRemoveOwnerCommand()
	cmdTransactRemoveOwner.GroupID = TransactGroup.ID
	cmd.AddCommand(cmdTransactRemoveOwner)
	cmdTransactSetFallbackHandler := CreateSetFallbackHandlerCommand()
	cmdTransactSetFallbackHandler.GroupID = TransactGroup.ID
	cmd.AddCommand(cmdTransactSetFallbackHandler)
	cmdTransactSetGuard := CreateSetGuardCommand()
	cmdTransactSetGuard.GroupID = TransactGroup.ID
	cmd.AddCommand(cmdTransactSetGuard)
	cmdTransactSetModuleGuard := CreateSetModuleGuardCommand()
	cmdTransactSetModuleGuard.GroupID = TransactGroup.ID
	cmd.AddCommand(cmdTransactSetModuleGuard)
	cmdTransactSetup := CreateSetupCommand()
	cmdTransactSetup.GroupID = TransactGroup.ID
	cmd.AddCommand(cmdTransactSetup)
	cmdTransactSimulateAndRevert := CreateSimulateAndRevertCommand()
	cmdTransactSimulateAndRevert.GroupID = TransactGroup.ID
	cmd.AddCommand(cmdTransactSimulateAndRevert)
	cmdTransactSwapOwner := CreateSwapOwnerCommand()
	cmdTransactSwapOwner.GroupID = TransactGroup.ID
	cmd.AddCommand(cmdTransactSwapOwner)

	return cmd
}

// SafeOperationType represents the type of operation for a Safe transaction
type SafeOperationType uint8

const (
	Call         SafeOperationType = 0
	DelegateCall SafeOperationType = 1
)

// String returns the string representation of the SafeOperationType
func (o SafeOperationType) String() string {
	switch o {
	case Call:
		return "Call"
	case DelegateCall:
		return "DelegateCall"
	default:
		return "Unknown"
	}
}

// SafeTransactionData represents the data for a Safe transaction
type SafeTransactionData struct {
	To             string            `json:"to"`
	Value          string            `json:"value"`
	Data           string            `json:"data"`
	Operation      SafeOperationType `json:"operation"`
	SafeTxGas      uint64            `json:"safeTxGas"`
	BaseGas        uint64            `json:"baseGas"`
	GasPrice       string            `json:"gasPrice"`
	GasToken       string            `json:"gasToken"`
	RefundReceiver string            `json:"refundReceiver"`
	Nonce          uint64            `json:"nonce"`
	SafeTxHash     string            `json:"safeTxHash"`
	Sender         string            `json:"sender"`
	Signature      string            `json:"signature"`
	Origin         string            `json:"origin"`
}

const (
	NativeTokenAddress = "0x0000000000000000000000000000000000000000"
)

func DeployWithSafe(client *ethclient.Client, key *keystore.Key, safeAddress common.Address, factoryAddress common.Address, value *big.Int, safeApi string, deployBytecode []byte, safeOperationType SafeOperationType, salt [32]byte) error {
	abi, err := CreateCall.CreateCallMetaData.GetAbi()
	if err != nil {
		return fmt.Errorf("failed to get ABI: %v", err)
	}

	safeCreateCallTxData, err := abi.Pack("performCreate2", value, deployBytecode, salt)
	if err != nil {
		return fmt.Errorf("failed to pack performCreate2 transaction: %v", err)
	}

	return CreateSafeProposal(client, key, safeAddress, factoryAddress, safeCreateCallTxData, value, safeApi, SafeOperationType(safeOperationType))
}

func CreateSafeProposal(client *ethclient.Client, key *keystore.Key, safeAddress common.Address, to common.Address, data []byte, value *big.Int, safeApi string, safeOperationType SafeOperationType) error {
	chainID, err := client.ChainID(context.Background())
	if err != nil {
		return fmt.Errorf("failed to get chain ID: %v", err)
	}

	// Create a new instance of the GnosisSafe contract
	safeInstance, err := GnosisSafe.NewGnosisSafe(safeAddress, client)
	if err != nil {
		return fmt.Errorf("failed to create GnosisSafe instance: %v", err)
	}

	// Fetch the current nonce from the Safe contract
	nonce, err := safeInstance.Nonce(&bind.CallOpts{})
	if err != nil {
		return fmt.Errorf("failed to fetch nonce from Safe contract: %v", err)
	}

	safeTransactionData := SafeTransactionData{
		To:             to.Hex(),
		Value:          value.String(),
		Data:           common.Bytes2Hex(data),
		Operation:      safeOperationType,
		SafeTxGas:      0,
		BaseGas:        0,
		GasPrice:       "0",
		GasToken:       NativeTokenAddress,
		RefundReceiver: NativeTokenAddress,
		Nonce:          nonce.Uint64(),
	}

	// Calculate SafeTxHash
	safeTxHash, err := CalculateSafeTxHash(safeAddress, safeTransactionData, chainID)
	if err != nil {
		return fmt.Errorf("failed to calculate SafeTxHash: %v", err)
	}

	// Sign the SafeTxHash
	signature, err := crypto.Sign(safeTxHash.Bytes(), key.PrivateKey)
	if err != nil {
		return fmt.Errorf("failed to sign SafeTxHash: %v", err)
	}

	// Adjust V value for Ethereum's replay protection
	signature[64] += 27

	// Convert signature to hex
	senderSignature := "0x" + common.Bytes2Hex(signature)

	// Prepare the request body
	requestBody := map[string]interface{}{
		"to":             safeTransactionData.To,
		"value":          safeTransactionData.Value,
		"data":           "0x" + safeTransactionData.Data,
		"operation":      int(safeTransactionData.Operation),
		"safeTxGas":      fmt.Sprintf("%d", safeTransactionData.SafeTxGas),
		"baseGas":        fmt.Sprintf("%d", safeTransactionData.BaseGas),
		"gasPrice":       safeTransactionData.GasPrice,
		"gasToken":       safeTransactionData.GasToken,
		"refundReceiver": safeTransactionData.RefundReceiver,
		"nonce":          fmt.Sprintf("%d", safeTransactionData.Nonce),
		"safeTxHash":     safeTxHash.Hex(),
		"sender":         key.Address.Hex(),
		"signature":      senderSignature,
		"origin":         fmt.Sprintf("{\"url\":\"%s\",\"name\":\"TokenSender Deployment\"}", safeApi),
	}

	// Marshal the request body to JSON
	jsonBody, err := json.Marshal(requestBody)
	if err != nil {
		return fmt.Errorf("failed to marshal request body: %v", err)
	}

	// Send the request to the Safe Transaction Service
	req, err := http.NewRequest("POST", safeApi, bytes.NewBuffer(jsonBody))
	if err != nil {
		return fmt.Errorf("failed to create request: %v", err)
	}

	req.Header.Set("Content-Type", "application/json")

	httpClient := &http.Client{}
	resp, err := httpClient.Do(req)
	if err != nil {
		return fmt.Errorf("failed to send request: %v", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK && resp.StatusCode != http.StatusCreated {
		return fmt.Errorf("unexpected status code: %d", resp.StatusCode)
	}

	fmt.Println("Safe proposal created successfully")
	return nil
}

func CalculateSafeTxHash(safeAddress common.Address, txData SafeTransactionData, chainID *big.Int) (common.Hash, error) {
	domainSeparator := apitypes.TypedDataDomain{
		ChainId:           (*math.HexOrDecimal256)(chainID),
		VerifyingContract: safeAddress.Hex(),
	}

	typedData := apitypes.TypedData{
		Types: apitypes.Types{
			"EIP712Domain": []apitypes.Type{
				{Name: "chainId", Type: "uint256"},
				{Name: "verifyingContract", Type: "address"},
			},
			"SafeTx": []apitypes.Type{
				{Name: "to", Type: "address"},
				{Name: "value", Type: "uint256"},
				{Name: "data", Type: "bytes"},
				{Name: "operation", Type: "uint8"},
				{Name: "safeTxGas", Type: "uint256"},
				{Name: "baseGas", Type: "uint256"},
				{Name: "gasPrice", Type: "uint256"},
				{Name: "gasToken", Type: "address"},
				{Name: "refundReceiver", Type: "address"},
				{Name: "nonce", Type: "uint256"},
			},
		},
		Domain:      domainSeparator,
		PrimaryType: "SafeTx",
		Message: apitypes.TypedDataMessage{
			"to":             txData.To,
			"value":          txData.Value,
			"data":           "0x" + txData.Data,
			"operation":      fmt.Sprintf("%d", txData.Operation),
			"safeTxGas":      fmt.Sprintf("%d", txData.SafeTxGas),
			"baseGas":        fmt.Sprintf("%d", txData.BaseGas),
			"gasPrice":       txData.GasPrice,
			"gasToken":       txData.GasToken,
			"refundReceiver": txData.RefundReceiver,
			"nonce":          fmt.Sprintf("%d", txData.Nonce),
		},
	}

	typedDataHash, _, err := apitypes.TypedDataAndHash(typedData)
	if err != nil {
		return common.Hash{}, fmt.Errorf("failed to hash typed data: %v", err)
	}

	return common.BytesToHash(typedDataHash), nil
}
